"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5516],{4668:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var r=s(4848),t=s(8453);const i={sidebar_position:8},o="Embracing Terseness: Functional Forms and Parse Trees",a={id:"concepts/functionalSelect",title:"Embracing Terseness: Functional Forms and Parse Trees",description:"Over the past few weeks, we've explored a lot about querying data, starting with Q-SQL and progressing to the powerful capabilities of the fby operator. Now, there are only two topics left to dive into: the functional form of Q-SQL statements and parse trees. The functional form offers a more concise way of writing Q-SQL, and it ties closely to the concept of parse trees, which we will also cover. After that, we'll move on to joins, which will be explored in an upcoming blog post.",source:"@site/docs/concepts/functionalSelect.mdx",sourceDirName:"concepts",slug:"/concepts/functionalSelect",permalink:"/docs/concepts/functionalSelect",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Mastering the Art of Filtering: An In-Depth Look at fby in KDB/Q",permalink:"/docs/concepts/fby"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},l={},c=[{value:"Why Functional Form Matters",id:"why-functional-form-matters",level:2},{value:"Parse Trees: The Key to Dynamic Queries",id:"parse-trees-the-key-to-dynamic-queries",level:2},{value:"<code>eval</code> vs <code>value</code>",id:"eval-vs-value",level:3},{value:"<code>parse</code>: Your Ultimate Helper Tool for Buidling Parse Trees",id:"parse-your-ultimate-helper-tool-for-buidling-parse-trees",level:3},{value:"Parse Gotchas",id:"parse-gotchas",level:3},{value:"Functional Forms",id:"functional-forms",level:2},{value:"Performance: Functional Form vs Traditional Q-SQL",id:"performance-functional-form-vs-traditional-q-sql",level:3},{value:"When Should You Use the Functional Form?",id:"when-should-you-use-the-functional-form",level:3},{value:"The Syntax",id:"the-syntax",level:3},{value:"<code>parse</code>: Your Go-To Tool for Building Functional Forms",id:"parse-your-go-to-tool-for-building-functional-forms",level:3},{value:"Three Key Gotchas When Using <code>parse</code> for Functional Forms",id:"three-key-gotchas-when-using-parse-for-functional-forms",level:4},{value:"The <code>parse</code> output will be displayed as <code>k</code> code",id:"the-parse-output-will-be-displayed-as-k-code",level:5},{value:"The <code>where clause</code> includes an extra commma at the beginning",id:"the-where-clause-includes-an-extra-commma-at-the-beginning",level:5},{value:"Symbols must be enlisted to be recognised as variables",id:"symbols-must-be-enlisted-to-be-recognised-as-variables",level:5},{value:"Escaping Strings: Essential When Using <code>parse</code>",id:"escaping-strings-essential-when-using-parse",level:5},{value:"ABC: Your Memory Hack for Functional Form Mastery",id:"abc-your-memory-hack-for-functional-form-mastery",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"embracing-terseness-functional-forms-and-parse-trees",children:"Embracing Terseness: Functional Forms and Parse Trees"}),"\n",(0,r.jsxs)(n.p,{children:["Over the past few weeks, we've explored a lot about querying data, starting with Q-SQL and progressing to the powerful capabilities of the ",(0,r.jsx)(n.code,{children:"fby"})," operator. Now, there are only two topics left to dive into: the functional form of Q-SQL statements and parse trees. The functional form offers a more concise way of writing Q-SQL, and it ties closely to the concept of parse trees, which we will also cover. After that, we'll move on to ",(0,r.jsx)(n.strong,{children:"joins"}),", which will be explored in an upcoming blog post."]}),"\n",(0,r.jsx)(n.h2,{id:"why-functional-form-matters",children:"Why Functional Form Matters"}),"\n",(0,r.jsxs)(n.p,{children:["Understanding and applying the functional form of Q-SQL statements in KDB/Q is essential. The functional form offers numerous advantages over traditional Q-SQL, including the flexibility to dynamically select columns and build ",(0,r.jsx)(n.code,{children:"where clauses"}),". Mastery of the functional form and the ability to translate Q-SQL statements into it is a crucial skill for any KDB/Q programmer. Consider a simple example where we need an API that allows a user to dynamically choose data from a table. We\u2019ll develop two APIs: one using conventional Q-SQL and one with the equivalent functional form. This example will clearly demonstrate why knowing the functional form of a Q-SQL query is so valuable."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// First, let's create a trade table we can select from\nq)show trade:([] sym:100?`AAPL`FB`MSFT`GOOG; price:100?100.)\nsym  price\n-------------\nMSFT 78.33686\nFB   40.99561\nFB   61.08817\nFB   49.76492\nMSFT 40.87545\nGOOG 44.9731\nAAPL 1.392076\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nFB   62.03014\nMSFT 93.26316\nFB   27.47066\nFB   5.752516\nAAPL 25.60658\n..\n// Let's have a quick look at our data\nq)select count i by sym from trade\nsym | x\n----| --\nAAPL| 29\nFB  | 20\nGOOG| 21\nMSFT| 30\n"})}),"\n",(0,r.jsxs)(n.p,{children:["First, we would like to write a simple API that allows the user to select data for specific symbols. In simple Q-SQL, the query is straightforward: ",(0,r.jsx)(n.code,{children:"select from trader where sym in `GOOG`MSFT"}),". But how can we make this dynamic, allowing symbols to be passed in at runtime? Here\u2019s a useful trick: we construct a string with our Q-SQL query, then use the ",(0,r.jsx)(n.code,{children:"value"})," operator to evaluate it. Let\u2019s give it a try!"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)select from trade where sym in `GOOG`MSFT\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)value "select from trade where sym in `GOOG`MSFT"\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)(select from trade where sym in `GOOG`MSFT)~value "select from trade where sym in `GOOG`MSFT"\n1b\n'})}),"\n",(0,r.jsx)(n.p,{children:"Since we know that evaluating the string version of our Q-SQL query produces the same result as running the query directly, we can now dynamically build this string. Let\u2019s go through the process step by step."}),"\n",(0,r.jsx)(n.p,{children:"The first part of our Q-SQL query is pretty straightforward, all we have to do is to build the where clause. Let's first store the symbols we are interested in, in a variable called col."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)show col:`GOOG`MSFT\n`GOOG`MSFT\n"})}),"\n",(0,r.jsxs)(n.p,{children:['Next, we have to build the string "',(0,r.jsx)(n.code,{children:"GOOG"}),"MSFT\" from this variable. Let's try to use the ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q/ref/string/",children:(0,r.jsx)(n.code,{children:"string"})}),"  keyword to achieve this."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)string col\n"GOOG"\n"MSFT"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["That doesn't look quite right, does it?!? Since the ",(0,r.jsx)(n.code,{children:"string"})," operator is atomic in KDB/Q, it applies individually to each element of the list, creating multiple separate strings instead of a single, cohesive one. Additionally, the backticks are missing, which can lead to a type error because the ",(0,r.jsx)(n.code,{children:"sym"})," column is of type ",(0,r.jsx)(n.code,{children:"symbol"}),", not ",(0,r.jsx)(n.code,{children:"string"}),". To resolve this, we\u2019ll use another powerful tool in KDB/Q: the ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q/ref/sv/",children:(0,r.jsx)(n.code,{children:"sv"})})," (",(0,r.jsx)(n.strong,{children:"s"}),"calar from ",(0,r.jsx)(n.strong,{children:"v"}),"ector) operator.. Let's have a look how this works."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"x sv y\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Given a list of strings ",(0,r.jsx)(n.code,{children:"y"}),", and a char atom ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"sv"})," returns the list of strings ",(0,r.jsx)(n.code,{children:"y"})," as a single string, separated by ",(0,r.jsx)(n.code,{children:"x"}),". Since we need a leading backtick at the beginning of our string, we\u2019ll prepend an empty symbol (a backtick) to the original list. This will produce the desired result."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)"`" sv string `GOOG`MSFT\n"GOOG`MSFT"\nq)"`" sv string ``GOOG`MSFT\n"`GOOG`MSFT"\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now, all that is left to do, is to concatenate the where clause we just created, with the initial part of our Q-SQL query and apply the value keyword to it. Let's do that."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)value "select from trade where sym in","`" sv string ``GOOG`MSFT\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)(select from trade where sym in `GOOG`MSFT)~value "select from trade where sym in","`" sv string ``GOOG`MSFT\n1b\n'})}),"\n",(0,r.jsx)(n.p,{children:"That worked like a charm. We can now reuse this piece of code to create our API."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'f:{[col] \n  query:"select from trade where sym in "; \n  query:query,"`" sv string `,col; \n  value query\n  };\n'})}),"\n",(0,r.jsx)(n.p,{children:"Let's test our API and call it with our symbols"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)f[`GOOG`MSFT]\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)(select from trade where sym in `GOOG`MSFT)~f[`GOOG`MSFT]\n1b\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Although our API functions as expected, we had to write quite a bit of code for a simple query. Imagine building something more complex \u2014 adding a ",(0,r.jsx)(n.code,{children:"by"})," clause or some aggregation. This would require even more code and string concatenation, which is not only inefficient but also prone to errors. A more efficient and reliable approach is to use the functional form of the Q-SQL query. The equivalent functional form of our Q-SQL example is ",(0,r.jsx)(n.code,{children:"?[`trade;enlist (in;`sym;enlist `GOOG`MSFT);0b;()]"}),". We'll explore how to construct the functional form later; for now, trust that this is the correct functional form."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)?[`trade;enlist (in;`sym;enlist `GOOG`MSFT);0b;()]\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)(select from trade where sym in `GOOG`MSFT)~?[`trade;enlist (in;`sym;enlist `GOOG`MSFT);0b;()]\n1b\n"})}),"\n",(0,r.jsx)(n.p,{children:"The functional form of a Q-SQL query simplifies API creation significantly, reducing this example to a single line of code."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"f:{[col] \n  ?[`trade;enlist (in;`sym;enlist col);0b;()]\n  };\n"})}),"\n",(0,r.jsx)(n.p,{children:"That was so much easier, wasn't it?!? Let's make sure our API returns the correct result"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)f[`GOOG`MSFT]\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)(select from trade where sym in `GOOG`MSFT)~f[`GOOG`MSFT]\n1b\n"})}),"\n",(0,r.jsx)(n.p,{children:"The functional form of a Q-SQL query simplifies API creation significantly, reducing this example to a single line of code. The example above clearly demonstrates the importance of the functional form for creating dynamic queries and APIs. Before diving deeper into functional forms, we\u2019ll take a brief detour to explore parse trees, as they are closely related to the functional form."}),"\n",(0,r.jsx)(n.h2,{id:"parse-trees-the-key-to-dynamic-queries",children:"Parse Trees: The Key to Dynamic Queries"}),"\n",(0,r.jsx)(n.p,{children:"In its most simple form, at its core, a Parse Tree is a list where the first element represents a function, and the subsequent elements are the arguments. Each of these elements can also be parse trees on their own. The below example should illustrate this concept"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// parse tree of "2+2"\nq)(+;2;2)\n+\n2\n2\n'})}),"\n",(0,r.jsx)(n.p,{children:"The general form of a Parse Tree is"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(function; arg 1; \u2026; arg n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["where every argument of the list, ",(0,r.jsx)(n.code,{children:"arg 1;...arg n"})," could be a parse tree itself."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Parse Tree Syntax",src:s(9701).A+"",width:"1210",height:"480"})}),"\n",(0,r.jsxs)(n.p,{children:["In order to evaluate a parse tree, we can use the keyword ",(0,r.jsx)(n.code,{children:"value"})," as we have seen in the previous section when evaluating the string form of a Q-SQL query."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)value (+;2;2)\n4\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Another operator that can evaluate parse trees is the ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q/ref/eval/#eval",children:(0,r.jsx)(n.code,{children:"eval"})}),", operator, as demonstrated below."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)eval (til;5)\n0 1 2 3 4\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"eval-vs-value",children:[(0,r.jsx)(n.code,{children:"eval"})," vs ",(0,r.jsx)(n.code,{children:"value"})]}),"\n",(0,r.jsxs)(n.p,{children:["Although ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q/ref/eval/#eval",children:(0,r.jsx)(n.code,{children:"eval"})})," and ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q/ref/value/",children:(0,r.jsx)(n.code,{children:"value"})})," appear to return the same result when evaluating the parse tree above, there is a key difference: ",(0,r.jsx)(n.code,{children:"eval"})," works on parse trees and evaluates any nested parse trees, while ",(0,r.jsx)(n.code,{children:"value"})," operates only on literals and does NOT evaluate nested parse trees. The below examples will illustrate these differences"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)value(+;7;3)                  //parse tree, with no nested trees\n10\nq)eval(+;7;3)\n10\nq)eval(+;7;(+;2;1))             //parse tree with nested trees\n10\nq)value(+;7;(+;2;1))\n'type\nq)value(,;`a;`b)\n`a`b\nq)eval(,;`a;`b)                 //no variable b defined\n'b\nq)eval(,;enlist `a;enlist `b)\n`a`b\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.p,{children:["NOTE: Symbols must be enlisted when evaluating a parse tree with ",(0,r.jsx)(n.code,{children:"eval"}),"; otherwise, they will be interpreted as variables."]})}),"\n",(0,r.jsxs)(n.h3,{id:"parse-your-ultimate-helper-tool-for-buidling-parse-trees",children:[(0,r.jsx)(n.code,{children:"parse"}),": Your Ultimate Helper Tool for Buidling Parse Trees"]}),"\n",(0,r.jsxs)(n.p,{children:["While parse trees may seem complex at first, creating them is actually quite simple, even for beginners. By using the ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q/ref/parse/",children:(0,r.jsx)(n.code,{children:"parse"})})," keyword, you can easily generate a parse tree from any KDB/Q statement represented as a string. Let's give it a try!"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)parse"2+2"\n+\n2\n2\nq)eval parse "2+2"\n4\n'})}),"\n",(0,r.jsxs)(n.p,{children:["As seen earlier, you can then use the ",(0,r.jsx)(n.code,{children:"eval"})," operator to evaluate a parse tree."]}),"\n",(0,r.jsx)(n.h3,{id:"parse-gotchas",children:"Parse Gotchas"}),"\n",(0,r.jsxs)(n.p,{children:["There are two main Gotchas to keep in mind with the ",(0,r.jsx)(n.code,{children:"parse"})," keyword, one of which we\u2019ve already covered. As mentioned, symbols must be enlisted to be used in parse trees. The other important point is that ",(0,r.jsx)(n.code,{children:"parse"})," displays all items in the parse tree using ",(0,r.jsx)(n.code,{children:"k"})," syntax.  Once you're aware of these two details, the ",(0,r.jsx)(n.code,{children:"parse"})," operator becomes a powerful and easy-to-use tool for creating parse trees."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)string `hello\n"hello"\nq)parse "string `hello"\n$:\n,`hello\nq)eval (string;enlist `hello)\n"hello"\nq)string\n$:\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The example above demonstrates the two main gotchas with the ",(0,r.jsx)(n.code,{children:"parse"})," keyword. All built-in KDB/Q operators are shown in their corresponding underlying ",(0,r.jsx)(n.code,{children:"k"})," syntax, and symbols must be enlisted."]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"k"})," syntax for ",(0,r.jsx)(n.code,{children:"enlist"})," is ",(0,r.jsx)(n.code,{children:","})]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)(,) `hello\n,`hello\nq)k),`hello\n,`hello\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"functional-forms",children:"Functional Forms"}),"\n",(0,r.jsxs)(n.p,{children:["In previous sections, we discussed the importance of using the functional form of a Q-SQL query and the reasons for doing so. Now, we'll examine the performance differences between the functional form and a pure Q-SQL statement, exploring when each should be used. We\u2019ll also cover the syntax of individual Q-SQL statements - ",(0,r.jsx)(n.code,{children:"select"}),", ",(0,r.jsx)(n.code,{children:"exec"}),", ",(0,r.jsx)(n.code,{children:"update"})," and `delete - and how to construct them."]}),"\n",(0,r.jsx)(n.h3,{id:"performance-functional-form-vs-traditional-q-sql",children:"Performance: Functional Form vs Traditional Q-SQL"}),"\n",(0,r.jsx)(n.p,{children:"First things first, let's address what interests most people: performance. Is there a performance advantage to using the functional form of a Q-SQL query over a standard Q-SQL statement? The short answer is: NO. The slightly longer answer is that while there may be a minimal performance gain when using the functional form, it\u2019s so minor that it\u2019s negligible. KDB/Q actually translates every Q-SQL statement into its functional form behind the scenes before executing it."}),"\n",(0,r.jsx)(n.p,{children:"To illustrate, if we measure the time it takes to parse a simple Q-SQL statement, we see that even parsing it a million times takes under a second. Only when we reach ten million parses does the time reach eight seconds."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)\\ts:100 parse "select from trade"\n0 912\nq)\\ts:10000 parse "select from trade"\n20 912\nq)\\ts:1000000 parse "select from trade"\n822 912\nq)\\ts:10000000 parse "select from trade"\n8156 912\n'})}),"\n",(0,r.jsx)(n.p,{children:"It's highly unlikely that any KDB/Q code will hit ten million Q-SQL queries. Admittedly, I used a very simple query here, and more complex ones might take longer, but it\u2019s reasonable to assume that the time difference for parsing more complex queries remains negligible as well."}),"\n",(0,r.jsx)(n.h3,{id:"when-should-you-use-the-functional-form",children:"When Should You Use the Functional Form?"}),"\n",(0,r.jsx)(n.p,{children:"So, when should you use the functional form instead of a traditional Q-SQL statement? The answer is simple: only when absolutely necessary. If you're building an API that requires dynamically generated queries, with user-parameterized inputs - go ahead. This is This is an ideal case for the functional form."}),"\n",(0,r.jsx)(n.p,{children:"But if your reason is just to save a few characters, show off your skills, or impress colleagues - don't. Think twice. We've just discovered that there's virtually no (or minimal) performance benefit to functional queries over traditional Q-SQL. So why make the code harder to read for others (or even yourself later on)? The functional form of a Q-SQL query is generally more challenging to read and understand. And we all know developers don't always comment code as thoroughly as they should. So, unless there\u2019s a compelling reason to use the functional form over a traditional Q-SQL statement, stick with the straightforward approach."}),"\n",(0,r.jsx)(n.h3,{id:"the-syntax",children:"The Syntax"}),"\n",(0,r.jsx)(n.p,{children:"Every Q-SQL statement has its corresponding functional form. The general syntax of the functional forms is"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Functional Form Syntax",src:s(4243).A+"",width:"1120",height:"380"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"?[t;c;b;a]              /select or exec\n![t;c;b;a]              /update and delete\n\n?[t;i;p]                /simple exec\n\n?[t;c;b;a;n]            /select up to n records\n?[t;c;b;a;n;(g;cn)]     /select up to n records sorted by g on cn\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"where"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"t"})," is a table, or the name of a table as a symbol atom."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"c"})," is the ",(0,r.jsx)(n.code,{children:"where clause"}),", a list of constrains represented as a list of parse trees. As in a traditional Q-SQL statement, the selection is performed in the order of the items in c, from left to right: only rows selected by one constraint are evaluated by the next."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"b"})," is the ",(0,r.jsx)(n.code,{children:"by phrase"}),". The ",(0,r.jsx)(n.code,{children:"by phrase"})," can have the following forms","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"the general empty list (), indicating that the functional form is of an exec rather than a select statement"}),"\n",(0,r.jsxs)(n.li,{children:["a boolean atom: ",(0,r.jsx)(n.code,{children:"0b"})," for no grouping, ",(0,r.jsx)(n.code,{children:"1b"})," for distinct rows"]}),"\n",(0,r.jsx)(n.li,{children:"a symbol atom or a list naming table column(s)"}),"\n",(0,r.jsx)(n.li,{children:"a dictionary of group-by specifications"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"a"})," is the ",(0,r.jsx)(n.code,{children:"select phrase"})," and can take one of the following forms","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"the general empty list ()"}),"\n",(0,r.jsx)(n.li,{children:"a symbol atom: the name of a table column"}),"\n",(0,r.jsx)(n.li,{children:"a parse tree: Each item of its range is an evaluation list consisting of a function and its argument(s)"}),"\n",(0,r.jsx)(n.li,{children:"a dictionary of select specifications (aggregations)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"i"})," is a list of indexes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"p"})," is a parse tree"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"n"})," is a non-negative integer or infinity, indicating the maximum number of records to be returned"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"g"})," is a unary grade function"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["A comprehensive discussion of each functional form is beyond the scope of this blog post, as ",(0,r.jsx)(n.a,{href:"https://code.kx.com/home/",children:"KX"})," has already covered this in detail on their website here: ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q/basics/funsql/",children:"Functional qSQL"}),". That said, I\u2019ll show you how you can easily transform any Q-SQL query into its equivalent functional form."]}),"\n",(0,r.jsxs)(n.h3,{id:"parse-your-go-to-tool-for-building-functional-forms",children:[(0,r.jsx)(n.code,{children:"parse"}),": Your Go-To Tool for Building Functional Forms"]}),"\n",(0,r.jsxs)(n.p,{children:["We\u2019ve already explored how the ",(0,r.jsx)(n.code,{children:"parse"})," keyword can generate a parse tree from any KDB/Q expression. However, one of the most practical uses of ",(0,r.jsx)(n.code,{children:"parse"})," is for translating Q-SQL queries into their equivalent functional form. Take, for example, the initial Q-SQL query we used in our simple API: ",(0,r.jsx)(n.code,{children:"select from trade where sym in `GOOG`MSFT"}),". By wrapping this query in quotation marks and applying the ",(0,r.jsx)(n.code,{children:"parse"})," operator, we can easily obtain the corresponding functional form."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)parse "select from trade where sym in `GOOG`MSFT"\n?\n`trade\n,,(in;`sym;,`GOOG`MSFT)\n0b\n()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["It's that simple. If we now evaluate our parse tree using ",(0,r.jsx)(n.code,{children:"eval"})," we get the same result as with our traditional Q-SQL query. This can easily be verified."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)eval parse "select from trade where sym in `GOOG`MSFT"\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)(select from trade where sym in `GOOG`MSFT)~eval parse "select from trade where sym in `GOOG`MSFT"\n1b\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If you're new to parse trees and functional forms, the functional form generated by the ",(0,r.jsx)(n.code,{children:"parse"})," keyword might look a bit unfamiliar \u2014 it is, after all, returned in ",(0,r.jsx)(n.code,{children:"k"})," code. Additionally, there are two main nuances to be aware of. Let\u2019s break these down for clarity."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Functional Form Parse Tree Syntax",src:s(4274).A+"",width:"1120",height:"380"})}),"\n",(0,r.jsxs)(n.p,{children:["The first thing to notice is that the ",(0,r.jsx)(n.code,{children:"where clause"})," in the functional form has an extra comma at the start, which we should ignore. As ",(0,r.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#912-functional-forms",children:(0,r.jsx)(n.strong,{children:"KX"})}),' explains: "The constraint portion of the result of ',(0,r.jsx)(n.code,{children:"parse"})," applied to a string containing a q-sql query template generally has an extra level of ",(0,r.jsx)(n.code,{children:"enlist"})," that should be removed for the corresponding functional form. In the console, this extra enlist shows up in ",(0,r.jsx)(n.code,{children:"k"})," form as a double comma ",(0,r.jsx)(n.code,{children:", , "}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The second comma has a simple explanation: The ",(0,r.jsx)(n.code,{children:"where clause"})," constraint is represented as a ",(0,r.jsx)(n.strong,{children:"list"})," of constraints in the parse tree format. Since our example has only one constraint (a single ",(0,r.jsx)(n.code,{children:"where clause"}),"), we need to create a list of constraints by using ",(0,r.jsx)(n.code,{children:"enlist"})," on the result."]}),"\n",(0,r.jsx)(n.p,{children:"Considering the above, our where clause can be rewritten as"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"enlist (in;`sym;,`GOOG`MSFT)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The second observation we make, is that in a parse tree, a variable is represented by a symbol that holds its name. So, when representing a symbol or list of symbols, you must use ",(0,r.jsx)(n.code,{children:"enlist"})," before that expression. In ",(0,r.jsx)(n.code,{children:"k"}),", ",(0,r.jsx)(n.code,{children:"enlist"})," is the unary form of the comma operator. If you omit this step, KDB/Q will attempt to interpret ",(0,r.jsx)(n.code,{children:"GOOG"})," and ",(0,r.jsx)(n.code,{children:"MSFT"})," as column names in the ",(0,r.jsx)(n.code,{children:"trade"})," table instead of as variables. Therefore, we need to rewrite the ",(0,r.jsx)(n.code,{children:"where clause"})," as follows."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"enlist (in;`sym;enlist `GOOG`MSFT)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Applying these changes to our initial result from parse we obtain the following functional form for our simple Q-SQL query"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)?[`trade;enlist (in;`sym;enlist `GOOG`MSFT);0b;()]\nsym  price\n-------------\nMSFT 78.33686\nMSFT 40.87545\nGOOG 44.9731\nGOOG 71.48779\nMSFT 19.46509\nMSFT 9.059026\nMSFT 93.26316\nGOOG 23.10108\nMSFT 86.71096\nMSFT 72.78528\nGOOG 16.27662\nGOOG 81.77547\nMSFT 41.2317\nMSFT 38.67353\nGOOG 72.6781\n..\nq)(select from trade where sym in `GOOG`MSFT)~?[`trade;enlist (in;`sym;enlist `GOOG`MSFT);0b;()]\n1b\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"parse"})," for more complex Q-SQL queries may seem a bit challenging at first, but you can break it down step-by-step. Just keep in mind:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"parse"})," output will be displayed as ",(0,r.jsx)(n.code,{children:"k"})," code"]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"where clause"})," includes an extra commma at the beginning"]}),"\n",(0,r.jsx)(n.li,{children:"Symbols must be enlisted to be recognised as variables"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Let's look at ta more complex example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)select sym,price from trade where price=(max;price) fby sym\nsym  price\n-------------\nAAPL 95.98964\nFB   98.77844\nGOOG 91.49882\nMSFT 97.97281\n\nq)parse \"select sym,price from trade where price=(max;price) fby sym\"\n?\n`trade\n,,(=;`price;(k){$[(#x 1)=#y;@[(#y)#x[0]0#x 1;g;:;x[0]'x[1]g:.=y];'`length]};(enlist;max;`price);`sym))\n0b\n`sym`price!`sym`price\n\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["If you would like to learn more about the ",(0,r.jsx)(n.code,{children:"fby"})," operator, read my previous blog post ",(0,r.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/fby",children:"Mastering the Art of Filtering: An In-Depth Look at fby in KDB/Q"})]})}),"\n",(0,r.jsxs)(n.p,{children:["This may look like quite a bit of gibberish at first glance. Following the low-hanging-fruit principle, let\u2019s start with the straightforward parts of the functional form. The table, ",(0,r.jsx)(n.code,{children:"by clause"}),", and ",(0,r.jsx)(n.code,{children:"select clause"})," can be directly copied into our functional form. The only thing left to decipher is the ",(0,r.jsx)(n.code,{children:"where clause"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"?[`trade; To-Do; 0b; `sym`price!`sym`price]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When looking at the ",(0,r.jsx)(n.code,{children:"where clause"}),", it\u2019s important to remember that it\u2019s represented as a parse tree or list of parse trees, displayed in ",(0,r.jsx)(n.code,{children:"k"})," code. By parsing the ",(0,r.jsx)(n.code,{children:"where clause"})," independently, we can simplify our task significantly."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)parse \"price=(max;price) fby sym\"\n=\n`price\n(k){$[(#x 1)=#y;@[(#y)#x[0]0#x 1;g;:;x[0]'x[1]g:.=y];'`length]};(enlist;max;`price);`sym)\n"})}),"\n",(0,r.jsx)(n.p,{children:"This can be translated into the following parse tree"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(=;`price; (k){$[(#x 1)=#y;@[(#y)#x[0]0#x 1;g;:;x[0]'x[1]g:.=y];'`length]};(enlist;max;`price);`sym))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["From our Q-SQL query, we know that our ",(0,r.jsx)(n.code,{children:"where clause"})," includes a ",(0,r.jsx)(n.code,{children:"fby"}),". So let's examine the ",(0,r.jsx)(n.code,{children:"k"})," code representation of the ",(0,r.jsx)(n.code,{children:"fby"})," to understand it better."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)fby\nk){$[(#x 1)=#y;@[(#y)#x[0]0#x 1;g;:;x[0]'x[1]g:.=y];'`length]}\n"})}),"\n",(0,r.jsxs)(n.p,{children:['This aligns with some of the "gibberish" we saw when parsing the ',(0,r.jsx)(n.code,{children:"where clause"})," independently. Now we can simply convert the ",(0,r.jsx)(n.code,{children:"k"})," code into ",(0,r.jsx)(n.code,{children:"q"})," code to make it more readable."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(=;`price;(fby;(enlist;max;`price)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Combining everything above we obtain the following functional form for our complex Q-SQL query"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)?[`trade;enlist (=;`price;(fby;(enlist;max;`price);`sym));0b;`sym`price!`sym`price]\nsym  price\n-------------\nAAPL 95.98964\nFB   98.77844\nGOOG 91.49882\nMSFT 97.97281\n"})}),"\n",(0,r.jsx)(n.p,{children:"Verifying that the results actually matches"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)(select sym,price from trade where price=(max;price) fby sym)~?[`trade;enlist (=;`price;(fby;(enlist;max;`price);`sym));0b;`sym`price!`sym`price]\n1b\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"three-key-gotchas-when-using-parse-for-functional-forms",children:["Three Key Gotchas When Using ",(0,r.jsx)(n.code,{children:"parse"})," for Functional Forms"]}),"\n",(0,r.jsxs)(n.p,{children:["As we have seen, there are a few subtle gotchas when using the ",(0,r.jsx)(n.code,{children:"parse"})," operator with Q-SQL queries. To help you remember these, let's review them one more time."]}),"\n",(0,r.jsxs)(n.h5,{id:"the-parse-output-will-be-displayed-as-k-code",children:["The ",(0,r.jsx)(n.code,{children:"parse"})," output will be displayed as ",(0,r.jsx)(n.code,{children:"k"})," code"]}),"\n",(0,r.jsxs)(n.p,{children:["As we've observed, the output of the ",(0,r.jsx)(n.code,{children:"parse"})," operator is actual ",(0,r.jsx)(n.code,{children:"k"})," code. This applies not only to common ",(0,r.jsx)(n.code,{children:"q"})," operators but also to ",(0,r.jsx)(n.code,{children:"q"})," keywords, which can be implemented in ",(0,r.jsx)(n.code,{children:"k"})," behind the scenes. This can make interpreting the parsed query output a bit more challenging. However, you can simplify this by comparing the parsed output directly with your original Q-SQL query to identify any ",(0,r.jsx)(n.code,{children:"q"})," keywords that have been translated into their ",(0,r.jsx)(n.code,{children:"k"})," equivalent."]}),"\n",(0,r.jsx)(n.p,{children:"For example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)parse "select first price from trade"\n?\n`trade\n()\n0b\n(,`price)!,(*:;`price)\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Examining the ",(0,r.jsx)(n.code,{children:"select phrase"})," of the above Q-SQL query and seeing that we selected ",(0,r.jsx)(n.code,{children:"first price"}),", we do realise that the corresponding ",(0,r.jsx)(n.code,{children:"k"})," operator for the ",(0,r.jsx)(n.code,{children:"first"})," ",(0,r.jsx)(n.code,{children:"q"})," operator is `*:. Let's confirm this"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"q)first 1 2 3\n1\nq)k)*1 2 3\n1\nq)(*:)1 2 3\n1\n"})}),"\n",(0,r.jsxs)(n.h5,{id:"the-where-clause-includes-an-extra-commma-at-the-beginning",children:["The ",(0,r.jsx)(n.code,{children:"where clause"})," includes an extra commma at the beginning"]}),"\n",(0,r.jsxs)(n.p,{children:["Another nuance we've encountered is that the parsed ",(0,r.jsx)(n.code,{children:"where clause"})," includes an extra comma at the beginning. This occurs because ",(0,r.jsx)(n.code,{children:"parse"})," applied to a Q-SQL query template often introduces an additional level of ",(0,r.jsx)(n.code,{children:"enlist"})," that needs to be removed for the functional form. In the console, the parse tree displays the ",(0,r.jsx)(n.code,{children:"k"})," form of enlist (",(0,r.jsx)(n.code,{children:","}),") as ",(0,r.jsx)(n.code,{children:",,"}),". This is easily corrected by simply removing the extra comma and using ",(0,r.jsx)(n.code,{children:"enlist"})," where necessary."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)parse "select from trade where sym=`GOOG"\n?\n`trade\n,,(=;`sym;,`GOOG)\n0b\n()\nq)(select from trade where sym=`GOOG)~?[`trade;enlist (=;`sym;enlist `GOOG);0b;()]\n1b\n'})}),"\n",(0,r.jsx)(n.h5,{id:"symbols-must-be-enlisted-to-be-recognised-as-variables",children:"Symbols must be enlisted to be recognised as variables"}),"\n",(0,r.jsxs)(n.p,{children:["In a parse tree, a variable is represented by a symbol containing its name. Therefore, to represent a single symbol or a list of symbols, you need to use ",(0,r.jsx)(n.code,{children:"enlist"})," on that expression. In ",(0,r.jsx)(n.code,{children:"k"}),", ",(0,r.jsx)(n.code,{children:"enlist"})," is the unary form of the comma operator, which can be a bit confusing initially but becomes intuitive with practice."]}),"\n",(0,r.jsxs)(n.p,{children:["This concept is especially clear when you try to parse a simple symbol. You'll see that the ",(0,r.jsx)(n.code,{children:"parse"})," operator adds ",(0,r.jsx)(n.code,{children:"enlist"})," to differentiate between a variable name and an actual symbol."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)parse "`google"\n,`google\n'})}),"\n",(0,r.jsxs)(n.h5,{id:"escaping-strings-essential-when-using-parse",children:["Escaping Strings: Essential When Using ",(0,r.jsx)(n.code,{children:"parse"})]}),"\n",(0,r.jsx)(n.p,{children:"The final gotcha to be aware of is that when parsing a string, you need to escape any quotation marks around it. This is necessary because the input to the parse operator is itself a string. Let\u2019s look at an example to clarify this."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)parse "select from trade where sym like "*GO*""\n\'GO\n  [0]  parse "select from trade where sym like "*GO*""\n                                                 ^\n'})}),"\n",(0,r.jsxs)(n.p,{children:["As you can see, omitting the escaped quotation marks when parsing a string results in an error. To parse a string, we need to use the escape character ",(0,r.jsx)(n.code,{children:"\\"})," to properly escape the quotation marks."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'q)parse "select from trade where sym like \\"*GO*\\""\n?\n`trade\n,,(like;`sym;"*GO*")\n0b\n()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"abc-your-memory-hack-for-functional-form-mastery",children:"ABC: Your Memory Hack for Functional Form Mastery"}),"\n",(0,r.jsxs)(n.p,{children:["I've conducted numerous (mock) interviews, and a common challenge for KDB/Q developers has been recalling the functional form syntax of a Q-SQL query. This is understandable, especially for junior developers or those who don\u2019t use functional forms frequently and often rely on the ",(0,r.jsx)(n.code,{children:"parse"}),' keyword to generate them. I once faced this challenge myself, which led me to create a memory hack that can help anyone remember the syntax effortlessly. Just think of "ABC" in reverse: "CBA." Here\u2019s how it works: the syntax for the functional form is ',(0,r.jsx)(n.code,{children:"? [t; c; b; a]"}),", where ",(0,r.jsx)(n.code,{children:"t"})," stands for ",(0,r.jsx)(n.strong,{children:"t"}),'able, followed by "CBA" in reverse order. ',(0,r.jsx)(n.strong,{children:"C"})," represents the where ",(0,r.jsx)(n.strong,{children:"c"}),"lause, ",(0,r.jsx)(n.strong,{children:"B"})," stands for the ",(0,r.jsx)(n.strong,{children:"b"}),"y clause, and ",(0,r.jsx)(n.strong,{children:"A"})," is the select or ",(0,r.jsx)(n.strong,{children:"a"}),"ggregation clause (remember ",(0,r.jsx)(n.strong,{children:"A"})," for ",(0,r.jsx)(n.strong,{children:"a"}),"ggregation if that helps!)."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Functional Form ABC Syntax",src:s(4491).A+"",width:"1120",height:"380"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"And that's it\u2014another topic complete! Happy coding, and feel free to reach out with any questions."})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Resources"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://code.kx.com/q/basics/parsetrees/",children:"Parse trees"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#912-functional-forms",children:"Q for Mortals, Chapter 9: Queries Q-SQL, 9.12 Functional Forms"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://code.kx.com/q/basics/funsql/",children:"Functional qSQL"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},4243:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/functionalForm-e1327a7dfa6b7841dba0ecfba97a1a94.png"},4491:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/functionalFormABC-d11160de0cb5eb0e294f229e8f7237bf.png"},4274:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/functionalFormParseTree-b519ad9e0ec2838bd44b922798365879.png"},9701:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/parseTree-4419ee96936581e9d646fa4f52e128e1.png"},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(6540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);