"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2585],{4151:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var i=t(4848),s=t(8453);const r={sidebar_position:6},a="QSQL - Querying Your Data",o={id:"concepts/qsql",title:"QSQL - Querying Your Data",description:"In our latest blog post, we've covered a lot about Dictionaries and Tables and explored how to store large volumes of data. Now, it's time to take the next step and dive into how we can access this data. How do we query it, filter for what we need, and manipulate the information to gain valuable insights? Just like other databases, KDB/Q comes with its own built-in querying language: Q-SQL. Contrary to popular belief, I find Q-SQL easier to use than traditional SQL, and it's significantly more performant. Thanks to KDB/Q's column-oriented database structure, which stores data as collections of lists rather than rows and keeps columns in contiguous memory, it's perfectly optimized for vectorized operations, delivering near-instant results. In this blog post, we'll explore the key concepts of the Q-SQL query language and how you can effectively access your data.",source:"@site/docs/concepts/qsql.mdx",sourceDirName:"concepts",slug:"/concepts/qsql",permalink:"/docs/concepts/qsql",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Dictionaries and Tables",permalink:"/docs/concepts/dictionariesTables"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},c={},l=[{value:"The <code>select</code> Statement",id:"the-select-statement",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Selecting Columns: The column(s) phrase",id:"selecting-columns-the-columns-phrase",level:3},{value:"Nested Columns: Handle with Care",id:"nested-columns-handle-with-care",level:4},{value:"Filtering Your Data: Mastering the Where Clause",id:"filtering-your-data-mastering-the-where-clause",level:3},{value:"Multiple Where Clauses",id:"multiple-where-clauses",level:4},{value:"The virtual column <code>i</code> in a <code>where clause</code>",id:"the-virtual-column-i-in-a-where-clause",level:4},{value:"Leveraging the Flexibility of KDB/Q: Writing Powerful Q-SQL Queries",id:"leveraging-the-flexibility-of-kdbq-writing-powerful-q-sql-queries",level:4},{value:"Demystifying the Magic of Where Clauses",id:"demystifying-the-magic-of-where-clauses",level:4},{value:"Grouping Data: The <code>by</code> clause",id:"grouping-data-the-by-clause",level:3},{value:"By clause demystified",id:"by-clause-demystified",level:4},{value:"How to Retrieve the Last Element for a Specific Identifier",id:"how-to-retrieve-the-last-element-for-a-specific-identifier",level:4},{value:"The <code>update</code> statement",id:"the-update-statement",level:2},{value:"Syntax",id:"syntax-1",level:3},{value:"Conformability Matters: Update Modifications Are Vector Operations",id:"conformability-matters-update-modifications-are-vector-operations",level:4},{value:"The <code>delete</code> Statement",id:"the-delete-statement",level:2},{value:"Syntax",id:"syntax-2",level:3},{value:"The <code>exec</code> Statement",id:"the-exec-statement",level:2},{value:"Syntax",id:"syntax-3",level:3},{value:"The Magic of <code>exec</code>",id:"the-magic-of-exec",level:4},{value:"Crafting Elegant Queries with exec: Simplify Your Q-SQL",id:"crafting-elegant-queries-with-exec-simplify-your-q-sql",level:4},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"qsql---querying-your-data",children:"QSQL - Querying Your Data"}),"\n",(0,i.jsxs)(n.p,{children:["In our latest blog post, we've covered a lot about ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/dictionariesTables",children:"Dictionaries and Tables"})," and explored how to store large volumes of data. Now, it's time to take the next step and dive into how we can access this data. How do we query it, filter for what we need, and manipulate the information to gain valuable insights? Just like other databases, KDB/Q comes with its own built-in querying language: ",(0,i.jsx)(n.strong,{children:"Q-SQL"}),". Contrary to popular belief, I find Q-SQL easier to use than traditional SQL, and it's significantly more performant. Thanks to KDB/Q's column-oriented database structure, which stores data as collections of lists rather than rows and keeps columns in contiguous memory, it's perfectly optimized for vectorized operations, delivering near-instant results. In this blog post, we'll explore the key concepts of the Q-SQL query language and how you can effectively access your data."]}),"\n",(0,i.jsxs)(n.h2,{id:"the-select-statement",children:["The ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#93-the-select-template",children:(0,i.jsx)(n.code,{children:"select"})})," Statement"]}),"\n",(0,i.jsxs)(n.p,{children:["The most common way to query your data is through the ",(0,i.jsx)(n.code,{children:"select"})," statement, which can range from simple, basic queries to more advanced and powerful data retrieval. In the following section, we\u2019ll discuss the syntax of the select statement and explore various methods for selecting data. Let\u2019s get started!"]}),"\n",(0,i.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Q-SQL Select Statement Syntax",src:t(9203).A+"",width:"1210",height:"480"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" select <columns phrase> <by phrase> from T<exp> <where phrase>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"column(s) phrase"}),":"]})," This specifies the columns you want to select. You can use the column phrase to rename or aggregate columns."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"by phrase"}),":"]})," To group your data by specific column(s), you can use the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"by"})})," phrase to organize the results accordingly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"T<exp>"}),":"]})," You can either select data directly from a specific table or use an expression as the data source for your select statement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"where phrase"}),":"]})," The where clause allows you to filter your dataset, narrowing it down to a smaller subset before making your (final) selection."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["It\u2019s crucial to remember the order in which the individual clauses of a ",(0,i.jsx)(n.code,{children:"select"})," statement are evaluated, particularly when optimizing queries for maximum efficiency. The evaluation order is as follows:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Texp"}),": The first clause to be evaluated is the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"from T<exp>"})})," expression, which defines the data source. If this is a straightforward table, no evaluation is necessary, making it almost instantaneous. However, as previously mentioned, ",(0,i.jsx)(n.code,{children:"T<exp>"})," can be any KDB/Q expression that returns a table."]}),"\n",(0,i.jsxs)(n.li,{children:["The next step is the evaluation of the ",(0,i.jsx)(n.strong,{children:"where phrase"}),". This filters your data, starting with the leftmost condition and progressively narrowing down the dataset for subsequent conditions. You can significantly improve performance by prioritizing the most restrictive condition first. We\u2019ll dive into this deeper later."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"by clause"})," is evaluated next, grouping your data based on specific columns."]}),"\n",(0,i.jsxs)(n.li,{children:["Lastly, the ",(0,i.jsx)(n.strong,{children:"column phrase"})," is executed, selecting the desired columns. You can also rename columns, perform calculations, or apply aggregations during this step."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's look at the individual phrases in more detail:"}),"\n",(0,i.jsxs)(n.p,{children:["In order to demonstrate the various forms, we\u2019ll create a simple ",(0,i.jsx)(n.code,{children:"trade"})," table as an example."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)show trade:([] sym:20?`AAPL`GOOG`IBM`MSFT;price:20?100.; quantity:20?1000;exchange:20?`LSE`NASDAQ`CBOE`NYSE)\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nAAPL 19.46509 850      CBOE\nIBM  9.059026 241      NASDAQ\nAAPL 62.03014 296      LSE\nAAPL 93.26316 216      NYSE\nAAPL 27.47066 717      NASDAQ\nGOOG 5.752516 414      CBOE\nAAPL 25.60658 657      CBOE\nGOOG 23.10108 890      NASDAQ\nIBM  8.724017 407      LSE\nMSFT 10.24432 635      NASDAQ\nMSFT 86.71096 108      CBOE\nIBM  72.78528 652      LSE\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"To keep this article concise, I will abbreviate table outputs where appropriate and where the full data isn't crucial for understanding. Complete tables will be provided whenever necessary to maintain clarity and context."})}),"\n",(0,i.jsx)(n.h3,{id:"selecting-columns-the-columns-phrase",children:"Selecting Columns: The column(s) phrase"}),"\n",(0,i.jsxs)(n.p,{children:['Let\u2019s begin with a simple and straightforward query: selecting all columns from a table without any filters. If you\u2019re familiar with SQL, this is the equivalent of the classic "Hello World" example for SQL, where you would write ',(0,i.jsx)(n.code,{children:"SELECT * FROM trade"})," (",(0,i.jsx)(n.a,{href:"https://www.w3schools.com/sql/sql_select.asp",children:"SQL SELECT reference"}),") to return all columns using the ",(0,i.jsx)(n.code,{children:"*"})," wildcard. But as ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"KDB/Q developers, we prefer our code to be concise and terse"})}),". So, instead of the unnecessary ",(0,i.jsx)(n.code,{children:"*"}),", we just write ",(0,i.jsx)(n.code,{children:"select from trade"}),". Moreover, we don\u2019t worry about capitalising our code either. Let\u2019s try it out!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Can we make it even more concise? Absolutely! Since a table is stored in a variable, we can just type ",(0,i.jsx)(n.code,{children:"trade"})," in the KDB/Q console to return the entire table. But be careful:"]}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsxs)(n.p,{children:["Do ",(0,i.jsx)(n.strong,{children:"NOT"})," try this with a large table in a production environment! (Actually you shouldn't have access to a production environment at all)"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\n...\n// Let's make sure that the results actually match\nq)trade~select from trade\n1b\n"})}),"\n",(0,i.jsx)(n.p,{children:"That was easy! Now, let\u2019s take it up a notch. If we want to select only a few specific columns from our table, we can do this by simply listing the columns we\u2019re interested in, separated by commas."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select sym,price from trade\nsym  price\n-------------\nMSFT 78.33686\nGOOG 40.99561\nMSFT 61.08817\nMSFT 49.76492\nIBM  40.87545\nAAPL 44.9731\nIBM  1.392076\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"That wasn't too difficult either. Now, let's try performing some calculations on our data. For example, if we want to calculate the nominal value for each row by multiplying the price column with the quantity column, here's how we can do it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select sym,price*quantity from trade\nsym  price\n-------------\nMSFT 3525.159\nGOOG 30541.73\nMSFT 54857.18\nMSFT 46530.2\nIBM  2616.029\nAAPL 7960.239\nIBM  331.3141\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note that KDB/Q will name the resulting column based on the first column it encounters in the calculation (in this case, price). You can rename the resulting column, as shown below. However, this is not an assignment\u2014 the original table remains unaltered. KDB/Q returns a copy of the data with the modifications applied."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select sym,nominal:price*quantity from trade\nsym  nominal\n-------------\nMSFT 3525.159\nGOOG 30541.73\nMSFT 54857.18\nMSFT 46530.2\nIBM  2616.029\nAAPL 7960.239\nIBM  331.3141\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can choose to assign this result to a new variable or leave it as is, but the original table will stay unchanged."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)tradeNew:select sym,nominal:price*quantity from trade\nq)tradeNew\nsym  nominal\n-------------\nMSFT 3525.159\nGOOG 30541.73\nMSFT 54857.18\nMSFT 46530.2\nIBM  2616.029\nAAPL 7960.239\nIBM  331.3141\n...\nq)trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But that's not all\u2014Q-SQL offers far more capabilities, even at a basic level. Below are a few examples with brief explanations. While covering its full potential is beyond the scope of this article, you can explore more in-depth details in ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/",children:(0,i.jsx)(n.em,{children:"Q for Mortals, Chapter 9: Queries-Q-SQL"})}),". Here, I\u2019ll focus on what I believe are the most important concepts."]}),"\n",(0,i.jsxs)(n.p,{children:["You can select the same column multiple times, and KDB/Q will automatically append a suffix to any duplicate column names. If KDB/Q cannot determine a column name, it will default to using ",(0,i.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select sym,price,sym,3*price+1 from trade\nsym  price    sym1 x\n---------------------------\nMSFT 78.33686 MSFT 238.0106\nGOOG 40.99561 GOOG 125.9868\nMSFT 61.08817 MSFT 186.2645\nMSFT 49.76492 MSFT 152.2948\nIBM  40.87545 IBM  125.6263\n"})}),"\n",(0,i.jsx)(n.p,{children:"One important point to remember when writing Q-SQL queries is that any time you create, rename, update, or modify a column, the changes will only take effect after the entire Q-SQL statement has been executed. This means you cannot create a new column and immediately reuse it within the same statement. Let me illustrate this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select avgPrice:avg price, avgQty:avg quantity, nominal: avgPrice*avgQty from trade\n'avgQty\n  [0]  select avgPrice:avg price, avgQty:avg quantity, nominal: avgPrice*avgQty from trade\n                                                                         ^\n"})}),"\n",(0,i.jsx)(n.p,{children:"As you can see from the error above, avgQty doesn't exist yet. To achieve this, you have to use a second Q-SQL query like below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select avgNominal:avgPrice*avgQty from select avgPrice:avg price, avgQty:avg quantity from trade\navgNominal\n----------\n19882.57\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Another useful feature of KDB/Q is the (hidden) virtual index, known as ",(0,i.jsx)(n.code,{children:"i"})," column, which you can utilize in your Q-SQL queries. Because this index is referenced as ",(0,i.jsx)(n.code,{children:"i"}),", it's best to avoid using ",(0,i.jsx)(n.code,{children:"i"})," as a column name. You can also incorporate the virtual index in the ",(0,i.jsx)(n.code,{children:"where"})," clause of your Q-SQL queries (more details on this later). One important thing to note is that the virtual index is not generated when the table is created, but only when it is referenced. Each time you reference it, the index is recreated, which can affect query performance as your dataset grows. The below examples illustrate this in more details."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Create a table called trade1 consisting of the first 5 rows of trade\n// Using the # take operator\nq)show trade1:5#trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\n// Selecting all columns including the virtal column i\nq)select i,sym,price,quantity,exchange from trade1\nx sym  price    quantity exchange\n---------------------------------\n0 MSFT 78.33686 45       LSE\n1 GOOG 40.99561 745      LSE\n2 MSFT 61.08817 898      CBOE\n3 MSFT 49.76492 935      NASDAQ\n4 IBM  40.87545 64       CBOE\n// Creating a subset of trade1 selecting only the last 3 rows using -3#\nq)select i,sym,price,quantity,exchange from -3#trade1\nx sym  price    quantity exchange\n---------------------------------\n0 MSFT 61.08817 898      CBOE\n1 MSFT 49.76492 935      NASDAQ\n2 IBM  40.87545 64       CBOE\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As shown in the last two examples above, when we select the virtual column ",(0,i.jsx)(n.code,{children:"i"})," in the first example, the index ranges from 0 to 4. However, when we use the ",(0,i.jsx)(n.code,{children:"# take"})," operator to select the last three rows of ",(0,i.jsx)(n.code,{children:"trade1"})," and then select the virtual index again, the index is updated. This demonstrates that the virtual column ",(0,i.jsx)(n.code,{children:"i"})," is generated each time it is referenced."]}),"\n",(0,i.jsxs)(n.p,{children:["Another powerful yet often overlooked feature of the ",(0,i.jsx)(n.code,{children:"select"})," template is the ",(0,i.jsx)(n.code,{children:"select [] from table"})," pattern. The expression within the square brackets allows you to select a subset of rows by specifying either a positive or negative number to retrieve the first or last ",(0,i.jsx)(n.code,{children:"n"})," rows, respectively. You can also provide a start index ",(0,i.jsx)(n.code,{children:"s"})," and the number ",(0,i.jsx)(n.code,{children:"n"})," of rows you want to return. Additionally, it's possible to sort the results in ",(0,i.jsx)(n.strong,{children:"ascending or descending"})," order based on a specific column. And, you can combine these features for even more flexibility. Let's explore some examples."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Selecting the first 5 rows\nq)select [5] from trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\n// Selecting the last 5 rows\nq)select [-5] from trade\nsym  price    quantity exchange\n-------------------------------\nGOOG 23.10108 890      NASDAQ\nIBM  8.724017 407      LSE\nMSFT 10.24432 635      NASDAQ\nMSFT 86.71096 108      CBOE\nIBM  72.78528 652      LSE\n// Starting at index 2, select 5 rows\nq)select [2 5] i,sym,price,quantity,exchange from trade\nx sym  price    quantity exchange\n---------------------------------\n2 MSFT 61.08817 898      CBOE\n3 MSFT 49.76492 935      NASDAQ\n4 IBM  40.87545 64       CBOE\n5 AAPL 44.9731  177      NASDAQ\n6 IBM  1.392076 238      CBOE\n// Select everything from trade in descending order by column sym\nq)select [>sym] from trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nMSFT 10.24432 635      NASDAQ\nMSFT 86.71096 108      CBOE\nIBM  40.87545 64       CBOE\nIBM  1.392076 238      CBOE\nIBM  9.059026 241      NASDAQ\nIBM  8.724017 407      LSE\nIBM  72.78528 652      LSE\nGOOG 40.99561 745      LSE\nGOOG 71.48779 361      NYSE\nGOOG 5.752516 414      CBOE\nGOOG 23.10108 890      NASDAQ\nAAPL 44.9731  177      NASDAQ\nAAPL 19.46509 850      CBOE\nAAPL 62.03014 296      LSE\nAAPL 93.26316 216      NYSE\nAAPL 27.47066 717      NASDAQ\nAAPL 25.60658 657      CBOE\n// Select everything from trade in ascending order by column price\nq)select [>price] i,sym,price,quantity,exchange from trade\nx  sym  price    quantity exchange\n----------------------------------\n11 AAPL 93.26316 216      NYSE\n18 MSFT 86.71096 108      CBOE\n0  MSFT 78.33686 45       LSE\n19 IBM  72.78528 652      LSE\n7  GOOG 71.48779 361      NYSE\n10 AAPL 62.03014 296      LSE\n2  MSFT 61.08817 898      CBOE\n3  MSFT 49.76492 935      NASDAQ\n5  AAPL 44.9731  177      NASDAQ\n1  GOOG 40.99561 745      LSE\n4  IBM  40.87545 64       CBOE\n12 AAPL 27.47066 717      NASDAQ\n14 AAPL 25.60658 657      CBOE\n15 GOOG 23.10108 890      NASDAQ\n8  AAPL 19.46509 850      CBOE\n17 MSFT 10.24432 635      NASDAQ\n9  IBM  9.059026 241      NASDAQ\n16 IBM  8.724017 407      LSE\n13 GOOG 5.752516 414      CBOE\n6  IBM  1.392076 238      CBOE\n// Select a subset\nq)select [2 5] i,sym,price,quantity,exchange from trade\nx sym  price    quantity exchange\n---------------------------------\n2 MSFT 61.08817 898      CBOE\n3 MSFT 49.76492 935      NASDAQ\n4 IBM  40.87545 64       CBOE\n5 AAPL 44.9731  177      NASDAQ\n6 IBM  1.392076 238      CBOE\n// Combine subset selection with ordering\nq)select [2 5;>price] i,sym,price,quantity,exchange from trade\nx  sym  price    quantity exchange\n----------------------------------\n0  MSFT 78.33686 45       LSE\n19 IBM  72.78528 652      LSE\n7  GOOG 71.48779 361      NYSE\n10 AAPL 62.03014 296      LSE\n2  MSFT 61.08817 898      CBOE\n"})}),"\n",(0,i.jsxs)(n.p,{children:["One important observation to note is when we combine selecting a subset of rows with sorting in descending order by price. The table is first sorted by price in descending order, but the virtual index ",(0,i.jsx)(n.code,{children:"i"})," remains as if the table were still in its original order. Then, the subset is drawn, starting at position ",(0,i.jsx)(n.code,{children:"s"})," and selecting ",(0,i.jsx)(n.code,{children:"n"})," rows, without affecting the virtual index."]}),"\n",(0,i.jsxs)(n.p,{children:["Attentive readers may have noticed that you can achieve the same result from the ",(0,i.jsx)(n.code,{children:"select [5] from trade"})," pattern by using the ",(0,i.jsx)(n.code,{children:"# take"})," operator like ",(0,i.jsx)(n.code,{children:"5#trade"}),". You might wonder why you should use the longer syntax when KDB/Q emphasizes brevity, and we've been advocating for concise code. This comes down to one of KDB/Q's core concepts: code is interpreted right to left. (You can read more about key KDB/Q concepts in my blog post ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/blog/The%20Magnificent%20Seven%20-%20Mastering%20KDB/Q%20Concepts%20for%20Data%20Excellence",children:"here"}),"). Since KDB/Q interprets code right to left, ",(0,i.jsx)(n.code,{children:"5#trade"})," first evaluates the entire ",(0,i.jsx)(n.code,{children:"trade"})," table before selecting the first 5 rows. In contrast, ",(0,i.jsx)(n.code,{children:"select [5] from trade"})," is optimized internally to directly take the first 5 rows without evaluating the entire table. This difference can significantly impact performance and memory usage, especially for large datasets. Therefore, it is recommended to use ",(0,i.jsx)(n.code,{children:"select [n] from table"})," in production code rather than ",(0,i.jsx)(n.code,{children:"5#table"})," for efficiency."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(5#trade)~select [5] from trade\n1b\n"})}),"\n",(0,i.jsx)(n.h4,{id:"nested-columns-handle-with-care",children:"Nested Columns: Handle with Care"}),"\n",(0,i.jsx)(n.p,{children:"The final behavior I'd like to explain is how to work with nested columns. A nested column is one where each cell essentially contains a list of lists. KDB/Q tables are very powerful, allowing you to store nearly anything within them\u2014but that's a topic for another time. For now, let's explore a table where two columns are nested, meaning they hold a list of lists. In our example, we're examining a quote table that contains the first three levels of an order book, with three bid and three ask prices for each symbol and row."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)show quote:([] sym:`AAPL`MSFT`FB`GOOG; bid:(130+3?1.0;50+3?1.0;300+3?1.0;200+3?1.0); ask:(131+3?1.0;51+3?1.0;301+3?1.0;201+3?1.0))\nsym  bid                        ask\n----------------------------------------------------------\nAAPL 130.5632 130.0602 130.7008 131.012  131.6942 131.1428\nMSFT 50.87678 50.76479 50.85959 51.50566 51.97591 51.00381\nFB   300.8109 300.4545 300.8047 301.0912 301.5939 301.3439\nGOOG 200.6956 200.8063 200.1153 201.2325 201.3502 201.1478\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, let\u2019s say we want to calculate the average bid and ask price for each symbol. A naive approach might be to simply apply the average ",(0,i.jsx)(n.code,{children:"avg"})," operator to the bid and ask columns. However, it's important to remember that each cell in these columns is a list, so we can't directly apply the operator to them. Instead, we need to use an iterator to handle each cell individually. Here's an example of how to do that:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Not using an iterator throws an error\nq)select sym,bid,ask,avgBid:avg bid,avgAsk:avg ask from quote\n'length\n  [0]  select sym,bid,ask,avgBid:avg bid,avgAsk:avg ask from quote\n       ^\nq)select sym,bid,ask, avgBid:avg each bid,avgAsk:avg each ask from quote\nsym  bid                        ask                        avgBid   avgAsk\n----------------------------------------------------------------------------\nAAPL 130.5632 130.0602 130.7008 131.012  131.6942 131.1428 130.4414 131.283\nMSFT 50.87678 50.76479 50.85959 51.50566 51.97591 51.00381 50.83372 51.49513\nFB   300.8109 300.4545 300.8047 301.0912 301.5939 301.3439 300.69   301.343\nGOOG 200.6956 200.8063 200.1153 201.2325 201.3502 201.1478 200.5391 201.2435\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at this in more detail. First, we start by examining the ",(0,i.jsx)(n.code,{children:"bid"})," column independently:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)quote`bid\n130.5632 130.0602 130.7008\n50.87678 50.76479 50.85959\n300.8109 300.4545 300.8047\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's go one step further, and use the ",(0,i.jsx)(n.code,{children:"0N!"})," operator to inspect the column in even greater detail:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)0N!quote`bid\n(130.5632 130.0602 130.7008;50.87678 50.76479 50.85959;300.8109 300.4545 300...\n130.5632 130.0602 130.7008\n50.87678 50.76479 50.85959\n300.8109 300.4545 300.8047\n200.6956 200.8063 200.1153\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As shown above, the ",(0,i.jsx)(n.code,{children:"bid"})," column is a nested list. Due to the ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/blog/The%20Magnificent%20Seven%20-%20Mastering%20KDB/Q%20Concepts%20for%20Data%20Excellence#kdbq-is-atomic",children:"atomic nature"})," of KDB/Q operators, the ",(0,i.jsx)(n.code,{children:"avg"})," operator will apply element-wise to each item within the lists, rather than to each sublist as a whole. Let\u2019s look at an example to demonstrate this behavior."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)avg 0N!(1 2 3;4 5 6;8 9 10)\n(1 2 3;4 5 6;8 9 10)\n4.333333 5.333333 6.333333\nq)(avg 1 4 8;avg 2 5 9;avg 3 6 10)\n4.333333 5.333333 6.333333\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In order to achieve the desired result, we have to leverage the behavior of the ",(0,i.jsx)(n.code,{children:"each"})," iterator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)avg each (1 2 3;4 5 6;8 9 10)\n2 5 9f\n"})}),"\n",(0,i.jsx)(n.p,{children:"Understanding this concept is essential, as nested columns are quite common, particularly when you start grouping tables. If you're unsure about any part of this explanation, I encourage you to review the section again and feel free to reach out to me directly for further clarification."}),"\n",(0,i.jsx)(n.h3,{id:"filtering-your-data-mastering-the-where-clause",children:"Filtering Your Data: Mastering the Where Clause"}),"\n",(0,i.jsxs)(n.p,{children:["When working with KDB/Q, you're typically handling large datasets, often containing millions or even billions of records. However, it\u2019s rare that you\u2019ll need to analyze an entire table. The ",(0,i.jsx)(n.code,{children:"where clause"})," enables you to filter your data into more manageable subsets. In this section, we'll explore the powerful functionality and behavior of the ",(0,i.jsx)(n.code,{children:"where clause"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's start with a simple example. Assume you would like to retrieve all the records for the stock Google from our ",(0,i.jsx)(n.code,{children:"trade"})," table. You can do this simply by using the below query:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where sym=`GOOG\nsym  price    quantity exchange\n-------------------------------\nGOOG 40.99561 745      LSE\nGOOG 71.48779 361      NYSE\nGOOG 5.752516 414      CBOE\nGOOG 23.10108 890      NASDAQ\n"})}),"\n",(0,i.jsx)(n.h4,{id:"multiple-where-clauses",children:"Multiple Where Clauses"}),"\n",(0,i.jsxs)(n.p,{children:["Obviously you're not limited to using just one ",(0,i.jsx)(n.code,{children:"where clause"})," in a Q-SQL query; you can include as many as needed, with each being an individual KDB/Q expression. Although KDB/Q code is generally evaluated from right to left (",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/blog/The%20Magnificent%20Seven%20-%20Mastering%20KDB/Q%20Concepts%20for%20Data%20Excellence#left-of-right-and-no-operator-precedence",children:"left-of-right"}),"), Q-SQL ",(0,i.jsx)(n.code,{children:"where clauses"})," are executed from the left most, to the right most. Each clause successively narrows down the data, passing the filtered subset to the next. This is one of the reasons Q-SQL queries are so efficient and powerful. Given this, it's often best to place the most restrictive ",(0,i.jsx)(n.code,{children:"where clause"})," first to optimize performance. Let\u2019s look at an example: Suppose we have an order table with data for eight different stocks, including the order price and whether it was a buy or sell. Our table contains 100 million records, and we want to filter for all the buy orders for Google."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Set n to 100 million\nq)n:100000000\n// Create the order table\nq)order:([] sym:n?`AAPL`GOOG`MSFT`FB`CSCO`C`GS`AMZN; price:n?100.0; side:n?`buy`sell)\nq)count order\n100000000\n// Estimate the size of the order table\nq)1e-6*-22!order\n1662.5\n"})}),"\n",(0,i.jsx)(n.p,{children:"First, we use a where clause to filter for all buy orders and then, subsequently we filter for all Google orders. Let's have a look at the performance of this query"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)\\ts select from order where side=`buy,sym=`GOOG\n377 1140851408\nq)1e-6*1140851408\n1140.851\n"})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, this takes just under 400 milliseconds to return and uses 1.14GB of memory."}),"\n",(0,i.jsx)(n.p,{children:"On the other hand, if we first filter for all Google orders and then apply a second filter for buy orders, the performance of our query improves by approximately 30% in terms of execution time while using four times less memory compared to the initial query."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)\\ts select from order where sym=`GOOG,side=`buy\n265 285213392\nq)1e-6*285213392\n285.2134\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The example above clearly demonstrates the importance of placing the most restrictive ",(0,i.jsx)(n.code,{children:"where clause"})," first, followed by progressively less restrictive ones. If you've worked with KDB/Q for a while, you've likely encountered a situation where either you or a less experienced user accidentally queried the Historical Database (HDB) without filtering by date first. This can lead to blocking the HDB and potentially crashing the process as it tries to load all the data into memory (unless certain safety flags are enabled, which is a topic for another post). Since the HDB typically holds years or even decades of market data, partitioned by date, failing to use a date filter first in your Q-SQL query will cause KDB/Q to attempt to load the entire dataset, overwhelming memory and crashing the KDB/Q process."]}),"\n",(0,i.jsxs)(n.h4,{id:"the-virtual-column-i-in-a-where-clause",children:["The virtual column ",(0,i.jsx)(n.code,{children:"i"})," in a ",(0,i.jsx)(n.code,{children:"where clause"})]}),"\n",(0,i.jsxs)(n.p,{children:["We've already seen how the virtual column ",(0,i.jsx)(n.code,{children:"i"})," can be used in your column selection, but there's even more you can do with it. You can also leverage it within your ",(0,i.jsx)(n.code,{children:"where clause"}),". A quick example will highlight this functionality."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where i=5\nsym  price   quantity exchange\n------------------------------\nAAPL 44.9731 177      NASDAQ\nq)select from trade where i within 3 9\nsym  price    quantity exchange\n-------------------------------\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nAAPL 19.46509 850      CBOE\nIBM  9.059026 241      NASDAQ\nq)select from trade where i in 5 6 7 1\nsym  price    quantity exchange\n-------------------------------\nGOOG 40.99561 745      LSE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\n"})}),"\n",(0,i.jsx)(n.h4,{id:"leveraging-the-flexibility-of-kdbq-writing-powerful-q-sql-queries",children:"Leveraging the Flexibility of KDB/Q: Writing Powerful Q-SQL Queries"}),"\n",(0,i.jsx)(n.p,{children:"I've mentioned it before, and I can't emphasize enough how powerful and flexible KDB/Q is for coding. You can accomplish a lot with minimal code in a highly elegant manner. This is especially clear when writing more complex Q-SQL queries. By leveraging the flexibility of KDB/Q, we can create concise yet effective code."}),"\n",(0,i.jsx)(n.p,{children:"Consider this scenario: Our trade table contains trade data for various stocks across multiple exchanges. One of your business users, a quant, is interested in trades for Google (GOOG), Apple (AAPL), and Microsoft (MSFT). Specifically, they want trades for Apple on the NASDAQ (National Association of Securities Dealers Automatic Quotation System), trades for Google on the NYSE (New York Stock Exchange), and trades for Microsoft on both the NASDAQ and CBOE (Chicago Board Options Exchange). The table below lists the various exchanges where these stocks are traded. How can we create a query to return the desired outcome?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select count i by sym,exchange from trade\nsym  exchange| x\n-------------| -\nAAPL CBOE    | 2\nAAPL LSE     | 1\nAAPL NASDAQ  | 2\nAAPL NYSE    | 1\nGOOG CBOE    | 1\nGOOG LSE     | 1\nGOOG NASDAQ  | 1\nGOOG NYSE    | 1\nIBM  CBOE    | 2\nIBM  LSE     | 2\nIBM  NASDAQ  | 1\nMSFT CBOE    | 2\nMSFT LSE     | 1\nMSFT NASDAQ  | 2\n"})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, the stocks we are focusing on are traded on multiple exchanges, some of which are not relevant to our needs. To start, let's filter the data to include only the stocks we're interested in."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where sym in `AAPL`GOOG`MSFT\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 78.33686 45       LSE      3525.159\nGOOG 40.99561 745      LSE      30541.73\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nAAPL 44.9731  177      NASDAQ   7960.239\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 19.46509 850      CBOE     16545.33\nAAPL 62.03014 296      LSE      18360.92\nAAPL 93.26316 216      NYSE     20144.84\nAAPL 27.47066 717      NASDAQ   19696.47\nGOOG 5.752516 414      CBOE     2381.541\nAAPL 25.60658 657      CBOE     16823.52\nGOOG 23.10108 890      NASDAQ   20559.96\nMSFT 10.24432 635      NASDAQ   6505.145\nMSFT 86.71096 108      CBOE     9364.784\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is a good start, but now we need to narrow it down to include only the exchanges that interest us. Let's give that a try."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where sym in `AAPL`GOOG`MSFT,exchange in `NASDAQ`CBOE`NYSE\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nAAPL 44.9731  177      NASDAQ   7960.239\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 19.46509 850      CBOE     16545.33\nAAPL 93.26316 216      NYSE     20144.84\nAAPL 27.47066 717      NASDAQ   19696.47\nGOOG 5.752516 414      CBOE     2381.541\nAAPL 25.60658 657      CBOE     16823.52\nGOOG 23.10108 890      NASDAQ   20559.96\nMSFT 10.24432 635      NASDAQ   6505.145\nMSFT 86.71096 108      CBOE     9364.784\n"})}),"\n",(0,i.jsx)(n.p,{children:"That's not quite what we want, is it? While we have all the trades for the stocks we're interested in, we're also seeing trades for Apple on the NYSE and CBOE, which we want to exclude. Perhaps rearranging the where clauses might help?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where exchange in `NASDAQ`CBOE`NYSE, sym in `AAPL`GOOG`MSFT\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nAAPL 44.9731  177      NASDAQ   7960.239\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 19.46509 850      CBOE     16545.33\nAAPL 93.26316 216      NYSE     20144.84\nAAPL 27.47066 717      NASDAQ   19696.47\nGOOG 5.752516 414      CBOE     2381.541\nAAPL 25.60658 657      CBOE     16823.52\nGOOG 23.10108 890      NASDAQ   20559.96\nMSFT 10.24432 635      NASDAQ   6505.145\nMSFT 86.71096 108      CBOE     9364.784\n"})}),"\n",(0,i.jsx)(n.p,{children:"No, that didn't work either. Alright, let's construct a query for each individual stock along with the exchanges we're interested in and then combine them."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(select from trade where sym=`AAPL, exchange=`NASDAQ),(select from trade where sym=`GOOG,exchange=`NYSE),select from trade where sym=`MSFT,exchange in `NASDAQ`CBOE\nsym  price    quantity exchange nominal\n----------------------------------------\nAAPL 44.9731  177      NASDAQ   7960.239\nAAPL 27.47066 717      NASDAQ   19696.47\nGOOG 71.48779 361      NYSE     25807.09\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nMSFT 10.24432 635      NASDAQ   6505.145\nMSFT 86.71096 108      CBOE     9364.784\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"In the code above, we've joined three tables into a single table. We'll discuss joins in much greater detail in a future post"})}),"\n",(0,i.jsx)(n.p,{children:"The code above gives us the desired result, showing all trades for Apple on the NASDAQ, all Google trades on the NYSE, and all Microsoft trades on both the NASDAQ and CBOE. However, this required quite a bit of typing. Surely, there must be a more concise way to achieve this. Let\u2019s take a moment to consider what we\u2019re actually interested in. The table below summarizes the stocks and exchanges we're focusing on."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)([] sym:`AAPL`GOOG`MSFT`MSFT;exchange:`NASDAQ`NYSE`NASDAQ`CBOE)\nsym  exchange\n-------------\nAAPL NASDAQ\nGOOG NYSE\nMSFT NASDAQ\nMSFT CBOE\n"})}),"\n",(0,i.jsx)(n.p,{children:"Wouldn't it be fantastic if we could utilize this information to filter our table? Well, KDB/Q always comes through! We can definitely achieve that! Let me demonstrate how."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where ([] sym;exchange) in ([] sym:`AAPL`GOOG`MSFT`MSFT;exchange:`NASDAQ`NYSE`NASDAQ`CBOE)\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nAAPL 44.9731  177      NASDAQ   7960.239\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 27.47066 717      NASDAQ   19696.47\nMSFT 10.24432 635      NASDAQ   6505.145\nMSFT 86.71096 108      CBOE     9364.784\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can probably already see that the result is exactly what we are looking for and matches the result of our previous query. However, the order of the table differs slightly from our previous result. So, let's sort both tables by the symbol and then compare the results to ensure they contain the same information."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(`sym xasc select from trade where ([] sym;exchange) in ([] sym:`AAPL`GOOG`MSFT`MSFT;exchange:`NASDAQ`NYSE`NASDAQ`CBOE))~(`sym xasc select from trade where sym=`AAPL, exchange=`NASDAQ),(select from trade where sym=`GOOG,exchange=`NYSE),select from trade where sym=`MSFT,exchange in `NASDAQ`CBOE\n1b\n"})}),"\n",(0,i.jsx)(n.p,{children:"Et voila! There we have it! We've confirmed that the results match perfectly, and we've now learned how to write terse yet powerful queries."}),"\n",(0,i.jsx)(n.h4,{id:"demystifying-the-magic-of-where-clauses",children:"Demystifying the Magic of Where Clauses"}),"\n",(0,i.jsxs)(n.p,{children:["We\u2019ve explored some basic where clause expressions and gained a solid understanding of how to use them. Now, let\u2019s dive deeper into what actually happens under the hood when you apply a where clause in your Q-SQL query. Each where clause in your Q-SQL expression is evaluated to produce a boolean vector (or boolean-equivalent types, like an integer 0 representing false) that matches the row count of the table. From a intuitive perspective you would expect that each boolean vector from the where clauses is combined using an ",(0,i.jsx)(n.strong,{children:"AND"})," operation, and the final vector is applied to filter your data. However, as we learned in the previous section on multiple where clauses, only the records passing the current where clause are tested in the next subphrase. The result is a progressively narrower subset of rows for each subsequent clause."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at this behaviour in action using our ",(0,i.jsx)(n.code,{children:"trade"})," table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// For reference\nq)trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nAAPL 19.46509 850      CBOE\nIBM  9.059026 241      NASDAQ\nAAPL 62.03014 296      LSE\nAAPL 93.26316 216      NYSE\nAAPL 27.47066 717      NASDAQ\nGOOG 5.752516 414      CBOE\nAAPL 25.60658 657      CBOE\nGOOG 23.10108 890      NASDAQ\nIBM  8.724017 407      LSE\nMSFT 10.24432 635      NASDAQ\nMSFT 86.71096 108      CBOE\nIBM  72.78528 652      LSE\n// Create count[trade] random boolean values --\x3e 20\nq)show ind:count[trade]?01b\n01000111010011011101b\n// Use our boolean vector to filter the trade table. Returning all rows where the boolean vector is 1b true\nq)select from trade where ind\nsym  price    quantity exchange\n-------------------------------\nGOOG 40.99561 745      LSE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nIBM  9.059026 241      NASDAQ\nAAPL 27.47066 717      NASDAQ\nGOOG 5.752516 414      CBOE\nGOOG 23.10108 890      NASDAQ\nIBM  8.724017 407      LSE\nMSFT 10.24432 635      NASDAQ\nIBM  72.78528 652      LSE\n// You can also select the whole table using 1b. This works because KDB/Q applies atomic extension\nq)select from trade where 1b\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nAAPL 19.46509 850      CBOE\nIBM  9.059026 241      NASDAQ\nAAPL 62.03014 296      LSE\nAAPL 93.26316 216      NYSE\nAAPL 27.47066 717      NASDAQ\nGOOG 5.752516 414      CBOE\nAAPL 25.60658 657      CBOE\nGOOG 23.10108 890      NASDAQ\nIBM  8.724017 407      LSE\nMSFT 10.24432 635      NASDAQ\nMSFT 86.71096 108      CBOE\nIBM  72.78528 652      LSE\n// Or select an empty table using 0b\nq)select from trade where 0b\nsym price quantity exchange\n---------------------------\n"})}),"\n",(0,i.jsxs)(n.p,{children:["That was fun, right? As you've seen, we can use a boolean vector to filter our data effectively. Thanks to the atomic nature of KDB/Q operators and atomic expansion, you can even pass a single ",(0,i.jsx)(n.code,{children:"true"})," value (",(0,i.jsx)(n.code,{children:"1b"}),") to return the entire table or a ",(0,i.jsx)(n.code,{children:"false"})," value (",(0,i.jsx)(n.code,{children:"0b"}),") to get an empty table. But let's take it up a notch and dive deeper into how the ",(0,i.jsx)(n.code,{children:"where clause"})," really works."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)ind\n01000111010011011101b\nq)where ind\n1 5 6 7 9 12 13 15 16 17 19\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, the ",(0,i.jsx)(n.code,{children:"where"})," operator returns the index of all ",(0,i.jsx)(n.code,{children:"true (1b)"})," values."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["There's actually more to this, but that, my friends, is a topic for another post. You can subscribe to my newsletter ",(0,i.jsx)(n.a,{href:"https://defconq.substack.com",children:"here"})," to stay updated and receive my blog posts directly in your inbox."]})}),"\n",(0,i.jsxs)(n.p,{children:["Now, back to the ",(0,i.jsx)(n.code,{children:"where"})," operator. Let's try using the indexes it returns to index into our ",(0,i.jsx)(n.code,{children:"trade"})," table\u2014it works like a charm."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)trade where ind\nsym  price    quantity exchange\n-------------------------------\nGOOG 40.99561 745      LSE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nIBM  9.059026 241      NASDAQ\nAAPL 27.47066 717      NASDAQ\nGOOG 5.752516 414      CBOE\nGOOG 23.10108 890      NASDAQ\nIBM  8.724017 407      LSE\nMSFT 10.24432 635      NASDAQ\nIBM  72.78528 652      LSE\n"})}),"\n",(0,i.jsx)(n.p,{children:"But what if we use numerical indexes directly in our Q-SQL statement? That should work, right? Given the left-to-right nature of KDB/Q, the indexing into the table should filter the data, and then we can select from it. Let\u2019s try it..."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade 1 5 6 7 9 12 13 15 16 17 19\nsym  price    quantity exchange\n-------------------------------\nGOOG 40.99561 745      LSE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nIBM  9.059026 241      NASDAQ\nAAPL 27.47066 717      NASDAQ\nGOOG 5.752516 414      CBOE\nGOOG 23.10108 890      NASDAQ\nIBM  8.724017 407      LSE\nMSFT 10.24432 635      NASDAQ\nIBM  72.78528 652      LSE\nq)(trade where ind)~select from trade 1 5 6 7 9 12 13 15 16 17 19\n1b\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It worked\u2014awesome! However, there\u2019s one caveat when using this behavior in a Q-SQL ",(0,i.jsx)(n.code,{children:"where"})," clause. The boolean vector must be the same length as the table's row count, otherwise, you\u2019ll encounter a length error. Take a look at the example below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where 010b\n'length\n  [0]  select from trade where 010b\n       ^\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"grouping-data-the-by-clause",children:["Grouping Data: The ",(0,i.jsx)(n.code,{children:"by"})," clause"]}),"\n",(0,i.jsxs)(n.p,{children:["When dealing with large tables, it's common to store data for multiple instruments or IDs; I have never encountered a table containing data for just one specific identifier. Therefore, it's usually impractical to run aggregation functions like minimum ",(0,i.jsx)(n.code,{children:"min"}),", maximum ",(0,i.jsx)(n.code,{children:"max"}),", or average ",(0,i.jsx)(n.code,{children:"avg"})," on the entire table (unless, of course, you're calculating something like the average height of a population, but let's set that aside for now). For example, calculating the minimum, maximum, and average trade price for the entire ",(0,i.jsx)(n.code,{children:"trade"})," table wouldn't make much sense, would it?"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select minimum:min price,maximum: max price,average: avg price from trade\nminimum  maximum  average\n--------------------------\n1.392076 93.26316 41.65634\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The query above is quite pointless if we're interested in individual stocks. It makes far more sense to calculate the minimum, maximum, and average trade price for each specific stock. This is where the ",(0,i.jsx)(n.code,{children:"by"})," clause comes in handy. By specifying the column we want to group by, we can calculate these metrics for each stock accordingly."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select minimum:min price,maximum: max price,average: avg price by sym from trade\nsym | minimum  maximum  average\n----| --------------------------\nAAPL| 19.46509 93.26316 45.46812\nGOOG| 5.752516 71.48779 35.33425\nIBM | 1.392076 72.78528 26.56717\nMSFT| 10.24432 86.71096 57.22905\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now this is much more meaningful. Of course, you can include multiple columns in the ",(0,i.jsx)(n.code,{children:"by"})," clause for more detailed grouping."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select minimum:min price,maximum: max price,average: avg price by sym,exchange from trade\nsym  exchange| minimum  maximum  average\n-------------| --------------------------\nAAPL CBOE    | 19.46509 25.60658 22.53583\nAAPL LSE     | 62.03014 62.03014 62.03014\nAAPL NASDAQ  | 27.47066 44.9731  36.22188\nAAPL NYSE    | 93.26316 93.26316 93.26316\nGOOG CBOE    | 5.752516 5.752516 5.752516\nGOOG LSE     | 40.99561 40.99561 40.99561\nGOOG NASDAQ  | 23.10108 23.10108 23.10108\nGOOG NYSE    | 71.48779 71.48779 71.48779\nIBM  CBOE    | 1.392076 40.87545 21.13376\nIBM  LSE     | 8.724017 72.78528 40.75465\nIBM  NASDAQ  | 9.059026 9.059026 9.059026\nMSFT CBOE    | 61.08817 86.71096 73.89957\nMSFT LSE     | 78.33686 78.33686 78.33686\nMSFT NASDAQ  | 10.24432 49.76492 30.00462\n"})}),"\n",(0,i.jsx)(n.h4,{id:"by-clause-demystified",children:"By clause demystified"}),"\n",(0,i.jsxs)(n.p,{children:["But how does the ",(0,i.jsx)(n.code,{children:"by"})," clause actually work? Let\u2019s break it down. When you use the ",(0,i.jsx)(n.code,{children:"by"})," clause, KDB/Q groups the underlying data based on the specified column, creating a keyed table (if you're unfamiliar with keyed tables, you can learn more about them ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/dictionariesTables#keyed-tables-vs-tables",children:"here"}),"). The column you specified in the ",(0,i.jsx)(n.code,{children:"by"})," clause becomes the key, and all the values for the other columns are stored as nested columns. To illustrate this, we can use the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/xgroup/",children:(0,i.jsx)(n.code,{children:"xgroup"})})," operator: given a table ",(0,i.jsx)(n.code,{children:"trade"}),", the ",(0,i.jsx)(n.code,{children:"xgroup"})," operator will group the data by the designated column."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)`sym xgroup trade\nsym | price                                                quantity                exchange\n----| --------------------------------------------------------------------------------------------------------------\nMSFT| 78.33686 61.08817 49.76492 10.24432 86.71096         45 898 935 635 108      `LSE`CBOE`NASDAQ`NASDAQ`CBOE\nGOOG| 40.99561 71.48779 5.752516 23.10108                  745 361 414 890         `LSE`NYSE`CBOE`NASDAQ\nIBM | 40.87545 1.392076 9.059026 8.724017 72.78528         64 238 241 407 652      `CBOE`CBOE`NASDAQ`LSE`LSE\nAAPL| 44.9731 19.46509 62.03014 93.26316 27.47066 25.60658 177 850 296 216 717 657 `NASDAQ`CBOE`LSE`NYSE`NASDAQ`CBOE\n"})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, each column is now a nested column. To perform meaningful analysis, we can apply an aggregation operator."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select minimum:min price,maximum: max price,average: avg price by sym from trade\nsym | minimum  maximum  average\n----| --------------------------\nAAPL| 19.46509 93.26316 45.46812\nGOOG| 5.752516 71.48779 35.33425\nIBM | 1.392076 72.78528 26.56717\nMSFT| 10.24432 86.71096 57.22905\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As previously mentioned, there's nothing preventing you from using multiple columns to group your data. Additionally, you can use any KDB/Q expression in the ",(0,i.jsx)(n.code,{children:"by"})," clause. For example, if you're interested in how many records there are for Apple stock, an intuitive approach would be to filter all records where the ",(0,i.jsx)(n.code,{children:"sym"})," column matches the Apple ticker and then count the results, like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select count i by sym from trade where sym=`AAPL\nsym | x\n----| -\nAAPL| 6\n"})}),"\n",(0,i.jsxs)(n.p,{children:["However, this method only provides the count for Apple stock. If you want to know the count for all other stocks as well, you would need to run an additional, separate query. Using the ",(0,i.jsx)(n.code,{children:"by"})," clause, though, you can achieve everything in one step."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select n:count i by isAAPL:sym=`AAPL from trade\nisAAPL| n\n------| --\n0     | 14\n1     | 6\n"})}),"\n",(0,i.jsx)(n.h4,{id:"how-to-retrieve-the-last-element-for-a-specific-identifier",children:"How to Retrieve the Last Element for a Specific Identifier"}),"\n",(0,i.jsxs)(n.p,{children:["Another highly useful feature of the ",(0,i.jsx)(n.code,{children:"by"})," clause is the ability to retrieve the last record for a specific identifier. For example, if you're looking to obtain the most recent record for a particular stock, a more verbose method might look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select last price,last quantity,last exchange by sym from trade\nsym | price    quantity exchange\n----| --------------------------\nAAPL| 25.60658 657      CBOE\nGOOG| 23.10108 890      NASDAQ\nIBM | 72.78528 652      LSE\nMSFT| 86.71096 108      CBOE\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This approach works well if you're dealing with a small table containing just a few columns. But what if you have dozens or even hundreds of columns, as is often the case? Typing out each column manually would be inefficient. Instead, you can leverage the ",(0,i.jsx)(n.code,{children:"by"})," clause without specifying any columns. By leaving the column selection blank and using the ",(0,i.jsx)(n.code,{children:"by"})," clause, KDB/Q will automatically return the last record for each identifier specified in the ",(0,i.jsx)(n.code,{children:"by"})," clause."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select by sym from trade\nsym | price    quantity exchange\n----| --------------------------\nAAPL| 25.60658 657      CBOE\nGOOG| 23.10108 890      NASDAQ\nIBM | 72.78528 652      LSE\nMSFT| 86.71096 108      CBOE\nq)(select last price,last quantity,last exchange by sym from trade)~select by sym from trade\n1b\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"the-update-statement",children:["The ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#95-the-update-template",children:(0,i.jsx)(n.code,{children:"update"})})," statement"]}),"\n",(0,i.jsx)(n.h3,{id:"syntax-1",children:"Syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Now that we understand how to select and filter our data, let\u2019s explore how to update it. You can modify your data using the ",(0,i.jsx)(n.code,{children:"update"})," template. The ",(0,i.jsx)(n.code,{children:"update"})," template follows the same syntax as the ",(0,i.jsx)(n.code,{children:"select"})," template, except that you use the ",(0,i.jsx)(n.code,{children:"update"})," keyword in place of the ",(0,i.jsx)(n.code,{children:"select"})," keyword."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Q-SQL Update Statement Syntax",src:t(1482).A+"",width:"1210",height:"480"})}),"\n",(0,i.jsxs)(n.p,{children:["The key difference between a ",(0,i.jsx)(n.code,{children:"select"})," statement and an ",(0,i.jsx)(n.code,{children:"update"})," statement is that the columns specified in the update are modified rather than just selected. If you update an existing column, the table returned will reflect the changes in that column. If you update a column that doesn't yet exist, a new column will be added to the end of the column list. ",(0,i.jsx)(n.strong,{children:"One important note"}),": the original table remains unchanged when using the ",(0,i.jsx)(n.code,{children:"update"})," statement\u2014what you get is a copy with the modifications. To apply changes directly to the original table, you need to reference the table by name. Let\u2019s look at some examples."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// For reference\nq)trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\n...\n// Updating the price to price times 2\nq)update price*2 from trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 156.6737 45       LSE\nGOOG 81.99122 745      LSE\nMSFT 122.1763 898      CBOE\nMSFT 99.52983 935      NASDAQ\nIBM  81.75089 64       CBOE\nAAPL 89.94621 177      NASDAQ\nIBM  2.784152 238      CBOE\nGOOG 142.9756 361      NYSE\n...\n// Update the price to price+10 for all Apple stocks\nq)update price+10 from trade where sym=`AAPL\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 54.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nAAPL 29.46509 850      CBOE\nIBM  9.059026 241      NASDAQ\nAAPL 72.03014 296      LSE\nAAPL 103.2632 216      NYSE\nAAPL 37.47066 717      NASDAQ\n...\n// Adding a new column nominal:price*quantity\nq)update nominal:price*quantity from trade\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 78.33686 45       LSE      3525.159\nGOOG 40.99561 745      LSE      30541.73\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nIBM  40.87545 64       CBOE     2616.029\nAAPL 44.9731  177      NASDAQ   7960.239\nIBM  1.392076 238      CBOE     331.3141\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 19.46509 850      CBOE     16545.33\n...\n// Inspecting the trade table --\x3e Updates haven't been persisted\nq)trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\n...\n// Updating the trade table in place --\x3e Using update by name\nq)update nominal:price*quantity from `trade\n`trade\nq)trade\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 78.33686 45       LSE      3525.159\nGOOG 40.99561 745      LSE      30541.73\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nIBM  40.87545 64       CBOE     2616.029\nAAPL 44.9731  177      NASDAQ   7960.239\nIBM  1.392076 238      CBOE     331.3141\nGOOG 71.48779 361      NYSE     25807.09\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As shown in the examples above, when we update the ",(0,i.jsx)(n.code,{children:"trade"})," table, we receive a modified copy of the original table, but the changes are not persisted. This is because the table is updated by value, not by name. To ensure the changes are saved, we need to update the table by name, as demonstrated in the final example."]}),"\n",(0,i.jsx)(n.h4,{id:"conformability-matters-update-modifications-are-vector-operations",children:"Conformability Matters: Update Modifications Are Vector Operations"}),"\n",(0,i.jsxs)(n.p,{children:["There is one final point we have to cover about the ",(0,i.jsx)(n.code,{children:"update"})," statement before moving on to the next topic. Actions in the ",(0,i.jsx)(n.code,{children:"update"})," statement are vector operations applied to the entire column. This means the ",(0,i.jsx)(n.strong,{children:"length and type"})," of the values you are updating matters."]}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s dive into this in more detail. Suppose we want to add a ",(0,i.jsx)(n.code,{children:"name"})," column to our trade table that contains the company names. For now, let\u2019s assume we only know the name of the stock with the ticker ",(0,i.jsx)(n.code,{children:"MSFT"})," and want to update just those records."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)update name:"Microsoft" from trade where sym=`MSFT\n\'length\n  [0]  update name:"Microsoft" from trade where sym=`MSFT\n                                                    ^\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Surprisingly, this doesn\u2019t work. But should it really be a surprise after learning that ",(0,i.jsx)(n.code,{children:"update"}),' operations are vector-based? Remember, "Microsoft" is a character vector, and its length doesn\u2019t match the length of our ',(0,i.jsx)(n.code,{children:"trade"})," table."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)count "Microsoft"\n9\nq)count trade\n20\n'})}),"\n",(0,i.jsx)(n.p,{children:'Alright, let\u2019s adjust our code to ensure we have the same number of "Microsoft" entries as the number of rows we intend to update.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)update name:count[i]#"Microsoft" from trade where sym=`MSFT\nsym  price    quantity exchange nominal  name\n---------------------------------------------\nMSFT 78.33686 45       LSE      3525.159 M\nGOOG 40.99561 745      LSE      30541.73\nMSFT 61.08817 898      CBOE     54857.18 i\nMSFT 49.76492 935      NASDAQ   46530.2  c\nIBM  40.87545 64       CBOE     2616.029\nAAPL 44.9731  177      NASDAQ   7960.239\nIBM  1.392076 238      CBOE     331.3141\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 19.46509 850      CBOE     16545.33\nIBM  9.059026 241      NASDAQ   2183.225\nAAPL 62.03014 296      LSE      18360.92\nAAPL 93.26316 216      NYSE     20144.84\nAAPL 27.47066 717      NASDAQ   19696.47\nGOOG 5.752516 414      CBOE     2381.541\nAAPL 25.60658 657      CBOE     16823.52\n..\n'})}),"\n",(0,i.jsxs)(n.p,{children:['Wait a minute, what\u2019s going on? Remember that "Microsoft" is a string, which is technically a character-vector. So, when we use the ',(0,i.jsx)(n.code,{children:"take"}),' operator, it treats the string "Microsoft" as a vector, no surprise here..']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// Additional illustration of how strings work\nq)update name:count[trade]#"Microsoft" from trade\nsym  price    quantity exchange nominal  name\n---------------------------------------------\nMSFT 78.33686 45       LSE      3525.159 M\nGOOG 40.99561 745      LSE      30541.73 i\nMSFT 61.08817 898      CBOE     54857.18 c\nMSFT 49.76492 935      NASDAQ   46530.2  r\nIBM  40.87545 64       CBOE     2616.029 o\nAAPL 44.9731  177      NASDAQ   7960.239 s\nIBM  1.392076 238      CBOE     331.3141 o\nGOOG 71.48779 361      NYSE     25807.09 f\nAAPL 19.46509 850      CBOE     16545.33 t\nIBM  9.059026 241      NASDAQ   2183.225 M\nAAPL 62.03014 296      LSE      18360.92 i\nAAPL 93.26316 216      NYSE     20144.84 c\nAAPL 27.47066 717      NASDAQ   19696.47 r\nGOOG 5.752516 414      CBOE     2381.541 o\nAAPL 25.60658 657      CBOE     16823.52 s\n..\nq)count[trade]#"Microsoft"\n"MicrosoftMicrosoftMi"\n'})}),"\n",(0,i.jsx)(n.p,{children:'Ok, so what\u2019s the solution? Let\u2019s create a singleton list containing the character vector "Microsoft" and allow KDB/Q\u2019s atomic extension to work its magic.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)update name:enlist "Microsoft" from trade where sym=`MSFT\n\'length\n  [0]  update name:enlist "Microsoft" from trade where sym=`MSFT\n                                                           ^\n'})}),"\n",(0,i.jsxs)(n.p,{children:['This still doesn\u2019t work. It seems atomic extension doesn\u2019t apply to lists, which isn\u2019t surprising\u2014after all, it\u2019s called "atomic" extension for a reason. So let\u2019s try one more approach: we\u2019ll create a list of lists, where we repeat the ',(0,i.jsx)(n.code,{children:'enlist "microsoft"'})," as many times as needed for all our ",(0,i.jsx)(n.code,{children:"MSFT"})," symbols."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)update name:sum[trade[`sym]=`MSFT]#enlist "Microsoft" from trade where sym=`MSFT\nsym  price    quantity exchange nominal  name\n----------------------------------------------------\nMSFT 78.33686 45       LSE      3525.159 "Microsoft"\nGOOG 40.99561 745      LSE      30541.73 ()\nMSFT 61.08817 898      CBOE     54857.18 "Microsoft"\nMSFT 49.76492 935      NASDAQ   46530.2  "Microsoft"\nIBM  40.87545 64       CBOE     2616.029 ()\nAAPL 44.9731  177      NASDAQ   7960.239 ()\nIBM  1.392076 238      CBOE     331.3141 ()\nGOOG 71.48779 361      NYSE     25807.09 ()\nAAPL 19.46509 850      CBOE     16545.33 ()\nIBM  9.059026 241      NASDAQ   2183.225 ()\nAAPL 62.03014 296      LSE      18360.92 ()\nAAPL 93.26316 216      NYSE     20144.84 ()\nAAPL 27.47066 717      NASDAQ   19696.47 ()\nGOOG 5.752516 414      CBOE     2381.541 ()\nAAPL 25.60658 657      CBOE     16823.52 ()\n..\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Finally, this worked! However, the query isn't particularly clean, concise, or as terse as we would like in KDB/Q. So, let's rewrite it in a more efficient and elegant way. Given what we know about the execution order of Q-SQL queries, we know that after the table expression ",(0,i.jsx)(n.code,{children:"T<exp>"})," is evaluated, the ",(0,i.jsx)(n.code,{children:"where clause"})," is processed, filtering the data so that only a subset is used in further operations. We can leverage this by simply using ",(0,i.jsx)(n.code,{children:"count[i]"})," to determine how many times we need to take ",(0,i.jsx)(n.code,{children:'enlist "Microsoft"'}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)update name:count[i]#enlist "Microsoft" from trade where sym=`MSFT\nsym  price    quantity exchange nominal  name\n----------------------------------------------------\nMSFT 78.33686 45       LSE      3525.159 "Microsoft"\nGOOG 40.99561 745      LSE      30541.73 ()\nMSFT 61.08817 898      CBOE     54857.18 "Microsoft"\nMSFT 49.76492 935      NASDAQ   46530.2  "Microsoft"\nIBM  40.87545 64       CBOE     2616.029 ()\nAAPL 44.9731  177      NASDAQ   7960.239 ()\nIBM  1.392076 238      CBOE     331.3141 ()\nGOOG 71.48779 361      NYSE     25807.09 ()\nAAPL 19.46509 850      CBOE     16545.33 ()\nIBM  9.059026 241      NASDAQ   2183.225 ()\nAAPL 62.03014 296      LSE      18360.92 ()\nAAPL 93.26316 216      NYSE     20144.84 ()\nAAPL 27.47066 717      NASDAQ   19696.47 ()\nGOOG 5.752516 414      CBOE     2381.541 ()\nAAPL 25.60658 657      CBOE     16823.52 ()\n..\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Bonus tip"}),": When working with small tables, using ",(0,i.jsx)(n.code,{children:"count[i]"})," is perfectly fine. However, for large tables, it's more efficient to use an already existing column to get the record count. Why? The virtual column ",(0,i.jsx)(n.code,{children:"i"})," is created each time it's referenced, which can decrease query performance. So, when dealing with large datasets, particularly in the Historical Database (HDB), always opt for an existing column."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Extra bonus tip"}),": Using ",(0,i.jsx)(n.code,{children:"count"})," on an existing column in the HDB is especially fast because the column file headers store the length of each column, speeding up the process."]})]}),"\n",(0,i.jsx)(n.p,{children:"One final note: Besides ensuring length conformability, the data type of the updated records (when the column already exists) must match the type of the existing column. This may seem obvious, but it's important to emphasize"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)update price:`error from trade where sym=`MSFT\n'type\n  [0]  update price:`error from trade where sym=`MSFT\n                                                ^\nq)update price:`error from trade\nsym  price quantity exchange nominal\n-------------------------------------\nMSFT error 45       LSE      3525.159\nGOOG error 745      LSE      30541.73\nMSFT error 898      CBOE     54857.18\nMSFT error 935      NASDAQ   46530.2\nIBM  error 64       CBOE     2616.029\nAAPL error 177      NASDAQ   7960.239\nIBM  error 238      CBOE     331.3141\nGOOG error 361      NYSE     25807.09\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you attempt to partially update a column with data that doesn't match the column's existing data type, you'll encounter a ",(0,i.jsx)(n.code,{children:"type"})," error. However, updating the entire column with a new data type will work without issue."]}),"\n",(0,i.jsxs)(n.h2,{id:"the-delete-statement",children:["The ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#96-the-delete-template",children:(0,i.jsx)(n.code,{children:"delete"})})," Statement"]}),"\n",(0,i.jsx)(n.h3,{id:"syntax-2",children:"Syntax"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Q-SQL Delete Statement Syntax",src:t(2356).A+"",width:"1210",height:"460"})}),"\n",(0,i.jsx)(n.p,{children:"Deleting from a table is quite simple\u2014you can either delete entire columns or entire rows, but not individual cells. The reason for this becomes clear when you think about it. If you were to delete a specific cell, the table structure would be compromised. Should the result be a list of non-conforming dictionaries? Or should the empty cells be filled with null values? Since there's no clear answer, deleting individual cells isn't allowed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// For reference \nq)trade\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 78.33686 45       LSE      3525.159\nGOOG 40.99561 745      LSE      30541.73\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nIBM  40.87545 64       CBOE     2616.029\nAAPL 44.9731  177      NASDAQ   7960.239\nIBM  1.392076 238      CBOE     331.3141\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 19.46509 850      CBOE     16545.33\nIBM  9.059026 241      NASDAQ   2183.225\nAAPL 62.03014 296      LSE      18360.92\nAAPL 93.26316 216      NYSE     20144.84\nAAPL 27.47066 717      NASDAQ   19696.47\nGOOG 5.752516 414      CBOE     2381.541\nAAPL 25.60658 657      CBOE     16823.52\n..\n// We can delete a column\nq)delete nominal from trade\nsym  price    quantity exchange\n-------------------------------\nMSFT 78.33686 45       LSE\nGOOG 40.99561 745      LSE\nMSFT 61.08817 898      CBOE\nMSFT 49.76492 935      NASDAQ\nIBM  40.87545 64       CBOE\nAAPL 44.9731  177      NASDAQ\nIBM  1.392076 238      CBOE\nGOOG 71.48779 361      NYSE\nAAPL 19.46509 850      CBOE\nIBM  9.059026 241      NASDAQ\nAAPL 62.03014 296      LSE\nAAPL 93.26316 216      NYSE\nAAPL 27.47066 717      NASDAQ\nGOOG 5.752516 414      CBOE\nAAPL 25.60658 657      CBOE\n..\n// We can delete rows\nq)delete from trade where sym=`GOOG\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 78.33686 45       LSE      3525.159\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nIBM  40.87545 64       CBOE     2616.029\nAAPL 44.9731  177      NASDAQ   7960.239\nIBM  1.392076 238      CBOE     331.3141\nAAPL 19.46509 850      CBOE     16545.33\nIBM  9.059026 241      NASDAQ   2183.225\nAAPL 62.03014 296      LSE      18360.92\nAAPL 93.26316 216      NYSE     20144.84\nAAPL 27.47066 717      NASDAQ   19696.47\nAAPL 25.60658 657      CBOE     16823.52\nIBM  8.724017 407      LSE      3550.675\nMSFT 10.24432 635      NASDAQ   6505.145\nMSFT 86.71096 108      CBOE     9364.784\nIBM  72.78528 652      LSE      47456\n// But we can't delete individual cells\nq)delete nominal from trade where sym=`GOOG\n'nyi\n  [0]  delete nominal from trade where sym=`GOOG\n                                           ^\n"})}),"\n",(0,i.jsx)(n.p,{children:"The image below should illustrate why it's not possible to delete an individual cell."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Q-SQL Delete Cells Statement Syntax",src:t(7476).A+"",width:"211",height:"151"})}),"\n",(0,i.jsxs)(n.h2,{id:"the-exec-statement",children:["The ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#94-the-exec-template",children:(0,i.jsx)(n.code,{children:"exec"})})," Statement"]}),"\n",(0,i.jsx)(n.h3,{id:"syntax-3",children:"Syntax"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Q-SQL Exec Statement Syntax",src:t(1198).A+"",width:"1210",height:"480"})}),"\n",(0,i.jsxs)(n.p,{children:["When I first started learning Q-SQL and querying data, I primarily used the ",(0,i.jsx)(n.code,{children:"exec"})," statement to extract a single column as a list from a table. Over time, I realized how powerful the ",(0,i.jsx)(n.code,{children:"exec"})," statement truly is. After reading ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/in/nickpsaris/",children:"Nick Psaris'"})," ",(0,i.jsx)(n.a,{href:"https://www.amazon.co.uk/Tips-Fast-Scalable-Maintainable-Kdb/dp/9881389909/ref=sr_1_1?crid=11GT2ZOQMHXVY&dib=eyJ2IjoiMSJ9.Y6P9bHDEKP-atK4ImvugPeFdDmX11RAYdkw4oEoR2Z9nfZKYwMxDvsijpTjDjs2sliBRstAkHtsOk96iXfG6gGHrER8nUi-3MO8RoBp9XQ-8yXIuf2fwiA1T7sOPzIhwnwjCbJ2cvMyXi7CM569o630TVyjKmCHznRvcBFX5VZaZhNTiKMIgQiydla8vBxxP.UuFJQs4F3ZwgrkdzGgJO5bE8ZsAad38t5SSibg92zGE&dib_tag=se&keywords=nick+psaris+Q+tips&qid=1727970339&sprefix=nick+psaris+q+tips%2Caps%2C68&sr=8-1",children:"Q Tips"})," I discovered that ",(0,i.jsx)(n.code,{children:"exec"})," is actually the general form of selecting data, while ",(0,i.jsx)(n.code,{children:"select"})," is just a special form of ",(0,i.jsx)(n.code,{children:"exec"})," that always returns a table. In contrast, ",(0,i.jsx)(n.code,{children:"exec"})," can return a wide range of outputs: an atom, a list, a dictionary, or even a table."]}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s begin with a few simple examples to understand the full potential of the ",(0,i.jsx)(n.code,{children:"exec"})," statement, and then progressively work our way towards more advanced use cases."]}),"\n",(0,i.jsx)(n.p,{children:"We can retrieve a single atom from a table"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec min price from trade\n1.392076\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or we can retrieve a list"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec sym from trade\n`MSFT`GOOG`MSFT`MSFT`IBM`AAPL`IBM`GOOG`AAPL`IBM`AAPL`AAPL`AAPL`GOOG`AAPL`GOOG`IBM`MSFT`MSFT`IBM\nq)exec distinct sym from trade\n`MSFT`GOOG`IBM`AAPL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using the ",(0,i.jsx)(n.code,{children:"exec"})," statement to select multiple columns from a table, the result is returned as a dictionary."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec sym,price from trade\nsym  | MSFT     GOOG     MSFT     MSFT     IBM      AAPL    IBM      GOOG     AAPL     IBM      AAPL     AAPL     AAPL     GOOG     AAPL     GOOG     IBM      MSFT     MSFT     IBM\nprice| 78.33686 40.99561 61.08817 49.76492 40.87545 44.9731 1.392076 71.48779 19.46509 9.059026 62.03014 93.26316 27.47066 5.752516 25.60658 23.10108 8.724017 10.24432 86.71096 72.78528\n"})}),"\n",(0,i.jsx)(n.p,{children:"This feature also works for a single column when combined with an assignment."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec price:price from trade\nprice| 78.33686 40.99561 61.08817 49.76492 40.87545 44.9731 1.392076 71.48779 19.46509 9.059026 62.03014 93.26316 27.47066 5.752516 25.60658 23.10108 8.724017 10.24432 86.71096 72.78528\nq)exec px:price from trade\npx| 78.33686 40.99561 61.08817 49.76492 40.87545 44.9731 1.392076 71.48779 19.46509 9.059026 62.03014 93.26316 27.47066 5.752516 25.60658 23.10108 8.724017 10.24432 86.71096 72.78528\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"the-magic-of-exec",children:["The Magic of ",(0,i.jsx)(n.code,{children:"exec"})]}),"\n",(0,i.jsxs)(n.p,{children:["By now, you might have started to understand how the ",(0,i.jsx)(n.code,{children:"select"})," statement is simply a specialized form of the more general ",(0,i.jsx)(n.code,{children:"exec"})," statement. If not, here's a quick reminder: a table is essentially a flipped column dictionary. If you haven't internalized this concept yet, write it down on a post-it and stick it everywhere you can until it becomes second nature. You can also revisit my blog post for a refresher ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/dictionariesTables#tables",children:"here"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Selecting multiple columns from trade\nq)exec sym,price,quantity,exchange,nominal from trade\nsym     | MSFT     GOOG     MSFT     MSFT     IBM      AAPL     IBM      GOOG     AAPL     IBM      AAPL     AAPL     AAPL     GOOG     AAPL     GOOG     IBM      MSFT     MSFT     IBM\nprice   | 78.33686 40.99561 61.08817 49.76492 40.87545 44.9731  1.392076 71.48779 19.46509 9.059026 62.03014 93.26316 27.47066 5.752516 25.60658 23.10108 8.724017 10.24432 86.71096 72.78528\nquantity| 45       745      898      935      64       177      238      361      850      241      296      216      717      414      657      890      407      635      108      652\nexchange| LSE      LSE      CBOE     NASDAQ   CBOE     NASDAQ   CBOE     NYSE     CBOE     NASDAQ   LSE      NYSE     NASDAQ   CBOE     CBOE     NASDAQ   LSE      NASDAQ   CBOE     LSE\nnominal | 3525.159 30541.73 54857.18 46530.2  2616.029 7960.239 331.3141 25807.09 16545.33 2183.225 18360.92 20144.84 19696.47 2381.541 16823.52 20559.96 3550.675 6505.145 9364.784 47456\n// Selecting several columns from trade using exec and then flipping the result returns a table\nq)flip exec sym,price,quantity,exchange,nominal from trade\nsym  price    quantity exchange nominal\n----------------------------------------\nMSFT 78.33686 45       LSE      3525.159\nGOOG 40.99561 745      LSE      30541.73\nMSFT 61.08817 898      CBOE     54857.18\nMSFT 49.76492 935      NASDAQ   46530.2\nIBM  40.87545 64       CBOE     2616.029\nAAPL 44.9731  177      NASDAQ   7960.239\nIBM  1.392076 238      CBOE     331.3141\nGOOG 71.48779 361      NYSE     25807.09\nAAPL 19.46509 850      CBOE     16545.33\nIBM  9.059026 241      NASDAQ   2183.225\nAAPL 62.03014 296      LSE      18360.92\nAAPL 93.26316 216      NYSE     20144.84\nAAPL 27.47066 717      NASDAQ   19696.47\nGOOG 5.752516 414      CBOE     2381.541\nAAPL 25.60658 657      CBOE     16823.52\n..\nq)trade~flip exec sym,price,quantity,exchange,nominal from trade\n1b\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Selecting several columns from ",(0,i.jsx)(n.code,{children:"trade"})," using ",(0,i.jsx)(n.code,{children:"exec"})," and then flipping the result returns a table."]})}),"\n",(0,i.jsxs)(n.p,{children:["The key difference between a ",(0,i.jsx)(n.code,{children:"select"})," statement and an ",(0,i.jsx)(n.code,{children:"exec"})," statement lies in their flexibility. White the ",(0,i.jsx)(n.code,{children:"select"})," statement always has to return a rectangular result (i.e. a table) the ",(0,i.jsx)(n.code,{children:"exec"})," statement is far more versatile, allowing the result to have any shape."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select sym,distinct exchange from trade\n'length\n  [0]  select sym,distinct exchange from trade\n       ^\nq)exec sym,distinct exchange from trade\nsym     | `MSFT`GOOG`MSFT`MSFT`IBM`AAPL`IBM`GOOG`AAPL`IBM`AAPL`AAPL`AAPL`GOOG`AAPL`GOOG`IBM`MSFT`MSFT`IBM\nexchange| `LSE`CBOE`NASDAQ`NYSE\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Just like with the ",(0,i.jsx)(n.code,{children:"select"})," statement, you cal also use the ",(0,i.jsx)(n.code,{children:"by"})," clause within an ",(0,i.jsx)(n.code,{children:"exec"})," statement."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec sym by exchange from trade\nCBOE  | `MSFT`IBM`IBM`AAPL`GOOG`AAPL`MSFT\nLSE   | `MSFT`GOOG`AAPL`IBM`IBM\nNASDAQ| `MSFT`AAPL`IBM`AAPL`GOOG`MSFT\nNYSE  | `GOOG`AAPL\nq)exec distinct sym by exchange from trade\nCBOE  | `MSFT`IBM`AAPL`GOOG\nLSE   | `MSFT`GOOG`AAPL`IBM\nNASDAQ| `MSFT`AAPL`IBM`GOOG\nNYSE  | `GOOG`AAPL\n// See how the result is a dictionary\nq)0N!exec min price by sym from trade\n`s#`AAPL`GOOG`IBM`MSFT!19.46509 5.752516 1.392076 10.24432\nAAPL| 19.46509\nGOOG| 5.752516\nIBM | 1.392076\nMSFT| 10.24432\n"})}),"\n",(0,i.jsx)(n.p,{children:"The result is a dictionary. But what if we want a table instead of a dictionary? Can we make that happen? Let's give it a try."}),"\n",(0,i.jsxs)(n.p,{children:["First, let's give the name used in the ",(0,i.jsx)(n.code,{children:"by"})," clause a name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Giving the column in the by clause a name\nq)exec sym by exchange:exchange from trade\nexchange|\n--------| ---------------------------------\nCBOE    | `MSFT`IBM`IBM`AAPL`GOOG`AAPL`MSFT\nLSE     | `MSFT`GOOG`AAPL`IBM`IBM\nNASDAQ  | `MSFT`AAPL`IBM`AAPL`GOOG`MSFT\nNYSE    | `GOOG`AAPL\n// Inspecting the output using 0N!\nq)0N!exec sym by exchange:exchange from trade\n(`s#+(,`exchange)!,`s#`CBOE`LSE`NASDAQ`NYSE)!(`MSFT`IBM`IBM`AAPL`GOOG`AAPL`MSFT;`MSFT`GOOG`AAPL`IBM`IBM;`MSFT`AAPL`IBM`AAPL`GOOG`MSFT;`GOOG`AAPL)\nexchange|\n--------| ---------------------------------\nCBOE    | `MSFT`IBM`IBM`AAPL`GOOG`AAPL`MSFT\nLSE     | `MSFT`GOOG`AAPL`IBM`IBM\nNASDAQ  | `MSFT`AAPL`IBM`AAPL`GOOG`MSFT\nNYSE    | `GOOG`AAPL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As we can see from the result, when we inspect it using the ",(0,i.jsx)(n.code,{children:"0N!"})," operator, the output is a dictionary where the key is a dictionary, and the value is a list of lists. Although it appears similar to a table, it is, in fact, not a table."]}),"\n",(0,i.jsxs)(n.p,{children:["Next, let's try naming the selected column rather than the column used in the ",(0,i.jsx)(n.code,{children:"by"})," clause."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec sym:distinct sym by exchange from trade\n      | sym\n----  | -------------------\nCBOE  | `MSFT`IBM`AAPL`GOOG\nLSE   | `MSFT`GOOG`AAPL`IBM\nNASDAQ| `MSFT`AAPL`IBM`GOOG\nNYSE  | `GOOG`AAPL\nq)0N!exec sym:distinct sym by exchange from trade\n`s#`CBOE`LSE`NASDAQ`NYSE!+(,`sym)!,(`MSFT`IBM`AAPL`GOOG;`MSFT`GOOG`AAPL`IBM;`MSFT`AAPL`IBM`GOOG;`GOOG`AAPL)\n      | sym\n----  | -------------------\nCBOE  | `MSFT`IBM`AAPL`GOOG\nLSE   | `MSFT`GOOG`AAPL`IBM\nNASDAQ| `MSFT`AAPL`IBM`GOOG\nNYSE  | `GOOG`AAPL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The result appears similar to the previous one, but now the output is a dictionary where the key is a list and the value is another dictionary. Still, it's not a table. Let's give it one last try by naming both the selected column and the column used in the ",(0,i.jsx)(n.code,{children:"by"})," clause"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec sym:distinct sym by exchange:exchange from trade\nexchange| sym\n--------| -------------------\nCBOE    | `MSFT`IBM`AAPL`GOOG\nLSE     | `MSFT`GOOG`AAPL`IBM\nNASDAQ  | `MSFT`AAPL`IBM`GOOG\nNYSE    | `GOOG`AAPL\nq)0N!exec sym:distinct sym by exchange:exchange from trade\n(`s#+(,`exchange)!,`s#`CBOE`LSE`NASDAQ`NYSE)!+(,`sym)!,(`MSFT`IBM`AAPL`GOOG;`MSFT`GOOG`AAPL`IBM;`MSFT`AAPL`IBM`GOOG;`GOOG`AAPL)\nexchange| sym\n--------| -------------------\nCBOE    | `MSFT`IBM`AAPL`GOOG\nLSE     | `MSFT`GOOG`AAPL`IBM\nNASDAQ  | `MSFT`AAPL`IBM`GOOG\nNYSE    | `GOOG`AAPL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Finally, now the result not only looks like a table but is, in fact, a keyed table. Remember, a keyed table is a dictionary where both the key and the value are dictionaries. As shown in the first line of the output, using ",(0,i.jsx)(n.code,{children:"0N!"})," confirms that this is indeed the case."]}),"\n",(0,i.jsx)(n.h4,{id:"crafting-elegant-queries-with-exec-simplify-your-q-sql",children:"Crafting Elegant Queries with exec: Simplify Your Q-SQL"}),"\n",(0,i.jsxs)(n.p,{children:["Writing Q-SQL queries can occasionally feel verbose and cumbersome, but that's where the ",(0,i.jsx)(n.code,{children:"exec"})," statement really shines over a ",(0,i.jsx)(n.code,{children:"select"})," statement.  In the following example, we'll calculate the open, high, low, and close prices for each symbol, and then sequentially for each symbol and exchange. These metrics are commonly used in candlestick charts, a key tool for technical analysis. While it\u2019s not too difficult to achieve this with a ",(0,i.jsx)(n.code,{children:"select"})," statement, the ",(0,i.jsx)(n.code,{children:"exec"})," statement offers a far more elegant and traditionally KDB/Q-style approach."]}),"\n",(0,i.jsxs)(n.p,{children:["First, let's look at the ",(0,i.jsx)(n.code,{children:"select"})," statement"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Create a candlestick chart for every symbol using a select statement\nq)select open:first price,high:max price,low:min price,close:last price by sym from trade\nsym | open     high     low      close\n----| -----------------------------------\nAAPL| 44.9731  93.26316 19.46509 25.60658\nGOOG| 40.99561 71.48779 5.752516 23.10108\nIBM | 40.87545 72.78528 1.392076 72.78528\nMSFT| 78.33686 86.71096 10.24432 86.71096\n// Create a candlestick chart for every symbol and exchange using a select statement\nq)select open:first price,high:max price,low:min price,close:last price by sym,exchange from trade\nsym  exchange| open     high     low      close\n-------------| -----------------------------------\nAAPL CBOE    | 19.46509 25.60658 19.46509 25.60658\nAAPL LSE     | 62.03014 62.03014 62.03014 62.03014\nAAPL NASDAQ  | 44.9731  44.9731  27.47066 27.47066\nAAPL NYSE    | 93.26316 93.26316 93.26316 93.26316\nGOOG CBOE    | 5.752516 5.752516 5.752516 5.752516\nGOOG LSE     | 40.99561 40.99561 40.99561 40.99561\nGOOG NASDAQ  | 23.10108 23.10108 23.10108 23.10108\nGOOG NYSE    | 71.48779 71.48779 71.48779 71.48779\nIBM  CBOE    | 40.87545 40.87545 1.392076 1.392076\nIBM  LSE     | 8.724017 72.78528 8.724017 72.78528\nIBM  NASDAQ  | 9.059026 9.059026 9.059026 9.059026\nMSFT CBOE    | 61.08817 86.71096 61.08817 86.71096\nMSFT LSE     | 78.33686 78.33686 78.33686 78.33686\nMSFT NASDAQ  | 49.76492 49.76492 10.24432 10.24432\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, this is quite a bit of typing. Next, let's take a look at the corresponding ",(0,i.jsx)(n.code,{children:"exec"})," statement."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Create a candlestick chart for every symbol using an exec statement\nq)exec `open`high`low`close!(first;max;min;last)@\\:price by sym:sym from trade\nsym | open     high     low      close\n----| -----------------------------------\nAAPL| 44.9731  93.26316 19.46509 25.60658\nGOOG| 40.99561 71.48779 5.752516 23.10108\nIBM | 40.87545 72.78528 1.392076 72.78528\nMSFT| 78.33686 86.71096 10.24432 86.71096\n// Create a candlestick chart for every symbol and exchange using an exec statement\nq)exec `open`high`low`close!(first;max;min;last)@\\:price by sym,exchange from trade\nsym  exchange| open     high     low      close\n-------------| -----------------------------------\nAAPL CBOE    | 19.46509 25.60658 19.46509 25.60658\nAAPL LSE     | 62.03014 62.03014 62.03014 62.03014\nAAPL NASDAQ  | 44.9731  44.9731  27.47066 27.47066\nAAPL NYSE    | 93.26316 93.26316 93.26316 93.26316\nGOOG CBOE    | 5.752516 5.752516 5.752516 5.752516\nGOOG LSE     | 40.99561 40.99561 40.99561 40.99561\nGOOG NASDAQ  | 23.10108 23.10108 23.10108 23.10108\nGOOG NYSE    | 71.48779 71.48779 71.48779 71.48779\nIBM  CBOE    | 40.87545 40.87545 1.392076 1.392076\nIBM  LSE     | 8.724017 72.78528 8.724017 72.78528\nIBM  NASDAQ  | 9.059026 9.059026 9.059026 9.059026\nMSFT CBOE    | 61.08817 86.71096 61.08817 86.71096\nMSFT LSE     | 78.33686 78.33686 78.33686 78.33686\nMSFT NASDAQ  | 49.76492 49.76492 10.24432 10.24432\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is much more elegant, isn\u2019t it? The reason the ",(0,i.jsx)(n.code,{children:"exec"})," statement works so well is that for each symbol (or symbol and exchange in the second example), KDB/Q creates a dictionary with conforming keys, which is then transformed into a table. As we've learned, a list of conforming dictionaries forms a table (if you need a refresher on tables, dictionaries, and column dictionaries, please refer to my blog post ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/dictionariesTables",children:"here"}),"). You can see the underlying structure when we inspect the result in more detail."]}),"\n",(0,i.jsxs)(n.p,{children:["When we examine the individual records generated by the ",(0,i.jsx)(n.code,{children:"by"})," clause in the ",(0,i.jsx)(n.code,{children:"exec"})," statement, we can observe that it's a list of conforming dictionaries."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exec 0N!`open`high`low`close!(first;max;min;last)@\\:price by sym:sym from trade\n`open`high`low`close!78.33686 86.71096 10.24432 86.71096\n`open`high`low`close!40.99561 71.48779 5.752516 23.10108\n`open`high`low`close!40.87545 72.78528 1.392076 72.78528\n`open`high`low`close!44.9731 93.26316 19.46509 25.60658\nsym | open     high     low      close\n----| -----------------------------------\nAAPL| 44.9731  93.26316 19.46509 25.60658\nGOOG| 40.99561 71.48779 5.752516 23.10108\nIBM | 40.87545 72.78528 1.392076 72.78528\nMSFT| 78.33686 86.71096 10.24432 86.71096\n"})}),"\n",(0,i.jsx)(n.p,{children:"This list of conforming dictionaries is subsequently transformed into a table."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)0N!exec `open`high`low`close!(first;max;min;last)@\\:price by sym:sym from trade\n(`s#+(,`sym)!,`s#`AAPL`GOOG`IBM`MSFT)!+`open`high`low`close!(44.9731 40.99561 40.87545 78.33686;93.26316 71.48779 72.78528 86.71096;19.46509 5.752516 1.392076 10.24432;25.60658 23.10108 72.78528 86.71096)\nsym | open     high     low      close\n----| -----------------------------------\nAAPL| 44.9731  93.26316 19.46509 25.60658\nGOOG| 40.99561 71.48779 5.752516 23.10108\nIBM | 40.87545 72.78528 1.392076 72.78528\nMSFT| 78.33686 86.71096 10.24432 86.71096\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we try to accomplish the same with a ",(0,i.jsx)(n.code,{children:"select"})," statement, we\u2019ll end up disappointed. At first glance, the result may seem acceptable, but upon closer inspection, it's clear that it's not what we intended. The candlestick metrics we calculated have been grouped into a single column, making it inconvenient for any further processing."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select (first;max;min;last)@\\:price by sym from trade\nsym | price\n----| -----------------------------------\nAAPL| 44.9731  93.26316 19.46509 25.60658\nGOOG| 40.99561 71.48779 5.752516 23.10108\nIBM | 40.87545 72.78528 1.392076 72.78528\nMSFT| 78.33686 86.71096 10.24432 86.71096\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"0N!"})," to inspect the result highlights this issue even more."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)0N!select (first;max;min;last)@\\:price by sym from trade\n(`s#+(,`sym)!,`s#`AAPL`GOOG`IBM`MSFT)!+(,`price)!,(44.9731 93.26316 19.46509 25.60658;40.99561 71.48779 5.752516 23.10108;40.87545 72.78528 1.392076 72.78528;78.33686 86.71096 10.24432 86.71096)\nsym | price\n----| -----------------------------------\nAAPL| 44.9731  93.26316 19.46509 25.60658\nGOOG| 40.99561 71.48779 5.752516 23.10108\nIBM | 40.87545 72.78528 1.392076 72.78528\nMSFT| 78.33686 86.71096 10.24432 86.71096\n"})}),"\n",(0,i.jsx)(n.p,{children:"There is one downside to our elegant code: we trade speed for conciseness. Since we are iterating through the price column for every function in our exec statement, this approach is slower than the select statement, which avoids iteration. In fact, the select statement is approximately 30% faster than the exec statement. If performance is critical, you may need to resort to a more verbose select statement. However, if performance isn't your primary concern, aim for the more elegant solution by using the exec statement."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)\\ts:10000 exec `open`high`low`close!(first;max;min;last)@\\:price by sym:sym from trade\n66 11392\nq)\\ts:10000 select open:first price,high:max price,low:min price,close:last price by sym from trade\n42 3008\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["In conclusion, we've explored the unique power and flexibility of Q-SQL, especially through its efficient handling of large datasets. We have learned about ",(0,i.jsx)(n.code,{children:"select"}),", ",(0,i.jsx)(n.code,{children:"update"}),", ",(0,i.jsx)(n.code,{children:"delete"})," and the flexible exec statements, and the use of nested queries. Unlike standard SQL, Q-SQL allows for more elegant, concise code while leveraging vectorized operations to enhance performance. These features make it a powerful tool for complex data analysis. I hope this deep dive helps you on your journey with KDB/Q!"]}),"\n",(0,i.jsxs)(n.p,{children:["Happy coding, and don't hesitate to reach out if you need any guidance. Make sure to subscribe to my newsletter ",(0,i.jsx)(n.a,{href:"https://defconq.substack.com",children:"here"})," to stay updated!"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Resources"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/",children:"Q for Mortals, Chapter 9: Queries: q-sql"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.amazon.co.uk/Tips-Fast-Scalable-Maintainable-Kdb/dp/9881389909/ref=sr_1_1?crid=2TXXQ5KF3QP2F&dib=eyJ2IjoiMSJ9.Y6P9bHDEKP-atK4ImvugPeFdDmX11RAYdkw4oEoR2Z8D7z6tlKY2lTsqtFdPjdzIu9BqidS6G-RpIVcRXPwJWLpHEyLEk5tDbPtL11RJ_tZrdcLK46XdH1zrj5RodmNpcpxuTGsJ9iJG8yDBUYuubrXdfnh4Dy0v4W_R5jGGLnk.fJihB-HM5Yy8Vgv_ISFrQA6MX6ClKNF-GxX5m1bCfG0&dib_tag=se&keywords=nick+psaris+q+tips&qid=1728220898&sprefix=%2Caps%2C107&sr=8-1",children:"Q Tips: Fast, Scalable and Maintainable Kdb+ by Nick Psaris"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},7476:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/deleteCells-6318039c4672237c14046f882f6f5692.png"},2356:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/deleteStatement-d970fb629b0747e68876dff9390819ea.png"},1198:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/execStatement-a5781116cb968c489d720e134e24dcec.png"},9203:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/selectStatement-3eeb6fad448d510eabf30b878ffeef7b.png"},1482:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/updateStatement-4a66e5939675682fb16d9fc172b7123d.png"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);