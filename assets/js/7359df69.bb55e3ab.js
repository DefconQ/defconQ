"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2978],{4413:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var t=s(74848),i=s(28453);const o={sidebar_position:11},r="Fundamentals of Interprocess Communication (IPC)",c={id:"concepts/ipc",title:"Fundamentals of Interprocess Communication (IPC)",description:"We have now covered most of the key KDB/Q concepts, with just one crucial topic left before you're fully equipped to build a complete KDB/Q application: Interprocess Cummincation (OPC). The last piece of the puzzle is understanding how KDB/Q processes communicate with each other. In the following section, we will explore how to establish a connection to a KDB/Q process, using connection handles to send messages, the differences between synchronous and asynchronous communication, their respective advantages, and when to use each. While IPC can be complex in many mainstream programming languages, KDB/Q provides it out of the box. So, without further delay, let's jump into the world of IPC!",source:"@site/docs/concepts/ipc.mdx",sourceDirName:"concepts",slug:"/concepts/ipc",permalink:"/docs/concepts/ipc",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"Iterators: Navigating Vectors Without the Need for Loops",permalink:"/docs/concepts/iterators"},next:{title:"Beyond the Fundamentals: Next Level Interprocess Communications",permalink:"/docs/concepts/ipcNextLevel"}},a={},h=[{value:"Why IPC matters",id:"why-ipc-matters",level:2},{value:"Before You Start Communicating: Setting Up a Port",id:"before-you-start-communicating-setting-up-a-port",level:2},{value:"Opening a connection: <code>hopen</code>",id:"opening-a-connection-hopen",level:2},{value:"Syntax",id:"syntax",level:3},{value:"TCP",id:"tcp",level:4},{value:"Unix domain socket",id:"unix-domain-socket",level:4},{value:"SSL/TLS",id:"ssltls",level:4},{value:"TCP  with SSL/TLS encryption",id:"tcp--with-ssltls-encryption",level:5},{value:"Unix domain socket with SSL/TLS encryption",id:"unix-domain-socket-with-ssltls-encryption",level:5},{value:"FIFO/Named Pipes",id:"fifonamed-pipes",level:4},{value:"Why Use a FIFO Named Pipe?",id:"why-use-a-fifo-named-pipe",level:5},{value:"What Happens When You Open a Connection?",id:"what-happens-when-you-open-a-connection",level:3},{value:"One-shot connections",id:"one-shot-connections",level:3},{value:"Message Formats: Sending Queries the Right Way",id:"message-formats-sending-queries-the-right-way",level:2},{value:"Closing a connection: <code>hclose</code>",id:"closing-a-connection-hclose",level:2},{value:"Synchronous vs Asynchronous communication",id:"synchronous-vs-asynchronous-communication",level:2},{value:"Synchronous Communication",id:"synchronous-communication",level:3},{value:"Asynchronous Communication",id:"asynchronous-communication",level:3},{value:"Flushing: Important Consideration when Sending Asynchronous Messages",id:"flushing-important-consideration-when-sending-asynchronous-messages",level:4},{value:"Message Handlers",id:"message-handlers",level:3},{value:"Customising Message Handlers",id:"customising-message-handlers",level:4},{value:"Testing Customised Implementations",id:"testing-customised-implementations",level:4},{value:"Synchronous vs Asynchronous Communication in the KDB/Q Tick Architecture",id:"synchronous-vs-asynchronous-communication-in-the-kdbq-tick-architecture",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"fundamentals-of-interprocess-communication-ipc",children:"Fundamentals of Interprocess Communication (IPC)"}),"\n",(0,t.jsx)(n.p,{children:"We have now covered most of the key KDB/Q concepts, with just one crucial topic left before you're fully equipped to build a complete KDB/Q application: Interprocess Cummincation (OPC). The last piece of the puzzle is understanding how KDB/Q processes communicate with each other. In the following section, we will explore how to establish a connection to a KDB/Q process, using connection handles to send messages, the differences between synchronous and asynchronous communication, their respective advantages, and when to use each. While IPC can be complex in many mainstream programming languages, KDB/Q provides it out of the box. So, without further delay, let's jump into the world of IPC!"}),"\n",(0,t.jsx)(n.h2,{id:"why-ipc-matters",children:"Why IPC matters"}),"\n",(0,t.jsx)(n.p,{children:"Before diving into the technical details of IPC, let\u2019s take a step back and look at the bigger picture: why do we need IPC in the first place? When designing a KDB/Q application (or any application, for that matter), relying on a single process to handle all tasks is not ideal. Not only does this create a single point of failure, but it also places an overwhelming burden on that one process. Imagine being the only employee in your company, you would struggle to keep up with all the tasks, and even if you managed, the quality of your work would likely suffer. The same principle applies to a software application."}),"\n",(0,t.jsxs)(n.p,{children:["A more efficient approach is to adopt a microservices-style architecture, breaking down tasks into smaller, specialized processes that communicate with each other. This is where IPC comes into play: it enables seamless communication between different components of a KDB/Q Tick system, such as the Tickerplant, Real-time Database, Historical Database, and more. For a deeper dive into the typical architecture of a KDB/Q Tick setup, check out my blog post ",(0,t.jsx)(n.a,{href:"https://www.defconq.tech/docs/architecture/plain",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"before-you-start-communicating-setting-up-a-port",children:"Before You Start Communicating: Setting Up a Port"}),"\n",(0,t.jsx)(n.p,{children:"Before two processes can communicate, a connection must be established, and to do that, you need the address of the process you\u2019re trying to reach. It\u2019s just like making a phone call; you need to know the recipient\u2019s number. The same applies to Interprocess Communication (IPC)."}),"\n",(0,t.jsx)(n.p,{children:"There are multiple ways to open a connection to a KDB/Q process, which we\u2019ll explore in the next section. But first, we need to understand how to set the port of a KDB/Q process, as that\u2019s what we\u2019ll use to connect."}),"\n",(0,t.jsx)(n.p,{children:"Think of a port like an apartment number in a large building. The server running the process is the entire apartment complex, and each port represents a different flat. To communicate with a specific process, you need to know its port number, just like you\u2019d need an apartment number to visit a friend in a large housing block."}),"\n",(0,t.jsxs)(n.p,{children:["In KDB/Q, you can define a process\u2019s port either at startup using the ",(0,t.jsx)(n.code,{children:"-p"})," flag or dynamically at runtime using the ",(0,t.jsx)(n.code,{children:"\\p"})," system command. Let\u2019s see how that works."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Start a KDB/Q process on port 5001 from the command line\n(base) alexanderunterrainer@Mac:~|\u21d2  qq -p 5001\nKDB+ 4.0 2023.01.20 Copyright (C) 1993-2023 Kx Systems\nm64/ 8(24)core 24576MB alexanderunterrainer mac 192.168.1.177 EXPIRE 2025.02.21 KDB PLUS TRIAL #5018719\n\nq)\\p\n5001i\nq)\\\\\n// Start a KDB/Q process without defining the port and assign it at runtime\n(base) alexanderunterrainer@Mac:~|\u21d2  qq\nKDB+ 4.0 2023.01.20 Copyright (C) 1993-2023 Kx Systems\nm64/ 8(24)core 24576MB alexanderunterrainer mac 192.168.1.177 EXPIRE 2025.02.21 KDB PLUS TRIAL #5018719\n\nq)\\p 5001\nq)\\p\n5001i\nq)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Interprocess communication in KDB/Q functions both between processes on the same machine and across different machines, provided you have the necessary connection details for the target process."}),"\n",(0,t.jsxs)(n.h2,{id:"opening-a-connection-hopen",children:["Opening a connection: ",(0,t.jsx)(n.code,{children:"hopen"})]}),"\n",(0,t.jsxs)(n.p,{children:["Now, let\u2019s learn how to connect to a KDB/Q process. For this, we have set up two KDB/Q processes: a client process (Process A) running on port ",(0,t.jsx)(n.code,{children:"6000"})," and a server process (Process B) running on port ",(0,t.jsx)(n.code,{children:"6001"}),". We establish the connection using the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/hopen/",children:(0,t.jsx)(n.code,{children:"hopen"})})," keyword."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Opening a connection: hopen",src:s(53955).A+"",width:"674",height:"294"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"hopen"})," not only allows you to open a connection to a KDB/Q process, but it also lets you specify the protocol, connect to a file or a named pipe, authenticate with a username and password, and even set a timeout in case the target process doesn\u2019t respond."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"(base) alexanderunterrainer@Mac:~/repos/defconQ/my-website/docs/concepts|master\u26a1 \u21d2  qq -p 6000\nKDB+ 4.0 2023.01.20 Copyright (C) 1993-2023 Kx Systems\nm64/ 8(24)core 24576MB alexanderunterrainer mac 192.168.1.177 EXPIRE 2025.02.21 KDB PLUS TRIAL #5018719\nq)// Client\nq)h:hopen `::6001\nq)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"(base) alexanderunterrainer@Mac:~|\u21d2  qq -p 6001\nKDB+ 4.0 2023.01.20 Copyright (C) 1993-2023 Kx Systems\nm64/ 8(24)core 24576MB alexanderunterrainer mac 192.168.1.177 EXPIRE 2025.02.21 KDB PLUS TRIAL #5018719\nq)// Server\nq)\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Opening a connection: hopen",src:s(80967).A+"",width:"3384",height:"368"})}),"\n",(0,t.jsxs)(n.p,{children:["That was pretty easy, wasn\u2019t it? When connecting to a process on the same machine, you only need to specify the port number, no need to include the hostname. Alternatively, you can use ",(0,t.jsx)(n.code,{children:"localhost"}),". Below is the full syntax for opening a connection from one process to another."]}),"\n",(0,t.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// hopen filehandle\nq)hopen ":path/to/file.txt"  \n// hopen processhandle\nq)hopen `:localhost:5000\n// hopen (communicationhandle;timeout)\nq)hopen(":10.43.23.198:5010";10000) \n// hopen port\nq)hopen 5010\n'})}),"\n",(0,t.jsx)(n.p,{children:"Additionally, you can specify the communication protocol of your choice, whether it's the default TCP protocol, with or without SSL encryption, or Unix Domain Sockets. The process remains simple and straightforward."}),"\n",(0,t.jsx)(n.h4,{id:"tcp",children:"TCP"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)hopen `:host:port[:user:password]\n"})}),"\n",(0,t.jsx)(n.p,{children:"host can be a hostname or IP address; omitted, it denotes the localhost"}),"\n",(0,t.jsx)(n.h4,{id:"unix-domain-socket",children:"Unix domain socket"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)hopen `:unix://port[:user:password]\n"})}),"\n",(0,t.jsx)(n.p,{children:"(Since V3.4.) Unix domain sockets can have significantly lower latency and higher throughput than a localhost TCP connection"}),"\n",(0,t.jsx)(n.h4,{id:"ssltls",children:"SSL/TLS"}),"\n",(0,t.jsx)(n.h5,{id:"tcp--with-ssltls-encryption",children:"TCP  with SSL/TLS encryption"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)hopen `:tcps://host:port[:user:password]\n"})}),"\n",(0,t.jsx)(n.h5,{id:"unix-domain-socket-with-ssltls-encryption",children:"Unix domain socket with SSL/TLS encryption"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)hopen `:unixs://port\n"})}),"\n",(0,t.jsx)(n.p,{children:"\xa0"}),"\n",(0,t.jsx)(n.h4,{id:"fifonamed-pipes",children:"FIFO/Named Pipes"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Named_pipe",children:(0,t.jsx)(n.strong,{children:"FIFO"})})," (First In, First Out) named pipe is a special type of file that allows for interprocess communication (IPC) by enabling one process to write data while another process reads it in the same order. Unlike regular files, FIFO pipes do not store data on disk permanently; instead, they act as a channel for data flow between processes."]}),"\n",(0,t.jsx)(n.h5,{id:"why-use-a-fifo-named-pipe",children:"Why Use a FIFO Named Pipe?"}),"\n",(0,t.jsxs)(n.p,{children:["When dealing with ",(0,t.jsx)(n.strong,{children:"large files"})," that cannot fit into memory all at once, a FIFO named pipe is a great solution. Instead of loading the entire file into RAM, you can ",(0,t.jsx)(n.strong,{children:"stream"})," the data, reading it in chunks, processing it on the fly, and writing the processed output to disk or another process. This is particularly useful for scenarios like:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Efficiently handling large datasets"})," without overwhelming memory"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-time data transformation"})," before storage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parallel processing"})," between multiple applications"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["By using a FIFO named pipe, you can process large files in a ",(0,t.jsx)(n.strong,{children:"memory-efficient and scalable way"}),", reducing the need for temporary storage and speeding up workflows."]}),"\n",(0,t.jsx)(n.p,{children:"If you want to connect to a FIFO named pipe you can do so by using"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)hopen `:fifo://filename\n"})}),"\n",(0,t.jsx)(n.h3,{id:"what-happens-when-you-open-a-connection",children:"What Happens When You Open a Connection?"}),"\n",(0,t.jsx)(n.p,{children:"What actually happens when we establish a connection to another KDB/Q process?"}),"\n",(0,t.jsxs)(n.p,{children:["When we use ",(0,t.jsx)(n.code,{children:"hopen"})," o open a connection from our client process to a server process and store the result in a variable ",(0,t.jsx)(n.code,{children:"h"}),", we can observe that ",(0,t.jsx)(n.code,{children:"hopen"})," returns a positive integer ",(0,t.jsx)(n.strong,{children:"\u22653"}),". This number is our ",(0,t.jsx)(n.strong,{children:"connection handle"}),", which we use to communicate with the server."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)// Client\nq)h:hopen `::6001\nq)h\n8i\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you think the fact that it's ",(0,t.jsx)(n.strong,{children:"\u22653"})," is trivial, think again. It ",(0,t.jsx)(n.strong,{children:"cannot"})," be 0, 1, or 2 because:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"0 is reserved for standard input"}),"\n",(0,t.jsx)(n.li,{children:"1 is reserved for standard output"}),"\n",(0,t.jsx)(n.li,{children:"2 is reserved for standard error"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"Both the client and server have their own connection handles when a connection is established between them. However, these handles are assigned independently, meaning their integer values are generally not the same."})}),"\n",(0,t.jsxs)(n.p,{children:["As shown in the example above, we stored the connection handle returned by",(0,t.jsx)(n.code,{children:"hopen"})," in a varibale ",(0,t.jsx)(n.code,{children:"h"}),". We can then use this variable to interact with the connected KDB/Q process, in this case, the server. However, you might be surprised to learn that using the variable isn\u2019t strictly necessary. The variable is simply a literal, meaning we can use its actual value directly to communicate with the server. Let\u2019s explore this in more detail."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)h:hopen `::6001\nq)h\n8i\n// Using the variable h to communicate with the server\nq)h "2+2"\n4\n// Using the connection handle itself to communicate with the serer\nq)8 "2+2"\n4\n'})}),"\n",(0,t.jsxs)(n.p,{children:["But that's only half the story. When KDB/Q processes communicate, ",(0,t.jsx)(n.strong,{children:"built-in message handlers"})," are triggered based on the type of request received. In the case of opening a connection, the ",(0,t.jsx)(n.code,{children:".z.po"})," (",(0,t.jsx)(n.strong,{children:"process open"}),") handler is invoked on the ",(0,t.jsx)(n.strong,{children:"server"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["However, ",(0,t.jsx)(n.code,{children:".z.po"})," is ",(0,t.jsx)(n.strong,{children:"not"})," the first event that occurs. Before reaching ",(0,t.jsx)(n.code,{children:".z.po"})," he system performs ",(0,t.jsx)(n.strong,{children:"authentication and security checks"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User permissions"})," are validated against any ",(0,t.jsx)(n.code,{children:"-u/-U file"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Password checks"})," are performed using ",(0,t.jsx)(n.code,{children:".z.pw"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Only ",(0,t.jsx)(n.strong,{children:"after both checks pass"}),", ",(0,t.jsx)(n.code,{children:".z.po"})," is finally executed."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Understanding this flow is crucial, this is a ",(0,t.jsx)(n.strong,{children:"common interview question"})," for KDB/Q developers, so make sure you understand these details!"]})}),"\n",(0,t.jsx)(n.h3,{id:"one-shot-connections",children:"One-shot connections"}),"\n",(0,t.jsxs)(n.p,{children:["Whenever you use ",(0,t.jsx)(n.code,{children:"hopen"})," to establish a connection between two KDB/Q processes, a persistent connection is created, and a connection handle is assigned to it. Before KDB/Q ",(0,t.jsx)(n.code,{children:"version 4.1"}),", the number of connections was limited to ",(0,t.jsx)(n.code,{children:"1022"}),", and exceeding this limit resulted in a ",(0,t.jsx)(n.code,{children:"'conn"})," error on the server. To prevent this, it was essential to close connections using ",(0,t.jsx)(n.code,{children:"hclose"})," when they were no longer needed. However, if you only needed to execute a single query without maintaining an open connection, you could use a one-shot connection, which automatically opens, executes the query, and then closes without requiring manual intervention."]}),"\n",(0,t.jsx)(n.p,{children:"Let's look at an example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)`::6001 "2+2"\n4\nq)(`::6001)"2+2"\n4\nq)(`:localhost:6001)"2+2"\n4\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, we sent a synchronous query, ",(0,t.jsx)(n.code,{children:'"2+2"'}),", from the client to the server, and after the query was evaluated on the server, the result, ",(0,t.jsx)(n.code,{children:"4"}),", was returned. Since ",(0,t.jsx)(n.code,{children:"KDB/Q version 4.0"})," you can now send one-shot queries as below"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'`::[(":host:port:username:password";timeout);query]\n\nq)`::[(":localhost:6001";5000);"2+2"]\n4\n'})}),"\n",(0,t.jsx)(n.h2,{id:"message-formats-sending-queries-the-right-way",children:"Message Formats: Sending Queries the Right Way"}),"\n",(0,t.jsx)(n.p,{children:"Now that we've established how to connect two KDB/Q processes, let's explore the different ways to send messages and execute queries. In the previous example, we used a simple string to send a query from the client to the server. While this approach is straightforward, it is also prone to errors and can be inconvenient."}),"\n",(0,t.jsx)(n.p,{children:"For instance, consider a trades table on the server with a sym column of type string. If you try querying this table remotely using a plain string query, you'll quickly run into issues, specifically, an error due to unescaped quotation marks. To include string values in your query correctly, you must escape the quotes, which is both cumbersome and error-prone."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Server"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// Server side\nq)show trades:([] sym:("GOOG";"AAPL";"MSFT"); price:10 20 30)\nsym    price\n------------\n"GOOG" 10\n"AAPL" 20\n"MSFT" 30\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Client"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// Client side\n\n// Without escaping quotation marks\nq)h "select from trades where sym like "AAPL"""\n\'"\n  [0]  h "select from trades where sym like "AAPL"""\n\n// Escaping quotation marks\nq)h "select from trades where sym like \\"AAPL\\""\nsym    price\n------------\n"AAPL" 20\n'})}),"\n",(0,t.jsx)(n.p,{children:"In the next section, we'll explore the best practices for sending queries via IPC, ensuring a more reliable and efficient approach."}),"\n",(0,t.jsxs)(n.p,{children:["Whenever a KDB/Q process receives a message, it automatically triggers one of the built-in message handlers: ",(0,t.jsx)(n.code,{children:"z.pg"})," (for ",(0,t.jsx)(n.strong,{children:"GET"})," requests) or ",(0,t.jsx)(n.code,{children:".z.ps"})," (for ",(0,t.jsx)(n.strong,{children:"SET"})," requests). The handler invoked depends on whether the query was sent ",(0,t.jsx)(n.strong,{children:"synchronously"})," or ",(0,t.jsx)(n.strong,{children:"asynchronously"})," (we\u2019ll dive deeper into synchronous vs. asynchronous messaging later)."]}),"\n",(0,t.jsxs)(n.p,{children:["By default, both handlers use the KDB/Q ",(0,t.jsx)(n.code,{children:"value"})," operator to evaluate the received query. This concept is similar to how functional selects and parse trees work (which I covered in a previous blog post ",(0,t.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/functionalSelect",children:"here"}),"). Queries sent via IPC follow the same structure: they are parsed as lists, where the first element represents the function and the remaining elements are its arguments."]}),"\n",(0,t.jsx)(n.p,{children:"Understanding this structure allows us to send queries as lists over IPC. We can either:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Call a function that exists on the server"}),", passing the function\u2019s name as a symbol (literal)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Send a function defined on the client"})," along with its arguments, which will then be executed on the server."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To demonstrate, let\u2019s first define a simple function ",(0,t.jsx)(n.code,{children:"f"})," on the server, which takes two numbers and returns their sum. Once defined, we can send a synchronous query from the client in the form of a list. If the function is already defined on the server, we must pass its name as a symbol, ensuring the function is properly invoked on the remote process."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// We define a function f on the server\nq)f:{x+y}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// We can now make a synchronous query in form of a list to the server\nq)h (`f;2;3)\n5\n"})}),"\n",(0,t.jsx)(n.p,{children:"While it\u2019s technically possible to pass the function name as a string, we\u2019ve already established that using strings for IPC is not ideal due to potential escaping issues."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)h ("f";2;3)\n5\n'})}),"\n",(0,t.jsx)(n.p,{children:"Alternatively, if we want to execute a function that exists only on the client but have it run on the server, we can pass the function itself, either as a variable or an anonymous lambda, as the first argument. In this case, the function definition stored in the variable will be evaluated first (substituting the variable name with the actual function definition) before being sent to the server. This happens because the KDB/Q compiler evaluates all resolvable expressions before proceeding with query execution."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Define a function on the client side\nq)f1:{x-y}\nq)h (f1;10;3)\n7\nq)h ({x-y};10;3)\n7\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see from the below error, the function ",(0,t.jsx)(n.code,{children:"f1"})," is not defined on the server, and it's really the definition on the client side that has been invoked."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)f1\n'f1\n  [0]  f1\n       ^\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"closing-a-connection-hclose",children:["Closing a connection: ",(0,t.jsx)(n.code,{children:"hclose"})]}),"\n",(0,t.jsxs)(n.p,{children:["As we discussed earlier, if you're not using the latest version of KDB/Q, the number of connection handles is limited to ",(0,t.jsx)(n.code,{children:"1022"})," (this restriction was lifted in ",(0,t.jsx)(n.code,{children:"KDB/Q version 4.1"}),"). To avoid hitting this limit, it's good practice to close connection handles once they are no longer needed. This can be done easily using the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/hopen/#hclose",children:(0,t.jsx)(n.code,{children:"hclose"})})," operator, which takes the connection handle as its argument and terminates the connection."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)hclose h\nq)h\n8i\nq)h "2+2"\n\'Cannot write to handle 8. OS reports: Bad file descriptor\n  [0]  h "2+2"\n       ^\n'})}),"\n",(0,t.jsx)(n.h2,{id:"synchronous-vs-asynchronous-communication",children:"Synchronous vs Asynchronous communication"}),"\n",(0,t.jsx)(n.p,{children:"Now that we've covered how to open and close a connection and the proper format for sending queries over IPC, let's shift our focus to synchronous and asynchronous communication, how they differ and when to use each."}),"\n",(0,t.jsxs)(n.p,{children:["In simple terms, a ",(0,t.jsx)(n.strong,{children:"synchronous"})," message causes the client process to pause after sending the request, waiting for a response from the server before proceeding. In contrast, an ",(0,t.jsx)(n.strong,{children:"asynchronous"})," message is sent to the server, but the client continues execution immediately without waiting for a reply. Notably, asynchronous communication does not return a value from the server."]}),"\n",(0,t.jsxs)(n.p,{children:["The diagram below, which I borrowed from my very good friend ",(0,t.jsx)(n.a,{href:"https://www.linkedin.com/in/nelsonamigoscode/",children:"Nelson"}),", founder of ",(0,t.jsx)(n.a,{href:"https://www.linkedin.com/company/amigoscode/",children:"Amigoscode"}),", an online training platform covering all things software engineering (except KDB/Q, which is my domain), illustrates the key differences between synchronous and asynchronous communication."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Synchronous vs Asynchronous Communication",src:s(54695).A+"",width:"889",height:"1034"})}),"\n",(0,t.jsx)(n.p,{children:"We are now going to take a deeper look at synchronous and asynchronous communication, exploring their behavior, benefits, and the best scenarios for using each."}),"\n",(0,t.jsx)(n.h3,{id:"synchronous-communication",children:"Synchronous Communication"}),"\n",(0,t.jsxs)(n.p,{children:["When sending a ",(0,t.jsx)(n.strong,{children:"synchronous"})," message from process A (the client) to process B (the server), a ",(0,t.jsx)(n.strong,{children:"positive"})," connection handle is used. This causes the client to block immediately after sending the query, waiting for a response from the server before proceeding. Behind the scenes, the following sequence of events takes place:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Any pending ",(0,t.jsx)(n.strong,{children:"outgoing asynchronous"})," messages on handle ",(0,t.jsx)(n.code,{children:"h"})," are first sent."]}),"\n",(0,t.jsx)(n.li,{children:"The client transmits a message containing the arguments of the handle application to the server and waits for a response, pausing execution until a result is received."}),"\n",(0,t.jsx)(n.li,{children:"The server receives the message, processes it as a function application, and computes the result."}),"\n",(0,t.jsx)(n.li,{children:"The server sends the computed result back to the client."}),"\n",(0,t.jsx)(n.li,{children:"The client receives the response and resumes execution from where it left off."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In synchronous message passing, when a client sends multiple queries to a server, the next query is only sent after the previous result has been received. This ensures that messages arrive at the server in the exact order they were sent, and the corresponding results are returned to the client in the same sequence."}),"\n",(0,t.jsx)(n.p,{children:"We've previously explored how to use a positive connection handle to send a synchronous message from a client to a server. Now, let's revisit this concept to reinforce our understanding."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// positive connection handle\nq)h\n8i\n// synchronous call to our server\nq)h "2+2"\n4\n'})}),"\n",(0,t.jsx)(n.p,{children:"We've mentioned that when sending a synchronous message, the client process blocks until a response is received, preventing any further commands from executing in the meantime. But can we actually verify this, or do you just have to take my word for it? Of course not! This can be easily tested, and I'll show you how."}),"\n",(0,t.jsx)(n.p,{children:"We'll create a lambda function that first prints the current datetime to the console. Then, it sends another lambda function to the server, which will invoke the sleep command, pausing for two seconds before adding two numbers and returning the sum to the client. Finally, we'll print the current datetime again to see exactly when the response is received. This will clearly demonstrate the blocking nature of synchronous communication."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q){0N!.z.p;0N!h ({system "sleep 2";x+y};2;2);.z.p}[]\n2025.02.23D13:04:12.114709000\n4\n2025.02.23D13:04:14.146935000\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In summary, ",(0,t.jsx)(n.strong,{children:"synchronous"})," queries are similar to an ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/HTTP",children:"HTTP GET"})," request, as they involve requesting data from a server process and waiting for a response before proceeding. This type of messaging is best suited for scenarios where time and performance are not critical, and when receiving a result is necessary for further execution."]}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-communication",children:"Asynchronous Communication"}),"\n",(0,t.jsxs)(n.p,{children:["When sending an ",(0,t.jsx)(n.strong,{children:"asynchronous"})," message from process A (the client) to process B (the server), a ",(0,t.jsx)(n.strong,{children:"negative"})," connection handle is used. In this scenario, the message is dispatched to the server, and the client continues execution immediately without waiting for a response. This approach is ideal when the result of the operation is not needed, such as triggering a long-running task or forwarding messages to other processes. Since the client does not wait for a reply, asynchronous messaging is essential in cases where delays from an unresponsive subscriber are unacceptable, such as in a tickerplant. Since an asynchronous message does not require a response from the server, it can be likened to an HTTP POST (SET) request."]}),"\n",(0,t.jsxs)(n.p,{children:["In the following example, we use the KDB/Q ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/neg/",children:(0,t.jsx)(n.code,{children:"neg"})})," operator to create a negative connection handle, allowing us to make an asynchronous call. We assign the value ",(0,t.jsx)(n.code,{children:"10"})," to a variable ",(0,t.jsx)(n.code,{children:"a"})," on the server without expecting any return value."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// verify that we are on the client\nq)\\p\n6000i\nq)neg[h]"a:10"\nq)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Verify that we are on the server\nq)\\p\n6001i\n// Verify the content of the variable a we just set via an asynchronous call\nq)a\n10\n"})}),"\n",(0,t.jsx)(n.p,{children:"To confirm that the client process remains unblocked, we replicate the previous synchronous example but replace the synchronous request with an asynchronous one."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q){0N!.z.p;neg[h] ({0N!.z.p;system "sleep 2";0N!x;0N!.z.p};2);.z.p}[]\n2025.02.23D13:56:52.381290000\n2025.02.23D13:56:52.381414000\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"2025.02.23D13:56:52.381771000\n2\n2025.02.23D13:56:54.408662000\n"})}),"\n",(0,t.jsx)(n.p,{children:"We first printed the current datetime on the client console, then sent an asynchronous query to the server. On the server, the datetime was printed, followed by a two-second sleep, after which the asynchronously received number was output, and the datetime was printed again. Meanwhile, after sending the asynchronous message, the client immediately printed the datetime again. As observed, the client remained unblocked (with only a negligible time difference), while the server was blocked for two seconds as expected."}),"\n",(0,t.jsx)(n.p,{children:"Asynchronous messaging is ideal when you don\u2019t need to wait for the server to finish processing the query and don\u2019t require a response. This is crucial for building high-performance and responsive applications."}),"\n",(0,t.jsx)(n.p,{children:"One important consideration with asynchronous messaging is that, since KDB/Q processes are single-threaded by default, the server processes messages in the order they are received. However, there is no guarantee that messages will arrive at the server in the same order they were sent."}),"\n",(0,t.jsx)(n.h4,{id:"flushing-important-consideration-when-sending-asynchronous-messages",children:"Flushing: Important Consideration when Sending Asynchronous Messages"}),"\n",(0,t.jsxs)(n.p,{children:["When an asynchronous query is sent, the message isn\u2019t transmitted immediately; instead, it is placed in the output queue, waiting to be sent when the KDB/Q main cycle runs next. You can inspect the output queue by calling ",(0,t.jsx)(n.code,{children:".z.W"})," on the client process, which returns a dictionary of IPC handles along with the number of bytes pending in their respective output queues."]}),"\n",(0,t.jsxs)(n.p,{children:["To ensure the asynchronous message is sent immediately, you need to flush the output queue. This can be achieved by sending a synchronous ",(0,t.jsx)(n.strong,{children:'"chaser"'})," message right after the asynchronous query, as synchronous messages automatically flush the queue and send any pending asynchronous messages."]}),"\n",(0,t.jsxs)(n.p,{children:["There are times when you may need to send a large number of asynchronous messages but want to block until all of them have been sent. This can be accomplished using an asynchronous flush, which is triggered by calling ",(0,t.jsx)(n.code,{children:"neg[h]{}"})," or ",(0,t.jsx)(n.code,{children:"neg[h](::)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If you require confirmation that the remote process has received and processed the asynchronous messages, you can send a synchronous request, such as ",(0,t.jsx)(n.code,{children:'h""'}),". Since the remote process handles messages on a socket in the order they are received, this ensures all prior asynchronous messages have been processed."]}),"\n",(0,t.jsx)(n.h3,{id:"message-handlers",children:"Message Handlers"}),"\n",(0,t.jsx)(n.p,{children:"Up to this point, we've focused primarily on how messages are sent from the client to the server, but we haven't explored much about how they are processed on the server side. In the next section, we'll dive into that."}),"\n",(0,t.jsxs)(n.p,{children:["Message handling on the server is managed through built-in handlers within the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/dotz/",children:(0,t.jsx)(n.code,{children:".z"})})," namespace, and their default behavior can be easily customized. We've already encountered a few of them: ",(0,t.jsx)(n.code,{children:".z.po"}),", ",(0,t.jsx)(n.code,{children:".z.ppw"}),", ",(0,t.jsx)(n.code,{children:".z.ps"}),", and ",(0,t.jsx)(n.code,{children:".z.pg"}),". Below, we provide a more complete list of the core message handlers. For those interested in exploring the full set, the official documentation at ",(0,t.jsx)(n.a,{href:"https://code.kx.com/home/",children:"code.kx.com"}),". provides further details."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pw"})," \u2013 Handles user validation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.po"})," \u2013 Invoked when a connection to a kdb+ session is established"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pg"})," \u2013 Triggered for a synchronous request"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.ps"})," \u2013 Triggered for an asynchronous request"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pc"})," \u2013 Called after a connection has been closed"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The default behavior of these callbacks can be restored using ",(0,t.jsx)(n.code,{children:"\\x."})]}),"\n",(0,t.jsx)(n.h4,{id:"customising-message-handlers",children:"Customising Message Handlers"}),"\n",(0,t.jsx)(n.p,{children:"Let's walk through a practical example that incorporates all of the above concepts. First, we'll create a table on the server to log all incoming requests. Then, we'll customize the core message handlers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pw"})," will validate the username and password, returning ",(0,t.jsx)(n.code,{children:"1b - true"})," for a valid match and ",(0,t.jsx)(n.code,{children:"0b - false"})," otherwise"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.po"})," will log connection events when a new session is initialized."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pg"})," and ",(0,t.jsx)(n.code,{children:".z.ps"})," will record synchronous and asynchronous messages, respectively."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pc"})," will track when a connection is closed."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This is a basic implementation, and a more advanced setup is left as an exercise for those who want to explore further."}),"\n",(0,t.jsx)(n.p,{children:"We start by creating a registry table to log all IPC events and queries occurring on the server. This table includes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["An ",(0,t.jsx)(n.code,{children:"ID"})," that increments with each message handler invocation."]}),"\n",(0,t.jsxs)(n.li,{children:["The handle of the process that sent the query, retrieved using the built-in ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/dotz/#zw-handle",children:(0,t.jsx)(n.code,{children:".z.w"})})]}),"\n",(0,t.jsx)(n.li,{children:"The event type, the query sent, and the return value."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)show registry:([id:`int$()] caller:`int$(); event:(); query:(); ret:())\nid| caller event query ret\n--| ----------------------\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Since some columns will store mixed types (for this simplified example), we initialize the table with a dummy row containing empty lists. This ensures that mixed-type columns remain flexible, as KDB/Q typically infers column types from the first inserted row, restricting future inserts to the same type (You can read more about tables in my blog post ",(0,t.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/dictionariesTables#tables",children:"here"}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)`registry upsert (0;-1;();();())\n`registry\nq)registry\nid| caller event query ret\n--| ----------------------\n0 | -1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We also create a global variable ",(0,t.jsx)(n.code,{children:"ID"})," to keep track of the number of records inserted into the ",(0,t.jsx)(n.code,{children:"registry"})," table."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)`ID set 1\n`ID\n"})}),"\n",(0,t.jsx)(n.p,{children:"Next, we define our message handlers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pw"})," performs basic username/password validation (hardcoded for illustration). If authentication fails, ",(0,t.jsx)(n.code,{children:".z.po"})," is not triggered."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q).z.pw:{ret:(x=`alex)&(y~"1234");`ID set id:ID+1;`registry upsert (id;.z.w;`hopen;`$".z.pw";ret);ret}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.po"})," logs connection events when a session is initialized."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q).z.po:{`ID set id:ID+1;`registry upsert (id;.z.w;`hopen;`hopen;1b)}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pg"})," and ",(0,t.jsx)(n.code,{children:".z.ps"})," track synchronous and asynchronous queries, respectively. The calling process is identified using ",(0,t.jsx)(n.code,{children:".z.w"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q).z.pg:{`ID set id:ID+1;`registry upsert (id;.z.w;`synchronous;x;ret:value x);ret}\nq).z.ps:{`ID set id:ID+1;`registry upsert (id;.z.w;`asynchronous;x;ret:value x)}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".z.pc"})," records when a connection is closed."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q).z.pc:{`ID set id:ID+1;`registry upsert (id;x;`hclose;`hclose;0b)}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"testing-customised-implementations",children:"Testing Customised Implementations"}),"\n",(0,t.jsxs)(n.p,{children:["If a client attempts to open a connection without credentials or with incorrect ones, an access error occurs, and ",(0,t.jsx)(n.code,{children:".z.po"})," is never called since ",(0,t.jsx)(n.code,{children:".z.pw"})," returns ",(0,t.jsx)(n.code,{children:"0b - false"}),". However, with valid credentials, ",(0,t.jsx)(n.code,{children:".z.po"})," is invoked, and the connection event is logged in the registry table."]}),"\n",(0,t.jsx)(n.p,{children:"We then test synchronous and asynchronous queries and finally close the connection. The registry table successfully logs all events, allowing us to inspect and verify the results."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Trying to open a connection without username and password"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// CLIENT\nq)h2:hopen `::6001\n'access\n  [0]  h2:hopen `::6001\n          ^\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, the client receives an access error as the return value, and the ",(0,t.jsx)(n.code,{children:"registry"})," table on the server has been updated with only one record, ogging the failed attempt to call ",(0,t.jsx)(n.code,{children:".z.pw"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// SERVER\nq)registry\nid| caller event  query  ret\n--| ------------------------\n0 | -1     ()     ()     ()\n2 | 14     `hopen `.z.pw 0b\n"})}),"\n",(0,t.jsxs)(n.p,{children:["On the other hand, when the correct username and password are provided, authentication is successful, and both ",(0,t.jsx)(n.code,{children:".z.pw"})," and ",(0,t.jsx)(n.code,{children:".z.po"})," execute as expected. This can be confirmed by checking the logs in the ",(0,t.jsx)(n.code,{children:"registry"})," table."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Using the correct username and password combination results in a successfull connection request"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// CLIENT\nq)h2:hopen `:localhost:6001:alex:1234\nq)h2\n14i\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// SERVER\nq)registry\nid| caller event  query  ret\n--| ------------------------\n0 | -1     ()     ()     ()\n2 | 14     `hopen `.z.pw 0b\n3 | 14     `hopen `.z.pw 1b\n4 | 14     `hopen `hopen 1b\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Next, we can send both a synchronous and an asynchronous query to the server, observe their behavior on both the client and server sides, inspect the ",(0,t.jsx)(n.code,{children:"registry"})," table, and finally close the connection by invoking ",(0,t.jsx)(n.code,{children:"hclose"})," on the client."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// CLIENT\n// synchronous query using a positive message handle\nq)h2 "2+2"\n4\n// asynchronous query using a negative message handle\nq)neg[h2]"myVar:100"\n// close the connection\nq)hclose h2\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// SERVER\nq)registry\nid| caller event        query  ret\n--| ------------------------------\n0 | -1     ()           ()     ()\n2 | 14     `hopen       `.z.pw 0b\n3 | 14     `hopen       `.z.pw 1b\n4 | 14     `hopen       `hopen 1b\n5 | 14     `synchronous "2+2"  4\nq)registry\nid| caller event         query       ret\n--| ------------------------------------\n0 | -1     ()            ()          ()\n2 | 14     `hopen        `.z.pw      0b\n3 | 14     `hopen        `.z.pw      1b\n4 | 14     `hopen        `hopen      1b\n5 | 14     `synchronous  "2+2"       4\n6 | 14     `asynchronous "myVar:100" ::\nq)myVar\n100\nq)registry\nid| caller event         query       ret\n--| ------------------------------------\n0 | -1     ()            ()          ()\n2 | 14     `hopen        `.z.pw      0b\n3 | 14     `hopen        `.z.pw      1b\n4 | 14     `hopen        `hopen      1b\n5 | 14     `synchronous  "2+2"       4\n6 | 14     `asynchronous "myVar:100" ::\n7 | 14     `hclose       `hclose     0b\n'})}),"\n",(0,t.jsx)(n.p,{children:"Attempting to use the connection handle after it has been closed will result in an error."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)h2 "2+2"\n\'Cannot write to handle 14. OS reports: Bad file descriptor\n  [0]  h2 "2+2"\n       ^\n'})}),"\n",(0,t.jsx)(n.p,{children:"This wraps up our basic example of customizing the default message handlers. Keep in mind that this is a highly simplified demonstration, and in a production environment, message handlers can be far more complex. Now, let's move on to the final section of this blog post, where we'll explore synchronous and asynchronous messaging within a KDB/Q tick setup."}),"\n",(0,t.jsx)(n.h3,{id:"synchronous-vs-asynchronous-communication-in-the-kdbq-tick-architecture",children:"Synchronous vs Asynchronous Communication in the KDB/Q Tick Architecture"}),"\n",(0,t.jsxs)(n.p,{children:["In this final section of the blog post, we\u2019ll explore synchronous and asynchronous communication within a typical KDB/Q Tick setup. If you need a quick refresher on a standard KDB/Q Tick architecture, you can refer to my dedicated blog post on KDB/Q architecture ",(0,t.jsx)(n.a,{href:"https://www.defconq.tech/docs/architecture/plain",children:"here"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronous messaging"})," is best suited when you need a ",(0,t.jsx)(n.strong,{children:"response"})," from the server process. It\u2019s ideal for scenarios where ",(0,t.jsx)(n.strong,{children:"time and performance are not critical"}),", but ",(0,t.jsx)(n.strong,{children:"obtaining a result"})," is essential for further execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous messaging"}),", on the other hand, is optimal when you ",(0,t.jsx)(n.strong,{children:"don\u2019t need to wait"})," for the server to complete processing and ",(0,t.jsx)(n.strong,{children:"don\u2019t require a response"}),". This is crucial for ",(0,t.jsx)(n.strong,{children:"high-performance and responsive applications"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The key takeaway is:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"synchronous messaging"})," when a response is required, and performance is not the main concern."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"asynchronous messaging"})," when performance is critical, and a response is unnecessary."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In most KDB/Q Tick architectures, performance is a top priority. As a result, IPC communication is ",(0,t.jsx)(n.strong,{children:"almost always asynchronous."})]}),"\n",(0,t.jsx)(n.p,{children:"Consider a scenario where the feed handler, responsible for publishing updates to the tickerplant, uses synchronous communication. If the feed handler were to wait for the tickerplant\u2019s response after each message, this delay would be impractical in a high-frequency, low-latency environment. The same applies to the tickerplant when publishing data to real-time subscribers (RTS) such as the real-time database (RDB). If the tickerplant had to wait for a response from every subscriber after each message, it would introduce significant delays, making it a major bottleneck. Therefore, the communication between the tickerplant and its real-time subscribers is always asynchronous."}),"\n",(0,t.jsx)(n.p,{children:"However, there are scenarios where synchronous messaging is necessary. Two key instances include:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subscription requests to the tickerplant"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When a real-time subscriber (RTS) subscribes to the tickerplant, the request is made synchronously."}),"\n",(0,t.jsxs)(n.li,{children:["Why? Because the subscriber needs to receive the table schema before it can process incoming updates. Without this schema, the RTS wouldn\u2019t know how to structure the incoming data. (For a detailed breakdown of tickerplant subscriptions, check out my ",(0,t.jsx)(n.a,{href:"https://www.defconq.tech/docs/tutorials/tick",children:"tickerplant walkthrough"}),")"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Client requests to the gateway"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In a production KDB/Q setup, clients (end users) interact with the system through a gateway, which serves as the entry point."}),"\n",(0,t.jsx)(n.li,{children:"Whenever a client requests data, it\u2019s because they intend to process, analyze, or manipulate it. Since this cannot happen before receiving the requested data, the communication must be synchronous."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"While most IPC communication in a KDB/Q Tick setup is asynchronous for performance reasons, understanding when to use synchronous messaging is key to building an efficient and reliable system."}),"\n",(0,t.jsx)(n.p,{children:"This wraps up the fundamentals of IPC in KDB/Q. In my next blog post, we\u2019ll dive into more advanced topics such as deferred sync, asynchronous callbacks, deferred responses, broadcasting, and additional practical examples. Until then, happy coding!"})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},53955:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/hopen-8ec823c82c990191b7e9233c66482751.gif"},80967:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/hopen1-25d1876f15797672a82e9e987e42864f.png"},54695:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/syncVsAsync-3ea4c8c70d86fe028e74f0d94518b9bc.gif"},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(96540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);