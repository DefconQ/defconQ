"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7197],{9598:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=n(4848),s=n(8453);const r={sidebar_position:1},o="KDB Tick Explained: A Walkthrough [PART 1]",a={id:"tutorials/tick",title:"KDB Tick Explained: A Walkthrough [PART 1]",description:"In this blog post, we're diving into the code of a simple Tickerplant. We'll break it down line by line, explaining what each part does and how it fits into the big picture. This will not only demystify Tickerplants but also shed light on important KDB/Q programming concepts. By doing so, you'll gain insights into the inner workings of a Tickerplant and acquire a deeper understanding of key concepts in the KDB/Q programming language.",source:"@site/docs/tutorials/tick.mdx",sourceDirName:"tutorials",slug:"/tutorials/tick",permalink:"/docs/tutorials/tick",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Tutorials",permalink:"/docs/category/tutorials"},next:{title:"KDB Tick Explained: A Walkthrough [PART 2]",permalink:"/docs/tutorials/tick2"}},l={},c=[{value:"The Tickerplant Core <code>tick.q</code>",id:"the-tickerplant-core-tickq",level:2},{value:"Helper Functions - <code>u.q</code>",id:"helper-functions---uq",level:2},{value:"The Real-Time Database (RDB) code - <code>r.q</code>",id:"the-real-time-database-rdb-code---rq",level:2},{value:"KDB/Q Tick demystified",id:"kdbq-tick-demystified",level:2},{value:"Global variables",id:"global-variables",level:2},{value:"Walkthrough",id:"walkthrough",level:2},{value:"The <code>sym.q</code> file",id:"the-symq-file",level:3},{value:"<code>u.q</code> Helper functions",id:"uq-helper-functions",level:2},{value:"<code>.u.init</code>",id:"uinit",level:2},{value:"<code>.u.sub</code>",id:"usub",level:2},{value:"<code>.u.del</code>",id:"udel",level:2},{value:"The drop operator <code>_</code>",id:"the-drop-operator-_",level:3},{value:"Eliding",id:"eliding",level:3},{value:"Assignment in place",id:"assignment-in-place",level:3},{value:"<code>.u.add</code>",id:"uadd",level:2},{value:"<code>.u.sel</code>",id:"usel",level:2},{value:"<code>.u.pub</code>",id:"upub",level:2},{value:"<code>.u.end</code>",id:"uend",level:2},{value:"Parse trees",id:"parse-trees",level:3},{value:"Each-left",id:"each-left",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"kdb-tick-explained-a-walkthrough-part-1",children:"KDB Tick Explained: A Walkthrough [PART 1]"}),"\n",(0,i.jsx)(t.p,{children:"In this blog post, we're diving into the code of a simple Tickerplant. We'll break it down line by line, explaining what each part does and how it fits into the big picture. This will not only demystify Tickerplants but also shed light on important KDB/Q programming concepts. By doing so, you'll gain insights into the inner workings of a Tickerplant and acquire a deeper understanding of key concepts in the KDB/Q programming language."}),"\n",(0,i.jsxs)(t.p,{children:["We'll also chat about the limitations of a basic Tickerplant, get cozy with fundamental KDB/Q operators, and explore their many flavors. To make the most of this, prior knowledge of the Tick architecture is crucial. If you need a refresher, check out my previous post ",(0,i.jsx)(t.a,{href:"https://defconq.tech/docs/architecture/plain",children:"here"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Our approach will involve a systematic breakdown. We will start with an in-depth explanation of each function, highlighting its purpose and contextual relevance. Following this, we will broaden our perspective to examine the entire code comprehensively in a line-by-line analysis of the code, delving into the specifics of input and output for each function."}),"\n",(0,i.jsxs)(t.p,{children:["You can access the KDB Tick code on the official KX GitHub page ",(0,i.jsx)(t.a,{href:"https://github.com/KxSystems/kdb-tick/tree/master",children:"here"}),". Note, this blog post is based on the code as of November 2023 and any future change need to be re-examined."]}),"\n",(0,i.jsx)(t.p,{children:"To enhance readability and minimize the need to switch between this blog and the codebase, I'm providing the code here:"}),"\n",(0,i.jsxs)(t.h2,{id:"the-tickerplant-core-tickq",children:["The Tickerplant Core ",(0,i.jsx)(t.code,{children:"tick.q"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'  1 system"l tick/",(src:first .z.x,enlist"sym"),".q"\n  2\n  3 if[not system"p";system"p 5010"]\n  4\n  5 \\l tick/u.q\n  6 \\d .u\n  7 ld:{\n  8   if[not type key L::`$(-10_string L),string x;.[L;();:;()]];i::j::-11!(-2;L);if[0<=type i;-2 (string L)," is a corrupt log. Truncate to length ",(string last i)," and restart";    exit 1];hopen L};\n  9\n 10 tick:{\n 11   init[];\n 12   if[not min(`time`sym~2#key flip value@)each t;\'`timesym];\n 13   @[;`sym;`g#]each t;\n 14   d::.z.D;\n 15   if[l::count y;L::`$":",y,"/",x,10#".";l::ld d]};\n 16\n 17 endofday:{\n 18   end d;\n 19   d+:1;\n 20   if[l;hclose l;l::0(`.u.ld;d)]};\n 21\n 22 ts:{\n 23   if[d<x;if[d<x-1;system"t 0";\'"more than one day?"];endofday[]]};\n 24\n 25 if[system"t";\n 26   .z.ts:{pub\'[t;value each t];@[`.;t;@[;`sym;`g#]0#];i::j;ts .z.D};\n 27   upd:{[t;x]\n 28   if[not -16=type first first x;if[d<"d"$a:.z.P;.z.ts[]];a:"n"$a;x:$[0>type first x;a,x;(enlist(count first x)#a),x]];\n 29   t insert x;if[l;l enlist (`upd;t;x);j+:1];}];\n 30\n 31 if[not system"t";system"t 1000";\n 32   .z.ts:{ts .z.D};\n 33   upd:{[t;x]ts"d"$a:.z.P;\n 34   if[not -16=type first first x;a:"n"$a;x:$[0>type first x;a,x;(enlist(count first x)#a),x]];\n 35   f:key flip value t;\n 36   pub[t;$[0>type first x;enlist f!x;flip f!x]];if[l;l enlist (`upd;t;x);i+:1];}];\n 37\n 38 \\d .\n 39\n 40 .u.tick[src;.z.x 1];\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"helper-functions---uq",children:["Helper Functions - ",(0,i.jsx)(t.code,{children:"u.q"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"  1 \\d .u\n  2 init:{w::t!(count t::tables`.)#()}\n  3\n  4 del:{w[x]_:w[x;;0]?y};\n  5\n  6 .z.pc:{del[;x]each t};\n  7\n  8 sel:{$[`~y;x;select from x where sym in y]}\n  9\n 10 pub:{[t;x] {[t;x;w]if[count x:sel[x]w 1;(neg first w)(`upd;t;x)]}[t;x]each w t}\n 11\n 12 add:{\n 13   $[(count w x)>i:w[x;;0]?.z.w;.[`.u.w;(x;i;1);union;y];w[x],:enlist(.z.w;y)];\n 14   (x;$[99=type v:value x;sel[v]y;@[0#v;`sym;`g#]])}\n 15\n 16 sub:{\n 17   if[x~`;:sub[;y]each t];\n 18   if[not x in t;'x];\n 19   del[x].z.w;\n 20   add[x;y]}\n 21\n 22 end:{(neg union/[w[;;0]])@\\:(`.u.end;x)}\n"})}),"\n",(0,i.jsxs)(t.h2,{id:"the-real-time-database-rdb-code---rq",children:["The Real-Time Database (RDB) code - ",(0,i.jsx)(t.code,{children:"r.q"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'  1 if[not "w"=first string .z.o;system "sleep 1"];\n  2\n  3 upd:insert;\n  4\n  5 .u.x:.z.x,(count .z.x)_(":5010";":5012");\n  6\n  7 .u.end:{\n  8   t:tables`.;\n  9   t@:where `g=attr each t@\\:`sym;\n 10   .Q.hdpf[`$":",.u.x 1;`:.;x;`sym];\n 11   @[;`sym;`g#] each t;};\n 12\n 13 .u.rep:{\n 14   (.[;();:;].)each x;\n 15   if[null first y;:()];\n 16   -11!y;\n 17   system "cd ",1_-10_string first reverse y };\n 18\n 19 .u.rep .(hopen `$":",.u.x 0)"(.u.sub[`;`];`.u `i`L)";\n'})}),"\n",(0,i.jsx)(t.p,{children:"It's remarkable to see how much you can accomplish in KDB/Q with such concise code. In a little over 80 lines, we've established the fundamental processes of a KDB/Q Tick system. Let's now have a closer look at the content of each file and the functions in it:"}),"\n",(0,i.jsx)(t.h2,{id:"kdbq-tick-demystified",children:"KDB/Q Tick demystified"}),"\n",(0,i.jsx)(t.p,{children:"Before we have a deeper look into the code in each file, let's have a look at the global variables used in a Tickerplant."}),"\n",(0,i.jsx)(t.h2,{id:"global-variables",children:"Global variables"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:" .u.w - A dictionary mapping all available tables to the handles of the real-time subscribers and the symbols they subscribe to\n .u.i - The message count in the TP log file. Note, because we can receive several records (rows) per message, this does not represent the total number of rows, but total numberof messages received\n .u.j - The total message count (TP log file plus those messages held in memory if we run the Tickerplant in batch mode)\n .u.t - All table names available in the Tickerplant\n .u.L - The Tickerplant Log filename, e.g. `:./sym2023.10.11\n .u.l - The handle to the Tickerplant Log file\n .u.d - The date for which the Tickerplant processes data\n"})}),"\n",(0,i.jsxs)(t.p,{children:["While the majority of the global variables explained above are pretty much straight forward, ",(0,i.jsx)(t.code,{children:".u.w"})," deserves a closer look:"]}),"\n",(0,i.jsxs)(t.p,{children:["If we connect to a running Tickerplant and look at ",(0,i.jsx)(t.code,{children:".u.w"})," we will observe the following"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w\nquote| 8i ` 9i `\ntrade| 8i ` 9i `\nq).u.w[`quote]\n8i `\n9i `\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We soon realise, that ",(0,i.jsx)(t.code,{children:".u.w"})," is a dictionary, mapping each table to a list of lists, where each element is a pair consisting of the handle of the real-time subscriber and the list of symbols they subscribe to. If we wanted to recreate such a dictionary we could do so using the following code:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w:`trade`quote!(((8;`);(9;`));((8;`);(9;`)))\nq).u.w\ntrade| 8 ` 9 `\nquote| 8 ` 9 `\nq).u.w[`trade]\n8 `\n9 `\nq)0N!.u.w[`trade]\t// Note: 0N! is a very helpful tool to output data to the console. This comes especially handy when debugging code.\n((8;`);(9;`))\n8 `\n9 `\n"})}),"\n",(0,i.jsx)(t.p,{children:"It's crucial to grasp the structure of this dictionary, as it proves beneficial when accessing information about the real-time subscribers."}),"\n",(0,i.jsx)(t.h2,{id:"walkthrough",children:"Walkthrough"}),"\n",(0,i.jsx)(t.p,{children:"Let's now start with our walkthrough and look at the code."}),"\n",(0,i.jsx)(t.p,{children:"We start the Tickerplant by running the below command in our terminal passing the following parameters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"tick.q"})," - the KDB/Q file containing the Tickerplant functions and logic"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"SOURCE"})," - the name of the file with the table defintions which is also used as directory name for where we want to store the data and the initial part of the Tickerplant Log file name"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"DESTINATION"})," [optional] - the location of where we want to store our data"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"-p PORT"})})," [optional] - the port on which we want the Tickerplant to run on"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// q tick.q SOURCE DESTINATION[optional] -p 5010[optional]\n// Example: \nAlexander@Alexanders-MBP:~/Desktop/kdb/tick\n\u21d2q tick.q sym  .  -p 5010\t\n"})}),"\n",(0,i.jsxs)(t.h3,{id:"the-symq-file",children:["The ",(0,i.jsx)(t.code,{children:"sym.q"})," file"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"tick.q"})," starts by loading the ",(0,i.jsx)(t.code,{children:"sym.q"})," file into memory. The ",(0,i.jsx)(t.code,{children:"sym.q"})," file contains all the table definitions of the tables we want to capture and is a prerequisite for the Tickerplant. A simple example can be found below:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"  1 // sym.q\n  2 // quote table schema\n  3 quote:([]time:`timespan$();sym:`g#`symbol$();bid:`float$();ask:`float$();bsize:`int$();asize:`int$());\n  4 // trade table schema\n  5 trade:([]time:`timespan$();sym:`g#`symbol$();price:`float$();size:`int$());\n"})}),"\n",(0,i.jsx)(t.p,{children:"Below code loads our schemas:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'system "l tick/",(src:first .z.x,enlist"sym"),".q"\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".z.x"})," contains the parameters we passed to the KDB/Q process. In case there were no parameters passed, we append the string ",(0,i.jsx)(t.code,{children:'"sym"'})," to the list and then select the first element of this list. Note: we have to enlist our string ",(0,i.jsx)(t.code,{children:'"sym"'})," otherwise it would be concatenated character by character to the existing list. The below code should illustrate this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q).z.x\n"sym"\n,"."\nq).z.x,"sym"\n"sym"\n,"."\n"s"\n"y"\n"m"\nq)first .z.x,enlist "sym"\n"sym"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["As a next step we will append ",(0,i.jsx)(t.code,{children:'".q"'})," the file extenstion to the sym file and prepend the rest of the path to the location of the sym file. We then use the ",(0,i.jsx)(t.code,{children:'system "l"'})," command to load the content of the ",(0,i.jsx)(t.code,{children:"sym.q"})," file. This will load all table definitions into memory."]}),"\n",(0,i.jsxs)(t.p,{children:["Next we check if the port of the Tickerplant has been set on startup with the ",(0,i.jsx)(t.code,{children:"-p"})," flag and if not we set it to ",(0,i.jsx)(t.code,{children:"5010"}),". All our KDB/Q processes need to run on a specific port in order for other services to connect to them. We do so by using an ",(0,i.jsx)(t.code,{children:"if"})," statement and the ",(0,i.jsx)(t.code,{children:"system"})," command:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if[not system"p";system"p 5010"]\n'})}),"\n",(0,i.jsxs)(t.p,{children:["We then load the code stored in the ",(0,i.jsx)(t.code,{children:"u.q"})," file which loads all the ",(0,i.jsx)(t.code,{children:".u"})," helper functions used in the Tickerplant"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"\\l tick/u.q\n"})}),"\n",(0,i.jsxs)(t.h2,{id:"uq-helper-functions",children:[(0,i.jsx)(t.code,{children:"u.q"})," Helper functions"]}),"\n",(0,i.jsxs)(t.p,{children:["The first line within ",(0,i.jsx)(t.code,{children:"u.q"})," changes the default namespace into a ",(0,i.jsx)(t.code,{children:".u"})," namespace. In order to avoid name clashes of varibales or functions within the same processs, KDB/Q introduces the concept of namespaces. If you are not familiar with namespaces, you can read about this concept in ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/12_Workspace_Organization/#121-namespaces",children:"Chapter 12"}),' of "Q for Mortals".']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"\\d .u\t\t// Change the namespace from default to .u\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For simplicity and readability, we will include the full, compound name (including namespace and context) of each function when describing them. I will describe the functions in a logical order, which will help you to comprehend the flow of the code. This order may slightly deviate from the order of the function definitions in ",(0,i.jsx)(t.code,{children:"u.q"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"uinit",children:(0,i.jsx)(t.code,{children:".u.init"})}),"\n",(0,i.jsxs)(t.p,{children:["Even though ",(0,i.jsx)(t.code,{children:".u.init"})," only consists of one line of code, it performs two very important tasks:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["it defines the list of tables ",(0,i.jsx)(t.code,{children:".u.t"})," a real-time subscribers can subscribe to"]}),"\n",(0,i.jsxs)(t.li,{children:["it creates a dictionary ",(0,i.jsx)(t.code,{children:".u.w"})," to keep track of the handles of all real-time subscribers and the tables and symbols they subscribe to. It does so by mapping each table name to a list of pairs consisting of the handle of the real-time subscriber and the corresponding symbols they susbcribe to. An example of a symbol would be the ticker symbol of an equity."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.init"})," is called inside the ",(0,i.jsx)(t.code,{children:".u.tick"})," function, the entry function of the Tickerplant, which is the first function called when the Tickerplant comes up."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @ param:\t\t \tNone\n// @ return:\t\tNone\n.u.init:{[]\n        .u.w::.u.t!(count .u.t::tables `.)#()\n        };\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As we already know, KDB/Q is read ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/4_Operators/#412-left-of-right-evaluation",children:"left-of-right"})," (or read from the right-to-left) which means we have to start at the end of the line. ",(0,i.jsx)(t.code,{children:"(count .u.t::tables `.)#()"})," creates a list of empty lists of length ",(0,i.jsx)(t.code,{children:"count tables `."}),". We first retrieve the names of all tables defined in the Tickerplant (the ones we defined in the ",(0,i.jsx)(t.code,{children:"sym.q"})," file and loaded at the beginning) and assign this list to the global variable ",(0,i.jsx)(t.code,{children:".u.t"})," using the ",(0,i.jsx)(t.code,{children:"::"})," operator. If you're within a function and want to assign a variable as global variable, which will exist beyond the scope of the current function, you can do so by using the ",(0,i.jsx)(t.code,{children:"::"})," operators. We use ",(0,i.jsx)(t.code,{children:"count"})," to identify how many tables exist and create a list of empty lists of exactly that length using the take ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/take/",children:(0,i.jsx)(t.code,{children:"#"})})," operator. Next we map this list of empty lists to the table names we stored in ",(0,i.jsx)(t.code,{children:".u.t"})," creating a dictionary and finally we assign this dictionary to ",(0,i.jsx)(t.code,{children:".u.w"})," using a global variable assignment. As explained previously, ",(0,i.jsx)(t.code,{children:".u.w"})," keeps track of the handles of all real-time subscribers and the tables and symbols they subscribe to."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["You can also use ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/get/#set",children:(0,i.jsx)(t.code,{children:"set"})})," to assign global variables and ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/get/#get",children:(0,i.jsx)(t.code,{children:"get"})})," to access them."]})}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsx)(t.p,{children:"If you are following along this blog post, break the code down into each individual command. For example, you can split up above code into the following pieces:"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)tables `.\n`s#`quote`trade\nq)count .u.t:tables `.\n2\nq)0N!(count .u.t:tables `.)#()\t\t// Note: 0N! is a helpful tool to output variables to the console, especially during debugging. The empty list () wouldn't be printed otherwise\n(();())\n\n\nq)0N!.u.t!(count .u.t::tables `.)#()\n`s#`quote`trade!(();())\nquote|\ntrade|\nq).u.w::.u.t!(count .u.t::tables `.)#()\nq).u.t\n`s#`quote`trade\nq)0N!.u.w\n`s#`quote`trade!(();())\nquote|\ntrade|\n"})}),(0,i.jsxs)(t.p,{children:["Observe each output in your console and inspect the content of ",(0,i.jsx)(t.code,{children:".u.t"})," and ",(0,i.jsx)(t.code,{children:".u.w"})," when you are done!"]})]}),"\n",(0,i.jsx)(t.h2,{id:"usub",children:(0,i.jsx)(t.code,{children:".u.sub"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.sub"})," is the function utilized by real-time subscribers (e.g. Real-time Database) to subscribe to particular tables and symbols published by the Tickerplant. This function has the capability to add a subscription to a specific table when the corresponding table name is passed as a parameter. Alternatively, if an empty symbol is passed, it subscribes to all tables. It first ensures that the specified table is among the subscribable tables, then clears all existing subscriptions for the caller by invoking ",(0,i.jsx)(t.code,{children:".u.del"}),", and finally adds the new subscription using ",(0,i.jsx)(t.code,{children:".u.add"}),". This sequence helps prevent duplicate subscriptions. In the context of ",(0,i.jsx)(t.code,{children:".u.add"}),", the schemas of all tables are retrieved, which are then used to initialize the tables on the real-time subscriber."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Examples: 1. Subscribe to all tables and all symbols .u.sub[`;`]\n//           2. Subscribe to specific tables and symbols .u.sub[`trade`quote;`AAPL`GOOG]\n\n// @param: \tx (symbol) \t- the table name to subscribe to, empty symbol ` for all tables\n// @param: \ty (symbolList) \t- list of symbols to subscribe to, empty symbol ` for all symbols\n// @return:\tA list of lists (to be more specific a list of pairs) is returned. Because .u.add returns a pair consisting of (`tableName;schema) and we invoke .u.add\n//\t\tfor every table, `.u.sub` returns a list of list (pairs) containing the name of each table and the corresponding schema.\n//\t\t((table1;schema1);(table2;schema2); ... ; (tableN;schemaN))\t\n.u.sub:{[x;y]\n        if[x~`;:.u.sub[;y] each .u.t];\n        if[not x in .u.t;'x];\n        .u.del[x].z.w;\n        .u.add[x;y]\n        };\n\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We first check if the real-time subscriber wants to subscribe to all tables (empty symbol) and if so, we call ",(0,i.jsx)(t.code,{children:".u.sub"})," recursively for the symbols ",(0,i.jsx)(t.code,{children:"y"})," they want to subscribe to. This will be invoked for all tables defined in ",(0,i.jsx)(t.code,{children:".u.t"}),". We do so by creating a projection on ",(0,i.jsx)(t.code,{children:".u.sub"})," and looping over every table name stored in ",(0,i.jsx)(t.code,{children:".u.t"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"if[x~`;:.u.sub[;y] each .u.t];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If the table the real-time subscriber wants to subscribe to is not in the list of subscribable tables we throw an error (",(0,i.jsx)(t.code,{children:"'"})," is used to throw errors)"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"if[not x in .u.t;'x];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Next we call ",(0,i.jsx)(t.code,{children:".u.del"})," for the table ",(0,i.jsx)(t.code,{children:"x"})," and the real time subscriber who called ",(0,i.jsx)(t.code,{children:".u.sub"}),". ",(0,i.jsx)(t.code,{children:".z.w"})," is the connection handle of the process which invoked the function, in this case the real-time subscriber. ",(0,i.jsx)(t.code,{children:".u.del"})," is a dyadic function which will remove all subscriptions for table",(0,i.jsx)(t.code,{children:" x"})," and subscriber ",(0,i.jsx)(t.code,{children:".z.w"})," if there exists one already."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".u.del[x].z.w;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Lastly we add a new subscription for table ",(0,i.jsx)(t.code,{children:"x"})," and symbols ",(0,i.jsx)(t.code,{children:"y"}),". This will add the details of the real time subscriber to ",(0,i.jsx)(t.code,{children:".u.w"})," the dictionary containing all details about real time subscribers and which tables they subscribe to."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".u.add[x;y]\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"danger",children:(0,i.jsxs)(t.p,{children:["It is crucial that we omit the last semicolon after ",(0,i.jsx)(t.code,{children:".u.add[x;y]"}),". The semicolon suppresses the result of a function from being returned. In the case of ",(0,i.jsx)(t.code,{children:".u.add"}),", the result is a list of table names and their corresponding schemas. This information is used by the real-time subscriber to initialize the tables. Suppressing this result would be counterproductive as the real-time subscriber can't initialise the tables they receive updates for."]})}),"\n",(0,i.jsx)(t.h2,{id:"udel",children:(0,i.jsx)(t.code,{children:".u.del"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.del"})," will remove an existing subscription for a specific real-time subscriber and the corresponding table within ",(0,i.jsx)(t.code,{children:".u.w"}),", the dictionary storing all information about real time subscribers. This is done to avoid duplicate subscriptions. ",(0,i.jsx)(t.code,{children:".u.del"})," is called within ",(0,i.jsx)(t.code,{children:".u.sub"}),", the function a real-time subscriber would call to subscribe to the Tickerplant"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @param:\tx (symbol) - the name of the table for which we need to remove the subscriber \n// @param:\ty (int)\t   - the handle of the subscriber\n// @return:\tNone\n.u.del:{[x;y]\n        .u.w[x]_:.u.w[x;;0]?y;\n        };\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As evident, the ",(0,i.jsx)(t.code,{children:".u.del"})," function appears to consist of just a single line of code, but there's more complexity beneath the surface. Let's take a brief detour to delve into the drop operator ",(0,i.jsx)(t.code,{children:"_"}),", the concept of eliding, and in-place assignment:"]}),"\n",(0,i.jsxs)(t.h3,{id:"the-drop-operator-_",children:["The drop operator ",(0,i.jsx)(t.code,{children:"_"})]}),"\n",(0,i.jsxs)(t.p,{children:["According to the official documentation ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/drop/",children:"here"}),", the drop operator ",(0,i.jsx)(t.code,{children:"_"}),":",(0,i.jsx)(t.em,{children:'"Drop items from a list, entries from a dictionary or columns from a table"'}),". Like many other KDB/Q operators, the drop operator has multiple overloads depending on the input parameters. While a comprehensive explanation of all these overloads is beyond the scope of this blog post, I recommend exploring the various use cases of the drop operator as they can be quite useful. Let's examine a specific use case: removing the i-th element from a list, which is precisely what we observe in ",(0,i.jsx)(t.code,{children:".u.del"}),":"]}),"\n",(0,i.jsx)(t.p,{children:"Given a list of N elements, the below code will drop the ith element from the list"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)1 2 3 _ 1\n1 3\n"})}),"\n",(0,i.jsx)(t.p,{children:"As you can see, he drop operator eliminated the element at index 1 from the list 1 2 3 and returned the updated list. Be sure to review the remaining use cases and grasp their functionalities."}),"\n",(0,i.jsx)(t.h3,{id:"eliding",children:"Eliding"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/3_Lists/#310-elided-indices",children:"Eliding"}),' is the concept of providing only a "partial" index when accessing data structures at depth. Let\'s illustrate this important concept with an example. Consider the 4 by 4 matrix m:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)m:(1 2 3 4;10 20 30 40;100 200 300 400;1000 2000 3000 4000)\nq)m\n1    2    3    4\n10   20   30   40\n100  200  300  400\n1000 2000 3000 4000\n"})}),"\n",(0,i.jsx)(t.p,{children:"If we want to access all elements of the first row we could use the following"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)m[0;0 1 2 3]\n1 2 3 4\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"In KDB/Q indexing starts at index 0"})}),"\n",(0,i.jsx)(t.p,{children:"Nonetheless, this approach can be cumbersome and inefficient, especially when dealing with larger matrices that have numerous columns. For instance, if we have a matrix with 100 columns, would we need to write out all 100 indexes? This is where eliding becomes useful. We can achieve the same outcome by simply omitting the second index."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)m[0;]                 \n1 2 3 4\n// Note: m[0] obtains the same result but for readability it's better to add the ; making it clear that we are eliding the second index\nq)m[0]\n1 2 3 4\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As described in ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/3_Lists/#310-elided-indices",children:"Q for Mortals"}),": ",(0,i.jsx)(t.em,{children:'"This indeed works because eliding an index in any slot is equivalent to specifying all legitimate indices for that slot."'})]}),"\n",(0,i.jsx)(t.p,{children:"Note, that if we wish to access only the second column of our matrix, we can do so using the following method:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)m[;1]\n2 20 200 2000\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Eliding is a versatile technique and extends to more than two dimensions. Let's examine its use in the context of ",(0,i.jsx)(t.code,{children:".u.w"}),", which is utilized in our Tickerplant. This dictionary stores the handles of subscribers, tables they are subscribed to, and the symbols they have subscribed to."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w:`trade`quote!(((8;`);(9;`));((8;`);(9;`)))\nq).u.w\ntrade| 8 ` 9 `\nquote| 8 ` 9 `\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Suppose we have two real-time subscribers with handles 8 and 9, both subscribing to the tables ",(0,i.jsx)(t.code,{children:"trade"})," and ",(0,i.jsx)(t.code,{children:"quote"})," and all symbols. The dictionary ",(0,i.jsx)(t.code,{children:".u.w"})," represents this mapping. Now, let's say you want to retrieve the list of pairs that represent all subscriber handles and the symbols they subscribe to for the ",(0,i.jsx)(t.code,{children:"trade"})," table. How can you achieve this? Well, you can simply elide into the dictionary ",(0,i.jsx)(t.code,{children:".u.w"})," with ",(0,i.jsx)(t.code,{children:".u.w[`trade]"}),", resulting in the following output:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w[`trade]\n8 `\n9 `\nq)0N!.u.w[`trade]      \n((8;`);(9;`))\n8 `\n9 `\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now, suppose we want only the first element from all pairs. How can we accomplish this? Given the list ",(0,i.jsx)(t.code,{children:"((8;`);(9;`))"}),", which represents our intermediate result, we can simply elide the first index and use 0 as the second index. Eliding the first index is equivalent to selecting all elements at the first level."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)((8;`);(9;`))[;0]\n8 9\nq)((8;`);(9;`))[0 1;0]\t\t// Eliding the first index is equivalent to selecting all elements at depth level 1\n8 9\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Combining this knowledge, we can now retrieve the handles of all real-time subscribers that subscribe to table ",(0,i.jsx)(t.code,{children:"trade"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w[`trade;;0]\n8 9\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Eliding is an important and powerful concept, make sure you fully understand it and how to use it. You can find more details about it ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/3_Lists/#310-elided-indices",children:"here"})]}),"\n",(0,i.jsx)(t.h3,{id:"assignment-in-place",children:"Assignment in place"}),"\n",(0,i.jsxs)(t.p,{children:["If you are transitioning from another programming language such as Java or C++, you might be familiar with the concept of assignment in place. Assignment in place, or ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/4_Operators/#46-amend",children:"amend"})," how it's referenced in KDB/Q, is essentially a way to achieve the same result with less code, providing a more concise syntax."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)a:0\nq)a+:1\nq)a\n1\nq)a:0\nq)a:a+1\nq)a\n1\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now we can return to our Tickerplant code and examine the ",(0,i.jsx)(t.code,{children:".u.del"})," function in detail"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".u.del:{[x;y]\n        .u.w[x]_:.u.w[x;;0]?y\n        };\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We start again reading from the right and can see that our first operation involves find ",(0,i.jsx)(t.code,{children:"?"}),". If you remember, ",(0,i.jsx)(t.code,{children:"y"})," is the handle of the subscriber we are trying to remove from the dictionary and thus the operation ",(0,i.jsx)(t.code,{children:"expression?y"})," is searching for the handle of the subscriber in the list on the left of the ",(0,i.jsx)(t.code,{children:"?"})," operator. From the previous section, we know that"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w[`tablename;;0]\nq).u.w[`trade;;0]\n8 9\n"})}),"\n",(0,i.jsxs)(t.p,{children:["will return all the handles of the real-time subscribers that subscribe to that particular table. In the above case, we retrieve all the handles of the subscribers of the ",(0,i.jsx)(t.code,{children:"trade"})," table."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["Even though find ",(0,i.jsx)(t.code,{children:"?"})," only returns the index of the first element found, we don't have to worry about this as there should be no duplication in the list of handles. If you need to search a list of non-unique elements be aware that find will only return the index of the first element."]})}),"\n",(0,i.jsxs)(t.p,{children:["Once we found the index of the handle of the real-time subscriber we want to remove from the dictionary, we use drop ",(0,i.jsx)(t.code,{children:"_"})," to remove the element and re-assign the modified list to the key that matches table ",(0,i.jsx)(t.code,{children:"x"})," in place. The entry for table ",(0,i.jsx)(t.code,{children:"x"})," is thus updated and the real time subscriber has been removedi."]}),"\n",(0,i.jsx)(t.p,{children:"Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w:`trade`quote!(((8;`);(9;`));((8;`);(9;`)))\nq).u.w\ntrade| 8 ` 9 `\nquote| 8 ` 9 `\nq).u.w[`trade] _ .u.w[`trade;;0]?9\t// Removing handle 9 for table trade from the dictionary\n8 `\n"})}),"\n",(0,i.jsx)(t.h2,{id:"uadd",children:(0,i.jsx)(t.code,{children:".u.add"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.add"})," is the second function invoked by ",(0,i.jsx)(t.code,{children:".u.sub"}),". This function adds a new subscription for a real time subscriber by adding the handle of the subscriber and the table it subscribes to, to the dictionary ",(0,i.jsx)(t.code,{children:".u.w"}),". It then returns the empty schema of the table that has been subscribed to."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @param:\tx (symbol)\t \t- the name of the table we want to subscribe to\n// @param:\ty (symbolList)\t- List of symbols we want to subscribe to. Empty symbol ` for all symbols\n// @return:\tList (pair)\t\t- List containing the table name for which we added the subscription and the corresponding schema  \n.u.add:{[x;y]\n        $[(count .u.w[x])>i:.u.w[x;;0]?.z.w;\n                .[`.u.w;(x;i;1);union;y];\n                .u.w[x],:enlist(.z.w;y)];\n        (x;$[99=type v:value x;.u.sel[v]y;@[0#v;`sym;`g#]])\n        };\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is the lengthiest function we've encountered thus far, and it's the most extensive function in the ",(0,i.jsx)(t.code,{children:"u.q"})," file. However, by dissecting each line into its constituent steps, we can gain a clear understanding of its operation."]}),"\n",(0,i.jsxs)(t.p,{children:["We are already familiar with the first part of the code ",(0,i.jsx)(t.code,{children:".u.w[x;;0]?.z.w"})," as this is similar to what we have seen in ",(0,i.jsx)(t.code,{children:".u.del"}),". We retrieve the index of the real-time subscriber that invoked the function for a particular table ",(0,i.jsx)(t.code,{children:"x"}),". Remember, ",(0,i.jsx)(t.code,{children:".z.w"})," is the connection handle of the process which called the function. We then store this index in variable ",(0,i.jsx)(t.code,{children:"i"})," as we will use it later in the function."]}),"\n",(0,i.jsxs)(t.p,{children:["Before we continue, let's pause for a moment and observe what the find ",(0,i.jsx)(t.code,{children:"?"})," operator returns when we are searching for an element that isn't present in the list we searching in."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)1 2 3?2       // If the element we search for, is in the list, find will return its index\n1\n// However, if the element we're searching for isn't within the list, the find operator will return \n// count[list]+1, indicating the index at which the element would be appended\nq)1 2 3?4       \n3\n"})}),"\n",(0,i.jsx)(t.p,{children:"Knowing this, we can establish two cases we check for:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Case 1"}),": ",(0,i.jsx)(t.code,{children:"(count .u.w[x])>i"})," the length of the list of pairs for table ",(0,i.jsx)(t.code,{children:"x"})," (established with ",(0,i.jsx)(t.code,{children:"count .u.w[x]"}),"), is larger than the index ",(0,i.jsx)(t.code,{children:"i"})," returned by find. This means the handle of the real-time subscriber has been found within the list of pairs and is therefore already present"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Case 2"}),": ",(0,i.jsx)(t.code,{children:"(count .u.w[x])>i"})," the length of the list of pairs for table ",(0,i.jsx)(t.code,{children:"x"})," is smaller than the index ",(0,i.jsx)(t.code,{children:"i"}),". This means that the handle isn't present yet"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We can now use the conditional operator ",(0,i.jsx)(t.code,{children:"$"})," (similar to an if-else statement) to action on these two cases:"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Case 1"}),": If the handle of the subscriber is already there. We use amend to add the new symbols ",(0,i.jsx)(t.code,{children:"y"})," we want to subscribe for table ",(0,i.jsx)(t.code,{children:"x"}),", to the already existing ones. ",(0,i.jsx)(t.strong,{children:"Note"}),": Because ",(0,i.jsx)(t.code,{children:".u.w"})," is not a simple dictionary but its values are list of lists, we need to use the ",(0,i.jsx)(t.code,{children:"."})," version of amend using nested indexes. ",(0,i.jsx)(t.strong,{children:"Remember"}),": the list of pairs consists of (handle;symbols) elements, thus the symbols are at index 1, while handles are at index 0."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Using the nested index `(x;i;1)` we retrieve the symbols this particular subscriber is interested \n// in and create the union with the new symbols that we need to add. `i` contains the index of the \n// subscriber in the list of pairs for the table `x`\n.[`.u.w;(x;i;1);union;y]\t\t\n"})}),"\n",(0,i.jsx)(t.p,{children:"Let's illustrate above with an example."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Recreate .u.w\nq).u.w:`trade`quote!(((8;`GOOG`APPL);(9;`MSFT`GS));((10;`IBM`TSLA);(11;`C`NVDA)))\t\nq).u.w\ntrade| 8 `GOOG`APPL 9 `MSFT`GS\nquote| 10 `IBM`TSLA 11 `C`NVDA\n// Assume we are interested in subscriber at index 1 for table `trade. This retrieves all \n// symbols they currently subscribe to\nq).u.w[`trade;1;1]\n`MSFT`GS\n// Append two new symbols to the symbols already subscribed to.\nq).[`.u.w;(`trade;1;1);union;`GOOG`APPL]\t\t\nq).u.w\ntrade| 8 `GOOG`APPL         9 `MSFT`GS`GOOG`APPL\nquote| 10 `IBM`TSLA         11 `C`NVDA\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Case 2"}),": The subscriber is not yet present in ",(0,i.jsx)(t.code,{children:".u.w"}),". In this case we simply have to add the new entry to the enties already present for table ",(0,i.jsx)(t.code,{children:"x"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// We are using `enlist` to create a singleton list of a pair containing the handle of the subscriber \n// .z.w and the symbols they want to subscribe to and add it to the already existing list for table x \n.u.w[x],:enlist (.z.w;y)\n"})}),"\n",(0,i.jsx)(t.p,{children:"The last remaining step is to return a pair consisting of the table name x and an empty schema."}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsx)(t.p,{children:"Nevertheless, there is one section of the code that remains somewhat unclear to me. In the conditional evaluation, we verify whether the table is a keyed table. However, the tables in the Tickerplant are normal tables and not keyed. I haven't encountered a production system where the Tickerplant stores keyed tables."})}),"\n",(0,i.jsxs)(t.p,{children:["Below code creates a tuple/pair consisting of ",(0,i.jsx)(t.code,{children:"x"})," the table name and an expression that will evaluate to the schema of the corresponding table. Let's have a look at it:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"(x;$[99=type v:value x;.u.sel[v]y;@[0#v;`sym;`g#]])\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The first part of the tuple is straightforward, it's simply the table name. The second part is a conditional evaluation. Because ",(0,i.jsx)(t.code,{children:"x"})," only contains the symbol name of the table, we first have to apply ",(0,i.jsx)(t.code,{children:"value"})," to it in order to retrieve the actual content of the table. We then check if the type of this data is 99, which corresponds to a keyed table. I have never seen a Tickerplant that processes keyed tables, so this evaluation should be always false. However, in case this evaluates to true, we apply the ",(0,i.jsx)(t.code,{children:".u.sel"})," function to the data we stored in ",(0,i.jsx)(t.code,{children:"v"})," for the symbols ",(0,i.jsx)(t.code,{children:"y"})," and return the result.\nFor the case the table isn't keyed (this should be always the case) we return the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"@[0#v;`sym;`g#]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We first take 0 rows from the data stored in ",(0,i.jsx)(t.code,{children:"v"})," using ",(0,i.jsx)(t.code,{children:"0#v"}),". This basically creates an empty table. We then use this construct in combination with the apply at ",(0,i.jsx)(t.code,{children:"@"})," operator to apply the grouped attribute ",(0,i.jsx)(t.code,{children:"g"})," to the ",(0,i.jsx)(t.code,{children:"sym"})," column. If you are not familiar with with the behaviour of ",(0,i.jsx)(t.strong,{children:"Apply At"})," you can have a read ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/apply/#apply-at-index-at",children:"here"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"usel",children:(0,i.jsx)(t.code,{children:".u.sel"})}),"\n",(0,i.jsxs)(t.p,{children:["This function is responsible for extracting a specific set of rows from a table using a list of symbols. It is used within both ",(0,i.jsx)(t.code,{children:".u.add"})," and ",(0,i.jsx)(t.code,{children:".u.pub"})," to fetch the subset of rows corresponding to the symbols that a real-time subscriber is interested in."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @param:\t\tx (table)\t\t- the data we want to select from\n// @param:\t\ty (symbolList)\t- the list of symbols we are interested in\n// @return: \tA table containing the relevant data\n.u.sel:{[x;y]\n        $[`~y;x;select from x where sym in y]\n        };\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This function is another one-liner and is relatively straight forward. We first distinguish whether the real-time subscriber is interested in all symbols, passing the empty symbol ",(0,i.jsx)(t.code,{children:"`"})," to the function, or in a specific list of symbols. In the former case, the function returns the complete data stored in parameter ",(0,i.jsx)(t.code,{children:"x"}),". In the latter case, where the subscriber is only interested in a specific subset of symbols, the function uses q-sql to retrieve the relevant data and returns it."]}),"\n",(0,i.jsx)(t.h2,{id:"upub",children:(0,i.jsx)(t.code,{children:".u.pub"})}),"\n",(0,i.jsxs)(t.p,{children:["This function publishes all relevant data to the interested real-time subscribers and is used within ",(0,i.jsx)(t.code,{children:".z.ts"}),", if the Tickerplant runs in batch mode on a timer, or within ",(0,i.jsx)(t.code,{children:".u.upd"})," if the Tickerplant publishes every incoming row straight away."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @param:\tx (symbol)\t- the table name\n// @param:\ty (table)\t- the corresponding data stored in table x at the time of publishing\n// @return:\tNone\n.u.pub:{[t;x]\n        {[t;x;w] if[count x:.u.sel[x] w 1;(neg first w)(`upd;t;x)]}[t;x] each .u.w[t]\n        };\n"})}),"\n",(0,i.jsxs)(t.p,{children:["While ",(0,i.jsx)(t.code,{children:".u.pub"})," is a concise function, it involves multiple steps. It starts by creating a projection of a three-parameter anonymous function. This effectively fixes the parameters ",(0,i.jsx)(t.code,{children:"t"})," and ",(0,i.jsx)(t.code,{children:"x"}),", which denote the table name and the actual data."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Create a projecton of a triadic function fixing the first two parameters.\n{[t;x;w] ... }[t;x]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We proceed by iterating through each pair, which consists of the subscriber handle and the list of symbols they are interested in for the table ",(0,i.jsx)(t.code,{children:"t"})," we aim to publish data for, involing the anonymous function."]}),"\n",(0,i.jsxs)(t.p,{children:["Inside the lambda function, we initially confirm the data's relevance to the subscriber by fetching the symbols of interest for that subscriber (stored in ",(0,i.jsx)(t.code,{children:"w 1"}),"). We then combine this list of symbols with the data and pass it to ",(0,i.jsx)(t.code,{children:".u.sel"}),", which will provide us with the relevant data. If there is any data available for publishing, we do so asynchronously to the real-time subscriber."]}),"\n",(0,i.jsxs)(t.p,{children:["We send an asynchronous message by utilizing the negative handle of the real-time subscriber. The data is sent in the form of a parse tree where the first element of the parse tree represents the function to be called on the real-time subscriber, and the subsequent elements are the parameters passed to that function. In our context, we invoke the ",(0,i.jsx)(t.code,{children:"update"})," function ",(0,i.jsx)(t.code,{children:"upd"})," on the subscriber, with ",(0,i.jsx)(t.code,{children:"t"})," as the table name and ",(0,i.jsx)(t.code,{children:"x"})," as the data to be inserted. It is important to note that the ",(0,i.jsx)(t.code,{children:"upd"})," function must be defined on the real-time subscriber; otherwise, an error will be thrown on the real-time subscriber."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Send the data asynchronously to the real time subscriber\n(neg first x)(`upd;t;x)\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:"Communication between the Tickerplant and the real-time subscriber should always be asynchronous when publishing data. Not only do we not need a response from the real-time subscriber (we don't really care whether the real-time subscriber received the message or not) but we avoid waiting for a response from the real-time subscriber to prevent potential delays and the risk of the Tickerplant crashing, which can occur with synchronous messaging"})}),"\n",(0,i.jsx)(t.h2,{id:"uend",children:(0,i.jsx)(t.code,{children:".u.end"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.end"})," sends an asynchronous message to all real time subscribers invoking their ",(0,i.jsx)(t.code,{children:".u.end"})," function at the end of the day. It is triggered within the ",(0,i.jsx)(t.code,{children:".u.endofday"})," function of the Tickerplant."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @param:\tx (date) - the date of the day that just ended, basically yesterday's date\n// @return:\tNone\n.u.end:{ (neg union/[w[;;0]])@\\:(`.u.end;x) }\n"})}),"\n",(0,i.jsx)(t.p,{children:"This concise function, although just a single line, covers various significant KDB/Q concepts, including iterators, eliding, asynchronous IPC, and parse trees."}),"\n",(0,i.jsx)(t.h3,{id:"parse-trees",children:"Parse trees"}),"\n",(0,i.jsxs)(t.p,{children:["Starting from the right, we first encounter a parse tree. The expression ",(0,i.jsx)(t.code,{children:"(`.u.end;x)"})," represents a parse tree that, upon evaluation, will trigger the ",(0,i.jsx)(t.code,{children:".u.end"})," function with the parameter ",(0,i.jsx)(t.code,{children:"x"}),". If you are not familiar with parse trees, I encourage you to read this very informative ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/wp/parse-trees/",children:"whitepaper"}),". In simple terms, a parse tree is a list containing a function, which could be in the form of an anonymous lambda function or the name of a function if it's defined within the process. It is followed by a list of parameters that serve as arguments for the function. A straightforward example would be:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)value (+;2;2)\n4\nq)value ({x*y};2;2)\n4\n"})}),"\n",(0,i.jsx)(t.h3,{id:"each-left",children:"Each-left"}),"\n",(0,i.jsxs)(t.p,{children:["The function then employs an each-left operation in conjunction with apply to execute the given parse tree on each element of the left expression. Each-left is one of the eight Iterators, which were previously referred to as Averbs. You can find a more in-depth explanation of iterators ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/basics/iteration/",children:"here"}),". Let me illustrate how each-left functions with the following example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q)"ABC",\\:"XY"\t\t// We apply the whole list of characters "XY" to each element on the left\n"AXY"\n"BXY"\n"CXY"\n// In comparison, each-right, applies the whole list of characters "ABC" to each element on the right\nq)"ABC",/:"XY"\n"ABCX"\n"ABCY"\n'})}),"\n",(0,i.jsx)(t.p,{children:"Let's now have a look at the expression on the left:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"(neg union/[w[;;0]])\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We come across another iterator in the code. First, we extract all the handles of real-time subscribers by using elide operations on the dictionary containing subscriber information. By omitting the first index, we access all the details for all tables initially. Then, by excluding the second index, we obtain all pairs in the form of ",(0,i.jsx)(t.code,{children:"(handle; symbolList)"}),", and finally, by accessing elements at index 0, we effectively retrieve all the handles."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.w:`trade`quote!(((8;`);(9;`));((10;`);(11;`)))\nq).u.w\ntrade| 8 `  9 `\nquote| 10 ` 11 `\nq).u.w[;;0]\ntrade| 8  9\nquote| 10 11\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We subsequently employ the Iterator ",(0,i.jsx)(t.code,{children:"Over /"})," in conjunction with the ",(0,i.jsx)(t.code,{children:"union"})," operator to obtain the union of all the handles. Like many KDB/Q operators, ",(0,i.jsx)(t.code,{children:"Over"})," has multiple overloads. In this particular scenario, ",(0,i.jsx)(t.code,{children:"Over"})," functions as an accumulator. For a comprehensive understanding of ",(0,i.jsx)(t.code,{children:"Over"}),", you can refer to the documentation linked ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/accumulators/",children:"here"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)union/[.u.w[;;0]]\n8 9 10 11\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Next, we apply the ",(0,i.jsx)(t.code,{children:"neg"})," operator to negate all the handles, as we intend to send an asynchronous message."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)(neg union/[.u.w[;;0]])\n-8 -9 -10 -11\n"})}),"\n",(0,i.jsxs)(t.p,{children:["To recap, we send an asynchronous message to all real-time subscribers, triggering the execution of their ",(0,i.jsx)(t.code,{children:".u.end"})," function with the current date as the parameter."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"(neg union/[w[;;0]])@\\:(`.u.end;x)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We have now completed the detailed exploration of all the functions in the ",(0,i.jsx)(t.code,{children:"u.q"})," file. We've covered a substantial amount of material up to this point. Let's take a brief pause for reflection and review what we've learned so far. This will allow you to consolidate your understanding of the topics we've covered before we proceed to delve into the remaining code of our Tick system. Stay tuned for more insights!"]}),"\n",(0,i.jsx)(t.p,{children:"Happy Coding!"})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);