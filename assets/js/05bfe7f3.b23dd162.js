"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[687],{7708:(e,o,i)=>{i.r(o),i.d(o,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var t=i(4848),n=i(8453);const r={sidebar_position:2},s="Memory Management",l={id:"concepts/memoryManagement",title:"Memory Management",description:"This blog post dives into a crucial aspect of real-time data handling: Memory Management. Despite its significance in architectural system design, this topic is not extensively covered in the official KX documentation. A profound comprehension of Memory Management in KDB/Q is crucial for understanding the workings of Garbage Collection in the same environment. In this blog post, I aim to provide a comprehensive overview of Memory Management in KDB/Q, shedding light on essential considerations for designing an efficient system.",source:"@site/docs/concepts/memoryManagement.mdx",sourceDirName:"concepts",slug:"/concepts/memoryManagement",permalink:"/docs/concepts/memoryManagement",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Attributes",permalink:"/docs/concepts/attributes"},next:{title:"Garbage Collection",permalink:"/docs/concepts/garbageCollection"}},a={},d=[{value:"Buddy Memory Allocation",id:"buddy-memory-allocation",level:2},{value:"Why Memory Management Matters",id:"why-memory-management-matters",level:2}];function c(e){const o={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.h1,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(o.p,{children:"This blog post dives into a crucial aspect of real-time data handling: Memory Management. Despite its significance in architectural system design, this topic is not extensively covered in the official KX documentation. A profound comprehension of Memory Management in KDB/Q is crucial for understanding the workings of Garbage Collection in the same environment. In this blog post, I aim to provide a comprehensive overview of Memory Management in KDB/Q, shedding light on essential considerations for designing an efficient system."}),"\n",(0,t.jsx)(o.h2,{id:"buddy-memory-allocation",children:"Buddy Memory Allocation"}),"\n",(0,t.jsxs)(o.p,{children:["In the background, KDB/Q employs the ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Buddy_memory_allocation",children:"Buddy Memory Allocation"})," Algorithm for memory allocation to objects. This method partitions memory into sizes that are powers of two, aiming to fulfill memory requests in the most efficient manner. The approach involves dividing memory into halves and attempting to provide the best fit for a given request. According to the renowned computer scientist and mathematician ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Donald_Knuth",children:"Donald Knuth"}),", the buddy system was invented in 1963 by ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Harry_Markowitz",children:"Harry Markowitz"}),". Markowitz is widely recognized for his groundbreaking contributions to ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Modern_portfolio_theory",children:"Modern Portfolio Theory (MPT)"})," and the development of the ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Efficient_frontier",children:"Efficient Portfolio Frontier"}),"."]}),"\n",(0,t.jsxs)(o.p,{children:["Various forms of the buddy system exist, and the most common variant involves subdividing each block into two smaller blocks. Each memory block in this system is assigned an order, represented by an integer ranging from 0 to a specified upper limit. The size of a block with order ",(0,t.jsx)(o.code,{children:"n"})," is proportional to ",(0,t.jsx)(o.code,{children:"2^n"}),", ensuring that blocks are precisely twice the size of those one order lower. This power-of-two sizing simplifies address computation as all buddies are aligned on memory address boundaries that are powers of two. When a larger block is split, it divides into two smaller blocks, with each smaller block serving as a unique buddy to the other. Importantly, a split block can only be merged with its unique buddy block (the block adjacent to it), effectively reconstituting the larger block from which they were initially split."]}),"\n",(0,t.jsxs)(o.p,{children:["The following example should illustrate the concept of Buddy Memory Allocation. Suppose the smallest block size in this system is 64 kilobytes, and the upper limit for the order is 4, yielding the largest possible allocatable block at ",(0,t.jsx)(o.code,{children:"2^4"})," times 64K = 1024K in size. The system's state after several memory requests might appear as follows:"]}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Buddy_memory_allocation",children:"Source: Wikipedia Buddy memory allocation"})}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.img,{alt:"KDB/Q Buddy Memory Allocation",src:i(3391).A+""})}),"\n",(0,t.jsx)(o.p,{children:"In the above scenario the  Buddy Memory Allocation Algorithm functions in the following sequence:"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"The initial state of the memory of our system"}),"\n",(0,t.jsxs)(o.li,{children:["Program A requests memory 34 K, order 0.","\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"No order 0 blocks are available, so an order 4 block is split, creating two order 3 blocks."}),"\n",(0,t.jsx)(o.li,{children:"Still no order 0 blocks available, so the first order 3 block is split, creating two order 2 blocks."}),"\n",(0,t.jsx)(o.li,{children:"Still no order 0 blocks available, so the first order 2 block is split, creating two order 1 blocks."}),"\n",(0,t.jsx)(o.li,{children:"Still no order 0 blocks available, so the first order 1 block is split, creating two order 0 blocks."}),"\n",(0,t.jsx)(o.li,{children:"Now an order 0 block is available, so it is allocated to A."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(o.li,{children:"Program B requests memory 66 K, order 1. An order 1 block is available, so it is allocated to B."}),"\n",(0,t.jsx)(o.li,{children:"Program C requests memory 35 K, order 0. An order 0 block is available, so it is allocated to C."}),"\n",(0,t.jsxs)(o.li,{children:["Program D requests memory 67 K, order 1.","\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"No order 1 blocks are available, so an order 2 block is split, creating two order 1 blocks."}),"\n",(0,t.jsx)(o.li,{children:"Now an order 1 block is available, so it is allocated to D."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(o.li,{children:"Program B releases its memory, freeing one order 1 block."}),"\n",(0,t.jsxs)(o.li,{children:["Program D releases its memory.","\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"One order 1 block is freed."}),"\n",(0,t.jsx)(o.li,{children:"Since the buddy block of the newly freed block is also free, the two are merged into one order 2 block."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(o.li,{children:"Program A releases its memory, freeing one order 0 block."}),"\n",(0,t.jsxs)(o.li,{children:["Program C releases its memory.","\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"One order 0 block is freed."}),"\n",(0,t.jsx)(o.li,{children:"Since the buddy block of the newly freed block is also free, the two are merged into one order 1 block."}),"\n",(0,t.jsx)(o.li,{children:"Since the buddy block of the newly formed order 1 block is also free, the two are merged into one order 2 block."}),"\n",(0,t.jsx)(o.li,{children:"Since the buddy block of the newly formed order 2 block is also free, the two are merged into one order 3 block."}),"\n",(0,t.jsx)(o.li,{children:"Since the buddy block of the newly formed order 3 block is also free, the two are merged into one order 4 block."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"As you can see, what happens when a memory request is made is as follows:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"If memory is to be allocated"}),"\n"]}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:["Look for a memory slot of a suitable size (the minimal 2k block that is larger or equal to that of the requested memory)","\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"If it is found, it is allocated to the program"}),"\n",(0,t.jsxs)(o.li,{children:["If not, it tries to make a suitable memory slot. The system does so by trying the following:","\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"Split a free memory slot larger than the requested memory size into half"}),"\n",(0,t.jsx)(o.li,{children:"If the lower limit is reached, then allocate that amount of memory"}),"\n",(0,t.jsx)(o.li,{children:"Go back to step 1 (look for a memory slot of a suitable size)"}),"\n",(0,t.jsx)(o.li,{children:"Repeat this process until a suitable memory slot is found"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"If memory is to be freed"}),"\n"]}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"Free the block of memory"}),"\n",(0,t.jsx)(o.li,{children:"Look at the neighboring block \u2013 is it free too?"}),"\n",(0,t.jsx)(o.li,{children:"If it is, combine the two, and go back to step 2 and repeat this process until either the upper limit is reached (all memory is freed), or until a non-free neighbour block is encountered"}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"why-memory-management-matters",children:"Why Memory Management Matters"}),"\n",(0,t.jsx)(o.p,{children:"You might wonder why you should pay this much attention to the inner working of KDB/Q's Memory Management. When building a KDB/Q system, you are bound by hardware restrictions and the amount of memory available. This means that the volume of data you can store in memory is finite and this limitation needs to be considered when designing your system. However, the required space can easily be underestimated due to the fact that the Buddy Memory allocation algorithm allocates memory to objects in blocks of power-of-two, rounding the size of an object to the next larger power-of-two."}),"\n",(0,t.jsxs)(o.p,{children:["This can easily be seen by inspecting the memory allocated to a simple list. An atom of ",(0,t.jsx)(o.a,{href:"https://code.kx.com/q/ref/#datatypes",children:"datatype"})," ",(0,t.jsx)(o.code,{children:"long"})," (the default datatype in KDB/Q) has a size of 8 bytes. A simple list of 4000 ",(0,t.jsx)(o.code,{children:"long"})," atoms should therefore occupy ",(0,t.jsx)(o.code,{children:"4000 * 8 = 32000"})," bytes, and a list with 5000 ",(0,t.jsx)(o.code,{children:"long"})," atoms should occupy ",(0,t.jsx)(o.code,{children:"5000*8=40000"})," bytes. However, as evident from the code snippet below, the list with 5000 long atoms consumes approximately 1.5 times more space than our initial estimation. We can delve deeper to determine the number of elements required for the Buddy Memory Allocation to allocate the next power-of-two block size."]}),"\n",(0,t.jsxs)(o.admonition,{type:"tip",children:[(0,t.jsx)(o.mdxAdmonitionTitle,{}),(0,t.jsxs)(o.p,{children:["You can use the system command ",(0,t.jsx)(o.a,{href:"https://code.kx.com/q/basics/syscmds/#ts-time-and-space",children:"\\ts"})," to evaluate the execution time an expression takes to run in milliseconds and the space used in bytes."]})]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{children:"q)4000*8\n32000\nq)5000*8\n40000\nq)\\ts til 4000\n48 32944\nq)\\ts til 5000\n0 65712\nq)\\ts til 4094\n0 32944\nq)\\ts til 4095\n0 65712\n"})}),"\n",(0,t.jsx)(o.p,{children:"As you can observe, once our list of long atoms grows beyond 4094 elements, the Buddy Memory Algorithm  allocates the next larger block of memory to accommodate the list.\nCalculating the various memory blocks is straightforward:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{children:"q)2 xexp til 20\n1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288f\n"})}),"\n",(0,t.jsx)(o.p,{children:"I hope this post has been beneficial in explaining the concept of Memory Management in KBD/Q. It is essential to grasp this concept as it forms the foundation for our upcoming discussion on Garbage Collection. Stay tuned!"}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.strong,{children:"Resources"})}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.a,{href:"https://www.timestored.com/kdb-guides/memory-management",children:"Memory Management in KDB"}),", TimeStored by Ryan Hamilton"]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.a,{href:"https://dataintellect.com/blog/kdb-database-setup-utilities/",children:"KDB+ Database Setup Utilities"})," by Data Intellect"]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.a,{href:"https://dataintellect.com/blog/adventure-in-retrieving-memory-size-of-kdb-object/",children:"Adventure in Retrieving Memory Size of KDB+ Object"})," by Data Intellect"]}),"\n"]})]})}function h(e={}){const{wrapper:o}={...(0,n.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},3391:(e,o,i)=>{i.d(o,{A:()=>t});const t=i.p+"assets/images/MemoryManagement-3d55c42da3303abd9590fe74bfccc91b.mp4"},8453:(e,o,i)=>{i.d(o,{R:()=>s,x:()=>l});var t=i(6540);const n={},r=t.createContext(n);function s(e){const o=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function l(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),t.createElement(r.Provider,{value:o},e.children)}}}]);