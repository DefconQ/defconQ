"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8909],{94354:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var t=s(74848),r=s(28453);const i={sidebar_position:12},o="Beyond the Fundamentals: Next Level Interprocess Communications",a={id:"concepts/ipcNextLevel",title:"Beyond the Fundamentals: Next Level Interprocess Communications",description:"In my last blog post, we covered the essential concepts of Interprocess Communication (IPC) in KDB/Q. Now, it's time to take things up a notch!",source:"@site/docs/concepts/ipcNextLevel.mdx",sourceDirName:"concepts",slug:"/concepts/ipcNextLevel",permalink:"/docs/concepts/ipcNextLevel",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"Fundamentals of Interprocess Communication (IPC)",permalink:"/docs/concepts/ipc"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},c={},l=[{value:"Asynchronous Broadcasting",id:"asynchronous-broadcasting",level:2},{value:"Asynchronous Callbacks",id:"asynchronous-callbacks",level:2},{value:"Unary Functions",id:"unary-functions",level:3},{value:"Error Trapping: Safeguard Your Code",id:"error-trapping-safeguard-your-code",level:4},{value:"Trap Gotchas",id:"trap-gotchas",level:5},{value:"Variadic Functions",id:"variadic-functions",level:3},{value:"Wrapper Function",id:"wrapper-function",level:3},{value:"Anonymous Functions",id:"anonymous-functions",level:3},{value:"Deferred Synchronous Messaging",id:"deferred-synchronous-messaging",level:2},{value:"Deferred Response",id:"deferred-response",level:2},{value:"Mastering Deferred Response: A Practical Gateway Example",id:"mastering-deferred-response-a-practical-gateway-example",level:3},{value:"Realtime Database RDB",id:"realtime-database-rdb",level:4},{value:"Historical Database HDB",id:"historical-database-hdb",level:4},{value:"Gateway",id:"gateway",level:4},{value:"Client",id:"client",level:4}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"beyond-the-fundamentals-next-level-interprocess-communications",children:"Beyond the Fundamentals: Next Level Interprocess Communications"}),"\n",(0,t.jsxs)(n.p,{children:["In my last blog post, we covered the essential concepts of ",(0,t.jsx)(n.strong,{children:"Interprocess Communication (IPC)"})," in KDB/Q. Now, it's time to take things up a notch!"]}),"\n",(0,t.jsxs)(n.p,{children:["In this post, we\u2019ll explore advanced IPC techniques that are crucial for building more sophisticated ",(0,t.jsx)(n.strong,{children:"KDB/Q Tick applications"}),". Whether you're enhancing the standard Tick setup with components like a Gateway or Load Balancer, or simply looking to optimize your existing architecture for better efficiency and performance, these concepts will be invaluable. The topics we are going to cover are the follwoing"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Asynchronous Broadcast"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Asynchronous Callbacks"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Deferred Synchronous Messaging"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Deferred Response"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["All of these concepts are covered in the official documentation at ",(0,t.jsx)(n.a,{href:"https://code.kx.com/home/",children:"code.kx.com"}),", but my goal is to break them down into simple, digestible explanations, one byte (pun intended) at a time. If you need a refresher on the ",(0,t.jsx)(n.strong,{children:"Fundamentals of IPC"}),", you can check out my previous blog post ",(0,t.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/ipc",children:"here"}),". Otherwise, let\u2019s get straight to it, let's immerse ourselves into the world of IPC mastery!"]}),"\n",(0,t.jsx)(n.h2,{id:"asynchronous-broadcasting",children:"Asynchronous Broadcasting"}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/releases/ChangesIn3.4/",children:"KDB/Q version 3.4"}),", KX introduced asynchronous broadcast, also known as ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/basics/internal/#-25x-async-broadcast",children:(0,t.jsx)(n.code,{children:"-25!"})}),", enabling the broadcasting of data as an asynchronous message to specific handles. But why was this feature implemented? To understand this, we need to take a step back and examine what happens behind the scenes when data is sent via Interprocess Communication (IPC)."]}),"\n",(0,t.jsxs)(n.p,{children:["Transmitting raw data can be inefficient and slow, which is why KDB/Q serializes data before sending it, and the receiving process then deserializes it. While this process is usually fast for small amounts of data, it can become increasingly time-consuming when dealing with large datasets or sending data to multiple processes. This inefficiency is particularly noticeable in the default implementation of the plain vanilla Tickerplant, as shown in the code below. (For a detailed walkthrough of the plain vanilla Tickerplant, check out my blog post ",(0,t.jsx)(n.a,{href:"https://www.defconq.tech/docs/tutorials/tick",children:"here"}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:".u.pub:{[t;x]\n        {[t;x;w] if[count x:.u.sel[x] w 1;(neg first w)(`upd;t;x)]}[t;x] each .u.w[t]\n        };\n"})}),"\n",(0,t.jsx)(n.p,{children:"As shown in the code above, we iterate over all subscriber handles for a specific table, sending the data asynchronously to each one. This approach requires the message to be serialized separately for every subscriber, which can introduce performance overhead and slow down the process."}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["You can use the internal functions ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/basics/internal/#-8x-to-bytes",children:(0,t.jsx)(n.code,{children:"-8!"})})," and ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/basics/internal/#-9x-from-bytes",children:(0,t.jsx)(n.code,{children:"-9!"})})," for data serialization and deserialization. ",(0,t.jsx)(n.code,{children:"-8!x"})," converts ",(0,t.jsx)(n.code,{children:"x"})," into its IPC byte representation, while ",(0,t.jsx)(n.code,{children:"-9!x"})," reconstructs data from its IPC byte format. Explore more serialization examples ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/kb/serialization/",children:"here"})]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Serialise\nq)-8!1 2 3\n0x010000001a000000060003000000010000000200000003000000\n// Deserialise\nq)-9!-8!1 2 3\n1 2 3\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["To optimize this process, KX introduced asynchronous broadcast. The key advantage of ",(0,t.jsx)(n.code,{children:"-25!(handles;msg)"})," over ",(0,t.jsx)(n.code,{children:"neg[handles]@\\:msg"})," is that it serializes the message only once, significantly reducing CPU and memory load. The message is serialized to the lowest capability of the list of handles, meaning if the connected processes are running different versions of KDB/Q, the serialization will be limited to the types supported by the oldest version. If an error occurs, no messages are sent, and the function will return the handle whose capability caused the failure."]}),"\n",(0,t.jsxs)(n.p,{children:["Similar to ",(0,t.jsx)(n.code,{children:"neg[handles]@\\:msg"}),", the ",(0,t.jsx)(n.code,{children:"-25!x"})," operation queues the message as asynchronous on the specified handles. The messages are not sent immediately but will be dispatched during the next iteration of the main loop or can be flushed manually using ",(0,t.jsx)(n.code,{children:"neg[handles]@\\:(::)"})," or ",(0,t.jsx)(n.code,{children:"-25!(handles; ::)"})]}),"\n",(0,t.jsx)(n.h2,{id:"asynchronous-callbacks",children:"Asynchronous Callbacks"}),"\n",(0,t.jsxs)(n.p,{children:["So far, we\u2019ve covered fairly straightforward concepts of Interprocess Communication. Now, it\u2019s time to explore something slightly more advanced: ",(0,t.jsx)(n.strong,{children:"Asynchronous Callbacks"}),". This technique is especially useful when you want to maintain fully asynchronous communication between processes, ensuring maximum efficiency, neither process gets blocked or has to wait for a response."]}),"\n",(0,t.jsxs)(n.p,{children:["While implementing asynchronous callbacks isn\u2019t overly complex, there\u2019s one critical rule to follow: ",(0,t.jsx)(n.strong,{children:"both the client and the server must use async calls"}),". Failing to do so can lead to a ",(0,t.jsx)(n.strong,{children:"deadlock"}),". For instance, due to KDB/Q's single-threaded nature, if the client makes a synchronous call, the server\u2019s attempt to call back will hang indefinitely since the original synchronous call is still being processed."]}),"\n",(0,t.jsx)(n.p,{children:"Let\u2019s go through some examples to see asynchronous callbacks in action!"}),"\n",(0,t.jsx)(n.h3,{id:"unary-functions",children:"Unary Functions"}),"\n",(0,t.jsx)(n.p,{children:"Let's start with a simple example: invoking a unary function (a function that takes a single argument) via an asynchronous call on the server side. The server will evaluate the function and send the result back to the client."}),"\n",(0,t.jsxs)(n.p,{children:["On the client side, we'll define a function to handle the server's response. Once the function is processed, the server will ",(0,t.jsx)(n.strong,{children:'"call back"'})," to the client process that originally invoked it, triggering the client-side function to process the result."]}),"\n",(0,t.jsx)(n.p,{children:"The following code snippet demonstrates this behavior:"}),"\n",(0,t.jsx)(n.p,{children:"First, we define two functions on the server: one to process and handle the client call and invoke a unary function, and secondly the actual unary function, invoked by the function that processes the request, itself. While it's not strictly necessary to separate them, as everything could be handled within a single function, for clarity, I've chosen to break it down into two distinct functions. This makes it easier to understand each step of the process. After this example, we\u2019ll explore how to consolidate everything into a single function."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// just a reminder, our server runs on port 6001\nq)\\p\n6001\n// A unary function taking one argument. \nq)unaryServerFunction:{show "Hello from the client side. This is client: ",string x}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Next, we define the function responsible for handling the client's request and executing the previously defined unary function. We then send an asynchronous message to the client, calling the client function that was provided as the ",(0,t.jsx)(n.code,{children:"y"})," parameter in the request-handling function."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)processClientRequest:{unaryServerFunction x;(neg .z.w)(y;"Hello from the server side")}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, the final step is to define the client function that will process the result returned by the server. Once that's in place, we can send an asynchronous message to the server, calling the ",(0,t.jsx)(n.code,{children:"processClientRequest"})," function and passing the client name as the ",(0,t.jsx)(n.code,{children:"x"})," parameter and the client function name as the ",(0,t.jsx)(n.code,{children:"y"})," parameter for the server to invoke as a callback."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// h contains the connection handle to the server \nq)h\n8i\n// define client function to be invoked by the server\nq)clientFunction:{show x}\n// asynchronous call to the server\nq)neg[h](`processClientRequest;`DefconQ;`clientFunction)\n// result\nq)"Hello from the server side"\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Asynchronous Callback",src:s(99955).A+"",width:"3420",height:"356"})}),"\n",(0,t.jsxs)(n.p,{children:["That wasn\u2019t too difficult! Earlier, I mentioned that everything we just implemented using two functions could actually be done in a single function. Do you think that\u2019s possible? It absolutely is! All we need to do is make a small adjustment to the ",(0,t.jsx)(n.code,{children:"unaryServerFunction"}),', modifying it so that it prints the "Hello from the client side" message to the console and then sends an asynchronous message back to the client. The code snippet below highlights the necessary changes on the server side, no modifications are needed on the client side since the overall behavior remains unchanged.']}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)unaryServerFunction:{\n\tshow "Hello from the client side. This is client: ",string x;\n\t(neg .z.w)(y;"Hello from the Server side")}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Asynchronous Callback with one function only",src:s(4169).A+"",width:"3406",height:"466"})}),"\n",(0,t.jsx)(n.p,{children:"That wasn\u2019t too difficult either! At this point, you might be thinking that interprocess communication isn\u2019t all that challenging after all. But, as with anything in programming, or life in general, you should always expect the unexpected. What do I mean by that? Well, what if the client sends an incorrect data type as a parameter to the unary function on the server? What would happen then?"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"QA Testing",src:s(43823).A+"",width:"800",height:"660"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's walk through an example. First, we'll define a function called square ",(0,t.jsx)(n.code,{children:"square"})," on the server, which takes a parameter ",(0,t.jsx)(n.code,{children:"x"}),", computes its square, and returns the result. Additionally, it will print the result to the console. We'll then refactor our ",(0,t.jsx)(n.code,{children:"processClientRequest"})," function to invoke the",(0,t.jsx)(n.code,{children:"square"})," function with the parameter provided by the client and return the result via an asynchronous callback. Once again, there\u2019s no need to modify anything on the client side, all we have to do is send an asynchronous message to the server, invoking ",(0,t.jsx)(n.code,{children:"processClientRequest"})," with the appropriate parameters."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)square:{show "The square of ",string[x]," is ",string[res:x*x];:res}\nq)processClientRequest:{result:square x;(neg .z.w)(y;"Squaring ",string[x]," returns :",string result)}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.p,{children:"With our server-side functions now refactored, the final step is to invoke them asynchronously from the client. Let's start by passing a valid integer to be squared."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)neg[h](`processClientRequest;4;`clientFunction)\n// Answer from server\nq)"Squaring 4 returns :16"\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.p,{children:"The request was successfully processed on the server, with the result logged to the console and then sent back to the client, which also displayed it on its console (as shown above)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)"The square of 4 is 16"\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Asynchronous Callback Testing with correct data type",src:s(39725).A+"",width:"3420",height:"234"})}),"\n",(0,t.jsxs)(n.p,{children:["Next, let's repeat the same exercise but pass a symbol data type instead. Since the ",(0,t.jsx)(n.code,{children:"square"})," function on the server expects a numerical input, this will naturally result in a ",(0,t.jsx)(n.code,{children:"type"})," error."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)neg[h](`processClientRequest;`DefconQ;`clientFunction)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)\'type\n  [2]  square:{show "The square of ",string[x]," is ",string[res:x*x];:res}\n                                                                  ^\nq))\\\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Asynchronous Callback Testing with incorrect data type",src:s(58918).A+"",width:"3416",height:"478"})}),"\n",(0,t.jsxs)(n.p,{children:["As seen in the code snippet and screenshot above, the server encountered a ",(0,t.jsx)(n.code,{children:"type"})," error and has entered debug mode. You will need to manually exit it using the backslash ",(0,t.jsx)(n.code,{children:"\\"})," command."]}),"\n",(0,t.jsx)(n.p,{children:"This behavior is highly undesirable and must be avoided at all costs, as it results in the server becoming unresponsive until manual intervention. In a large investment bank or hedge fund processing millions of trades daily, even a few minutes of downtime could lead to substantial financial losses."}),"\n",(0,t.jsx)(n.h4,{id:"error-trapping-safeguard-your-code",children:"Error Trapping: Safeguard Your Code"}),"\n",(0,t.jsxs)(n.p,{children:["How can we prevent situations like the one we just encountered? Luckily, nearly every programming language offers a mechanism for handling exceptions. If you're familiar with languages like Java, you might recognize this as a ",(0,t.jsx)(n.strong,{children:"try-catch"})," statement. In KDB/Q, exception handling is managed using the ",(0,t.jsx)(n.strong,{children:"trap"})," operator. And in good KDB/Q manner, this is an operator we have already seen several times, having multiple overloads, one of which serves as ",(0,t.jsx)(n.strong,{children:"trap"}),". Here\u2019s the syntax:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Syntax"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Trap At"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@[f;fx;e]"})}),(0,t.jsxs)(n.td,{children:["Try ",(0,t.jsx)(n.code,{children:"f@fx"}),";    catch with ",(0,t.jsx)(n.code,{children:"e"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Trap"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:".[g;gx;e]"})}),(0,t.jsxs)(n.td,{children:["Try ",(0,t.jsx)(n.code,{children:"g . gx"}),";  catch with ",(0,t.jsx)(n.code,{children:"e"})]})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"where"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"f"})," is a unary function, with ",(0,t.jsx)(n.code,{children:"fx"})," as an argument within its domain."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"g"})," is a function with a specified rank, and ",(0,t.jsx)(n.code,{children:"gx"})," is either an atom or a list of length ",(0,t.jsx)(n.strong,{children:"count"}),"  containing elements within the domain of ",(0,t.jsx)(n.code,{children:"g"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"e"})," represents an expression, usually a function."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Now, let's put the trap operator into action and see how it works in practice. First, we define two functions in our KDB/Q process: a unary function, ",(0,t.jsx)(n.code,{children:"square"}),", which takes a single argument and returns its square, and a binary function that accepts two arguments and returns their sum. By using the ",(0,t.jsx)(n.code,{children:"trap"})," operator with ",(0,t.jsx)(n.code,{children:"@"})," and ",(0,t.jsx)(n.code,{children:"."})," to invoke these functions, we can catch any errors that occur without disrupting the program flow. Instead of halting execution, the error message is returned gracefully."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)square:{x*x}\nq)add:{x+y}\nq)@[square;4;{"Error message: ",x}]\n16\nq)@[square;`DefconQ;{"Error message: ",x}]\n"Error message: type"\nq).[add;(3;4);{"Error message: ",x}]\n7\nq).[add;(`DefconQ;4);{"Error message: ",x}]\n"Error message: type"\nq)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, let's apply this knowledge within a function to prevent process interruptions. By wrapping our function calls with ",(0,t.jsx)(n.code,{children:"trap"}),", we can ensure that any errors are handled gracefully, allowing the program to continue running smoothly instead of getting stuck in debug mode. First, we define a function that invokes the previously defined ",(0,t.jsx)(n.code,{children:"square"})," function without using ",(0,t.jsx)(n.code,{children:"trap"})," to observe how it behaves when called with an incorrect data type.."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)functionWithoutErrorTrap:{[x] res:square[x]; show "Function continues";:"Return success. Result is: ",string res}\nq)square[2]\n4\nq)functionWithoutErrorTrap[2]\n"Function continues"\n"Return success. Result is: 4"\nq)functionWithoutErrorTrap[`DefconQ]\n\'type\n  [2]  square:{x*x}\n                ^\nq))\\\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Next, we create another function with the same functionality but explicitly use ",(0,t.jsx)(n.code,{children:"trap"})," to catch any potential errors. In the first case, the program flow is interrupted, causing the process to enter debug mode until we manually exit using the backslash operator. However, in the second case, ",(0,t.jsx)(n.code,{children:"trap"})," ensures that errors are handled gracefully, preventing any disruption to the process flow."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'q)functionWithErrorTrap:{[x] res:@[square;x;{"Error message: ",x}];show "Function continues";:"Return success. Result is: ",res}\nq)functionWithErrorTrap[`DefconQ]\n"Function continues"\n"Return success. Result is: Error message: type"\n'})}),"\n",(0,t.jsx)(n.h5,{id:"trap-gotchas",children:"Trap Gotchas"}),"\n",(0,t.jsxs)(n.p,{children:["One key consideration when using ",(0,t.jsx)(n.strong,{children:"trap"})," is how KDB/Q evaluates expressions. As we saw in the syntax ",(0,t.jsx)(n.code,{children:"@[f;fx;e]"}),", the expression ",(0,t.jsx)(n.code,{children:"e"})," can be any valid KDB/Q expression. However, KDB/Q evaluates expressions before executing the actual code, meaning that if ",(0,t.jsx)(n.code,{children:"e"})," contains a syntax error, your code will fail before trap even gets a chance to run. Additionally, since ",(0,t.jsx)(n.code,{children:"e"})," is evaluated first, any code within it will execute immediately, regardless of whether an error occurs in ",(0,t.jsx)(n.code,{children:"f@fx"}),". In most cases, you\u2019ll want ",(0,t.jsx)(n.code,{children:"e"})," to be a function that only executes when an error is thrown, ensuring it runs only when needed. The below examples should illustrate this behaviour:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)@[square;2;nonExistingVariable]\n'nonExistingVariable\n  [0]  @[square;2;nonExistingVariable]\n                  ^\nq)@[square;2;{nonExistingVariable}]\n4\nq)@[square;2;{nonExistingVariable]\n']\n  [0]  @[square;2;{nonExistingVariable]\n                                      ^\nq)@[square;2;a:20]\n4\nq)a\n20\nq)@[square;2;{ `a set 100}]\n4\nq)a\n20\nq)@[square;`b;{ `a set 100}]\n`a\nq)a\n100\n"})}),"\n",(0,t.jsx)(n.h3,{id:"variadic-functions",children:"Variadic Functions"}),"\n",(0,t.jsxs)(n.p,{children:["We\u2019ve now explored how to use asynchronous callbacks with a unary function. Next, let\u2019s move on to asynchronous callbacks for variadic functions, functions that can accept any number of arguments. To illustrate this, we\u2019ll define a ",(0,t.jsx)(n.code,{children:"sum"})," function on the server that takes three arguments, ",(0,t.jsx)(n.code,{children:"x,y and z"}),", and returns their sum. We\u2019ll then use ",(0,t.jsx)(n.strong,{children:"apply"})," (another overload of ",(0,t.jsx)(n.code,{children:"."}),") to pass the parameters received from the client via an asynchronous call and return the result. The code for this example is provided below."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)add:{x+y+z}\nq)processClientRequest:{show res:add . x;(neg .z.w)(y;res)}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["From the client side, we can now make an asynchronous call to the server, invoking the ",(0,t.jsx)(n.code,{children:"processClientRequest"})," function and passing the list of arguments to be passed to the ",(0,t.jsx)(n.code,{children:"add"})," function defined on the server. The result is first logged to the console on the server side before being sent back to the client, where it is then displayed on the console as well."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)clientFunction\n{show x}\nq)neg[h](`processClientRequest;1 2 3;`clientFunction)\n// result from the server\nq)6\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Asynchronous Callback Testing with variadic Function",src:s(24140).A+"",width:"3420",height:"356"})}),"\n",(0,t.jsx)(n.p,{children:"This worked perfectly! However, there's something worth considering, our example is quite limited, as it only handles a single specific use case: calculating the sum of three numbers on the server. In a real-world KDB/Q Tick Architecture, this wouldn't be practical. So how can we make it more flexible? The solution is to create a wrapper function and refactor our code to handle a wider range of scenarios."}),"\n",(0,t.jsx)(n.h3,{id:"wrapper-function",children:"Wrapper Function"}),"\n",(0,t.jsxs)(n.p,{children:["To make the asynchronous communication between our client and server more flexible, we'll modify the ",(0,t.jsx)(n.code,{children:"processClientRequest"})," function on the server. Instead of being limited to a specific function, it will now accept the name of any function defined on the server as a parameter, evaluate it with the provided arguments, and return the result to the client that initiated the asynchronous call."]}),"\n",(0,t.jsxs)(n.p,{children:["To evaluate any function dynamically on the server, we leverage the evaluate-by-name concept. By passing the function name as a parameter, we can use the ",(0,t.jsx)(n.code,{children:"value"})," operator in KDB/Q to retrieve and execute the corresponding function definition. Let\u2019s illustrate this with an example."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)add\n{x+y}\nq)value `add\n{x+y}\nq)(value `add)[2;3]\n5\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now, we can apply this knowledge to refactor our code and achieve the desired functionality. The following code implements these changes."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)add:{x+y}\nq)sub:{x-y}\nq)processClientRequest:{show res:(value x) . y;(neg .z.w)(z;res)}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// invoke the add function on the server, adding 5 to 10\nq)neg[h](`processClientRequest;`add;10 5;`clientFunction)\nq)15\n// invoke the sub function on the server, subtracting 5 from 10\nq)neg[h](`processClientRequest;`sub;10 5;`clientFunction)\nq)5\n"})}),"\n",(0,t.jsx)(n.p,{children:"Pretty cool, right?"}),"\n",(0,t.jsx)(n.h3,{id:"anonymous-functions",children:"Anonymous Functions"}),"\n",(0,t.jsx)(n.p,{children:"But we can take it even further! By leveraging an anonymous function, we can combine everything we've learned so far to achieve the same functionality, without defining any functions on the server at all. And if we really want to push the boundaries, we don't even need to define the function that processes the result on the client either. Let's dive in and explore how this works!"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsxs)(n.p,{children:["First, to keep things simple, we'll use a single anonymous function while still relying on the ",(0,t.jsx)(n.code,{children:"clientFunction"})," defined on our client to handle the result returned by the server. Remember, we can send a query via Interprocess Communication as a parse tree using the syntax ",(0,t.jsx)(n.code,{children:"(functionName; arg1; ...; argN)"}),". In this case, instead of specifying a function name to be executed on the server, we send an anonymous function. This function takes three parameters: ",(0,t.jsx)(n.code,{children:"x"})," and ",(0,t.jsx)(n.code,{children:"y"}),", which are numeric values used to compute the sum of two numbers, and ",(0,t.jsx)(n.code,{children:"z"}),", which represents the function name to be invoked on the client side when the server returns the result."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)neg[h]({(neg .z.w)(z;x+y)};10;5;`clientFunction)\nq)15\n"})}),"\n",(0,t.jsx)(n.p,{children:"where"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{(neg .z.w)(z;x+y)}"})," is the anonymous function taking three parameters, ",(0,t.jsx)(n.code,{children:"x,y,z"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"x and y"})," are numeric values used to compute the sum of two numbers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"z"})," the function name to be invoked on the client side when the server returns the result"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Let's take it a step further by replacing the function name intended for invocation on the client with another anonymous function. This makes the entire process completely independent of any predefined functions on either the client or server."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)neg[h]({(neg .z.w)(z;x+y)};10;5;{show x})\nq)15\n"})}),"\n",(0,t.jsx)(n.h2,{id:"deferred-synchronous-messaging",children:"Deferred Synchronous Messaging"}),"\n",(0,t.jsx)(n.p,{children:"After exploring asynchronous callbacks, we now understand a powerful communication method that enables efficient interaction between KDB/Q processes without causing any of them to block. But is this always the best approach? What if the process sending an asynchronous call depends on the result and cannot proceed until it receives a response? Consider a client querying a load balancer, which then distributes the request across multiple backend processes. The client needs the full response before it can continue execution. In our previous asynchronous callback examples, the client never waited for a response, it simply sent the query and moved on. This can be problematic in scenarios where the client must wait for the result."}),"\n",(0,t.jsxs)(n.p,{children:["This is exactly where we are going to leverage ",(0,t.jsx)(n.strong,{children:"Deferred Synchronous Messaging"}),": This technique involves sending an asynchronous message first and immediately flushing the output queue by following up with a synchronous message. This ensures that the client remains blocked until a response is received, allowing for controlled execution flow."]}),"\n",(0,t.jsxs)(n.p,{children:["Before discussing ",(0,t.jsx)(n.strong,{children:"deferred synchronous messaging"})," in detail, let\u2019s quickly revisit the difference between synchronous and asynchronous messaging:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronous messaging"})," pauses the client process after sending a request, waiting for a response from the server before continuing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous messaging"})," allows the client to continue execution immediately after sending a request, without waiting for or expecting a reply."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Since asynchronous messages do not expect a return value, what happens if the server does send a response to an asynchronous request? Let\u2019s explore this scenario: we have set up two KDB/Q processes, the client running on port ",(0,t.jsx)(n.code,{children:"6000"})," and the server on port ",(0,t.jsx)(n.code,{children:"6001"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Next, we will define a function ",(0,t.jsx)(n.code,{children:"add"})," on the server that takes two numbers, adds them together, and sends the result back to the client using asynchronous messaging. Now, from the client, we can send an asynchronous request to invoke this function on the server. Let\u2019s see what happens."]}),"\n",(0,t.jsxs)(n.p,{children:["First, we define the function on the server, by leveraging the internal ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/dotz/#zw-handle",children:(0,t.jsx)(n.code,{children:".z.w"})}),", which holds the connection handle of the process that sent the query."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)add:{neg[.z.w] x+y}\n"})}),"\n",(0,t.jsx)(n.p,{children:"We can now call the function from our client by sending an asynchronous message to the server and observe the outcome."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)neg[h](`add;2;3)\nq)'type\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["Remember, we established a connection from the client to the server using ",(0,t.jsx)(n.code,{children:"hopen"}),". The connection handle stored in the variable ",(0,t.jsx)(n.code,{children:"h"})," allows us to send messages and interact with the server."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)h:hopen `::6001\nq)h\n8i\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["As seen in the output, the client encountered a ",(0,t.jsx)(n.code,{children:"type"})," error. But why did this happen? Remember, in asynchronous messaging, the client sends a query without expecting a response. However, in this case, the server did send a reply back to the client. Unlike receiving an unexpected gift, which might be a pleasant surprise, the client wasn\u2019t prepared for a response, resulting in a  ",(0,t.jsx)(n.code,{children:"type"})," error."]}),"\n",(0,t.jsxs)(n.p,{children:["This is a small but important drawback of asynchronous messaging, if the server sends a response and the client isn't expecting it, a ",(0,t.jsx)(n.code,{children:"type"})," error occurs. However, when using ",(0,t.jsx)(n.strong,{children:"Deferred Synchronous Messaging"})," we are essentiallys sending an asynchronous message and then immediately flushing the output queue by following up with a synchronous message. This not only ensures that the client is blocked until a response is received, but by doing this, the client now expects a reply, and when the server sends back the asynchronous callback, the client no longer encounters an error. Let's see this in action:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)neg[h](`add;2;3);h[]\n5\nq)neg[h](`add;2;3);h(::)\n5\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As seen in the code above, we no longer encounter a ",(0,t.jsx)(n.code,{children:"type"})," error, and the result from the ",(0,t.jsx)(n.code,{children:"add"})," function is successfully returned. The two methods, ",(0,t.jsx)(n.code,{children:"h[]"})," and ",(0,t.jsx)(n.code,{children:"h(::)"}),", are equivalent, allowing you to choose whichever style suits you best. Additionally, we can store the returned result in a variable for further processing."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)neg[h](`add;2;3);result:h[]\nq)result*2\n10\nq)result\n5\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With this, we conclude our deep dive into ",(0,t.jsx)(n.strong,{children:"Deferred Synchronous Messaging"})," and can now move on to ",(0,t.jsx)(n.strong,{children:"Deferred Response"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"deferred-response",children:"Deferred Response"}),"\n",(0,t.jsx)(n.p,{children:"In the previous section, we explored how deferred synchronous messaging allows a client to send an asynchronous request to the server while immediately blocking itself with a synchronous message. This approach enables the server to process the request without being blocked, delegating tasks to worker processes in the background, aggregating the results, and then returning them to the client."}),"\n",(0,t.jsxs)(n.p,{children:["This method is so widely used that KX introduced a built-in function to optimize gateway efficiency. Starting from ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/releases/ChangesIn3.6/#deferred-response",children:"KDB/Q version 3.6"}),", the ",(0,t.jsx)(n.strong,{children:"Deferred Response"})," was introduced. In the next section, we\u2019ll take a closer look at how this works, reinforcing the theory with practical examples."]}),"\n",(0,t.jsx)(n.p,{children:"Even though this technique looks complicated at first, it's actually not that hard once you understand it. The deferred response consists of two key components:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Suspending a Sync Message"}),": ",(0,t.jsx)(n.code,{children:"-30!(::)"})," emporarily suspends the processing of a synchronous message, allowing the response to be sent explicitly at a later time. This enables the server to handle other messages before sending a response."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sending the Deferred Response"}),": ",(0,t.jsx)(n.code,{children:"-30!(handle; isError; msg)"})," is used to respond to the deferred sync call. The ",(0,t.jsx)(n.code,{children:"isError"})," flag indicates whether an error occurred (",(0,t.jsx)(n.code,{children:"1b"})," for an error, ",(0,t.jsx)(n.code,{children:"0b"})," for success). The ",(0,t.jsx)(n.code,{children:"msg"})," parameter contains either an error message (if an error occurred) or the actual result of the deferred sync call if execution was successful."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The diagram below illustrates this process."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Client Gateway interaction with Deferred Response",src:s(76585).A+"",width:"966",height:"578"})}),"\n",(0,t.jsxs)(n.p,{children:["As illustrated above, the client first sends a synchronous message (",(0,t.jsx)(n.strong,{children:"1"}),") to the Gateway, which defers the response for later processing, using ",(0,t.jsx)(n.code,{children:"-30!(::)"})," (",(0,t.jsx)(n.strong,{children:"2"}),"). The Gateway then asynchronously dispatches the request (",(0,t.jsx)(n.strong,{children:"3"}),") to the Real-Time Database (RDB) and the Historical Database (HDB) without waiting for an immediate result. Once the RDB and HDB process the query, they return the results (",(0,t.jsx)(n.strong,{children:"4"})," and ",(0,t.jsx)(n.strong,{children:"5"}),") asynchronously to the Gateway. The Gateway then aggregates these results (not shown in the diagram) before finally sending the consolidated response back to the client (",(0,t.jsx)(n.strong,{children:"6"}),"), using ",(0,t.jsx)(n.code,{children:"-30!(handle;isError;msg)"})]}),"\n",(0,t.jsxs)(n.p,{children:["Now, we can explore a practical example, but before diving into the practical example shown above, let's first examine how ",(0,t.jsx)(n.strong,{children:"suspending a synchronous message"})," with ",(0,t.jsx)(n.code,{children:"-30!(::)"})," and sending a ",(0,t.jsx)(n.strong,{children:"deferred response"})," via ",(0,t.jsx)(n.code,{children:"-30!(handle;isError;msg)"})," works."]}),"\n",(0,t.jsxs)(n.p,{children:["To do this, we modify the default implementation of  ",(0,t.jsx)(n.code,{children:".z.pg"}),", the message handler for synchronous requests, so that it completes the currently executing callback without immediately responding to the client. The ",(0,t.jsx)(n.code,{children:"-30!(::)"})," command can be used at any point in the execution path of ",(0,t.jsx)(n.code,{children:".z.pg"})," to defer the response. This allows us to initiate some work, let ",(0,t.jsx)(n.code,{children:".z.pg"})," complete without sending a reply, and then explicitly return the response once the workers have finished processing the task."]}),"\n",(0,t.jsxs)(n.p,{children:["We update ",(0,t.jsx)(n.code,{children:".z.pg"})," to print the message handle of the client making the synchronous call, along with the function and its corresponding parameters, to the console. The response is then deferred. This allows us to observe how the client remains blocked while the server processes the function and eventually returns the result."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)// SERVER\nq)\\p 6001\nq).z.pg:{show .z.w;show x;-30!(::)}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)// CLIENT\nq)h:hopen `::6001\nq)h\n5i\nq)h({x+x};4)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)7i\n{x+x}\n4\n\nq)-30!(7i;0b;{x+x}4)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Deferred Response Explained",src:s(38113).A+"",width:"3420",height:"1156"})}),"\n",(0,t.jsxs)(n.p,{children:["The example above should give you a solid understanding of the concept behind deferred responses. Of course, it's a simplified version of how you would use ",(0,t.jsx)(n.code,{children:"-30!"})," in real-world scenarios."]}),"\n",(0,t.jsx)(n.p,{children:"Before exploring a more practical example, let's complete this basic demonstration by showing how to send an error message back to the client. No refactoring is needed, his time, instead of returning a successful result, we will send an error message from the server. Let\u2019s see how that works."}),"\n",(0,t.jsx)(n.p,{children:"We begin by sending the same synchronous request from the client to the server as before. Once the request is sent, the client will again remain blocked, waiting for a response. Meanwhile, the server is free to continue its execution."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLIENT"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-q)//",metastring:"CLIENT",children:"q)h({x+x};4)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Thanks to our customized ",(0,t.jsx)(n.code,{children:".z.pg"})," function, we can observe the connection handle of the process that sent the query, along with the query itself. Now, all that's left is to return an error message by setting the ",(0,t.jsx)(n.code,{children:"isError"})," bollean flag to true (1b) and passing the error message in the form of a string or symbol"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SERVER"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q).z.pg\n{show .z.w; show x; -30!(::)}\nq)7i\n{x+x}\n4\n\nq)-30!(7i;1b;`thisIsAnError)\nq)\n"})}),"\n",(0,t.jsx)(n.p,{children:"The client then receives the response from the server, which in this case is an error. The error message is displayed on the client console."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"'thisIsAnError\n  [0]  h({x+x};4)\n       ^\nq)\n"})}),"\n",(0,t.jsx)(n.p,{children:"One great feature of the Deferred Response in KDB/Q is that it automatically tracks connection handles awaiting a response. If you attempt to send a message to a handle that is not expecting a response, a domain error will be triggered. This behavior is demonstrated in the code snippet below."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)-30!(7i;1b;`thisIsAnError)\n'Handle 7 was not expecting a response msg\n  [0]  -30!(7i;1b;`thisIsAnError)\n          ^\nq)-30!(7i;0b;`noError)\n'Handle 7 was not expecting a response msg\n  [0]  -30!(7i;0b;`noError)\n          ^\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mastering-deferred-response-a-practical-gateway-example",children:"Mastering Deferred Response: A Practical Gateway Example"}),"\n",(0,t.jsxs)(n.p,{children:["Now that we\u2019ve explored the details of deferred response, let\u2019s apply our knowledge to a practical scenario. We\u2019ll build a simple Gateway that handles synchronous queries from a client. This Gateway will forward the client\u2019s query to two worker processes: a Real-time Database (",(0,t.jsx)(n.strong,{children:"RDB"}),") containing intraday trade data and a Historical Database (",(0,t.jsx)(n.strong,{children:"HDB"}),") storing historical data. Once the worker processes evaluate the query, they will return the results to the Gateway, which will aggregate them before sending the final response back to the client. Without further delay, let\u2019s get started!"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This example is an extended, in detailed explained walk through of the example provided by KX ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/kb/deferred-response/",children:"here"})]})}),"\n",(0,t.jsxs)(n.p,{children:["Let's start by looking at the code for the RDB and HDB, as this is the simplest part, it just involves setting up some dummy trade data. We\u2019ll also define a ",(0,t.jsx)(n.code,{children:"getTradeData"})," function that retrieves trade data for a given symbol. In the case of the RDB, we\u2019ll add a date column with today\u2019s date before returning the result. This ensures a consistent schema between the RDB and HDB, making it easier to aggregate the results on the Gateway."]}),"\n",(0,t.jsx)(n.h4,{id:"realtime-database-rdb",children:"Realtime Database RDB"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'  1 // RDB  rdb.q\n  2\n  3 // Set the RDB port to 6000\n  4 system "p 6000";\n  5\n  6 // Create an intraday table for trade data\n  7\n  8 trade:([] time:asc 10?.z.T; sym:10?`AAPL`GOOG`MSFT; price:10?100.; qty:10?1000);\n  9\n 10 // Create a function to retrieve trade data for a specific symbol\n 11 // For consistency, we add a date column set to today\'s date\n 12 getTradeData:{[s] `date xcols update date:.z.D from select from trade where sym=s}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"historical-database-hdb",children:"Historical Database HDB"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'  1 // HDB  hdb.q\n  2\n  3 // Set the HDB port to 6001\n  4 system "p 6001";\n  5\n  6 // Create an intraday table for trade data\n  7\n  8 trade:([] date:asc 20?.z.D-1 2 3;time:asc 20?.z.T; sym:20?`AAPL`GOOG`MSFT; price:20?100.; qty:20?1000);\n  9\n 10 // Create a function to retrieve trade data for a specific symbol\n 11 getTradeData:{[s] select from trade where sym=s}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"gateway",children:"Gateway"}),"\n",(0,t.jsx)(n.p,{children:"Now, let's move on to our Gateway, which is a bit more complex, but don't worry, I will walk you through it step by step."}),"\n",(0,t.jsxs)(n.p,{children:["First, we establish connections to all our worker processes (RDB and HDB) and store these connections in a variable called ",(0,t.jsx)(n.code,{children:"workerHandles"}),". Next, we create an empty dictionary to store results received from the worker processes for each client handle, he handle of the process that sent a query to the Gateway."]}),"\n",(0,t.jsxs)(n.p,{children:["How does this dictionary look in practice? Each entry maps a client handle to a list of tuples. Each tuple consists of two elements ",(0,t.jsx)(n.code,{children:"clientHandle | ((isError;result1);(isError;result2);...;(isError;resultN))"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"isError"})," flag (which we introduced earlier)."]}),"\n",(0,t.jsx)(n.li,{children:"The result, which could either be an error message or actual data."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here's what that structure looks like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"clientHandle1 | ((0b;result1);(0b;result2))\nclientHandle2 | ((1b;result1);(0b;result2))\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or, alternatively as actual KDB/Q dictionary"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)show pending:4 5!(((0b;10);(0b;11));((1b;20);(1b;21)))\n4| 0b 10 0b 11\n5| 1b 20 1b 21\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Next, we define a custom ",(0,t.jsx)(n.code,{children:".z.pg"})," function to handle all incoming synchronous messages. Inside this function, we create a ",(0,t.jsx)(n.code,{children:"remoteFunction"})," that will be sent to the worker processes. This function takes two parameters: the client query and the client handle. The client handle is essential for tracking which client the results belong to."]}),"\n",(0,t.jsxs)(n.p,{children:["The Gateway sends an asynchronous message to each worker handle, invoking the ",(0,t.jsx)(n.code,{children:"remoteFunction"})," with the client handle and client query as arguments. The worker processes, in turn, execute the ",(0,t.jsx)(n.code,{children:"remoteFunction"})," on the worker process, invoking the client function passed by the gateway, and then sends the result back to the Gateway via an asynchronous message."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally, our custom ",(0,t.jsx)(n.code,{children:".z.pg"})," function defers the response using ",(0,t.jsx)(n.code,{children:"-30!(::)"}),", ensuring that the client remains blocked while allowing the Gateway to continue processing other tasks."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Customised .z.pg connection handler for synchronous messages\n.z.pg:{[query]\n        // function definition to be send to worker processes, executing the client query\n        // and sending the result back to the gateway, invoking callback function on GW\n        remoteFunction: {[clntHandle;query]\n                        (neg .z.w)(`callback;clntHandle;@[(0b;)value@; query; {[error] (1b;error)}])\n                        };\n        // send client query to all worker processes\n        neg[workerHandles]@\\:(remoteFunction;.z.w;query);\n        // defer response\n        -30!(::);\n        };\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you've been paying close attention to the ",(0,t.jsx)(n.code,{children:"remoteFunction"}),", you might have noticed an extra ",(0,t.jsx)(n.code,{children:"@"})," inside the ",(0,t.jsx)(n.code,{children:"trap"})," command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"@[(0b;) value@; query; {[error] (1b; error)}]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You might be wondering why this is necessary. Well, remember that KDB/Q always attempts to evaluate expressions whenever possible. If we only had ",(0,t.jsx)(n.code,{children:"(0b;) value"})," this would already be considered an evaluable expression. You can see this in the following example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)(0b;)value\n0b\n.:\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, by adding the additional ",(0,t.jsx)(n.code,{children:"@"}),", we create a projection that waits for another parameter to be passed, effectively delaying the evaluation of the expression until the parameter is provided."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)(0b;)value@\nenlist[0b;]@[.:]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, the final step on our gateway is to implement the callback function that the worker processes will invoke when sending back the result. This callback function takes two arguments: the client handle and the result. It first appends the result to the ",(0,t.jsx)(n.code,{children:"pending"})," dictionary, keeping track of responses received for a particular client. Then, it checks whether the number of received results matches the total number of worker handles, if so, all responses have arrived; otherwise, it continues waiting for the remaining ones."]}),"\n",(0,t.jsxs)(n.p,{children:["Next, the function verifies if an error occurred by summing the error flags. If the sum is zero, no errors were encountered. However, if the sum is greater than or equal to one, it indicates that at least one error was received, setting ",(0,t.jsx)(n.code,{children:"isError"})," to ",(0,t.jsx)(n.code,{children:"1b"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The function then retrieves all results associated with a specific client handle. If an error occurred, it returns the first error message; otherwise, it aggregates the worker responses using the ",(0,t.jsx)(n.code,{children:"raze"})," function. Finally, it sends the result back to the client via the client handle and clears the pending dictionary entry for that client."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// callback function to be called by worker processes when returning result to the gateway\ncallback:{[clientHandle;result]\n        // append current result to the pending results for particular client\n        pending[clientHandle],:enlist result;\n        // check if we already have all expected results for this client\n        if[count[workerHandles]=count pending[clientHandle];\n                // check if any of the responses includes an error\n                isError:0<sum pending[clientHandle][;0];\n                // grab the results: either error string or data\n                result:pending[clientHandle][;1];\n                // return the first error or the reduced result to the client\n                r:$[isError;{first x where 10h=type each x};reduceFunction] result;\n                // send result to client\n                -30!(clientHandle;isError;r);\n                // reset pending results for this client\n                pending[clientHandle]:();\n        ];\n        };\n"})}),"\n",(0,t.jsx)(n.p,{children:"Putting it all together:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'  1 // Gateway  gw.q\n  2\n  3 // Set the Gateway port\n  4 system "p 5999";\n  5\n  6 // Connect to all worker handles, i.e. RDB and HDB\n  7 workerHandles:hopen each 6000 6001;\n  8\n  9 // Dictionary to keep track of results received for each clientHandle\n 10 pending:()!();\n 11\n 12 // function to reduce the results received from the different worker processes. In this case, basic raze\n 13 reduceFunction:raze;\n 14\n 15 // Customised .z.pg connection handler for synchronous messages\n 16 .z.pg:{[query]\n 17         // function definition to be send to worker processes, executing the client query\n 18         // and sending the result back to the gateway, invoking callback function on GW\n 19         remoteFunction: {[clntHandle;query]\n 20                         (neg .z.w)(`callback;clntHandle;@[(0b;)value@; query; {[error] (1b;error)}])\n 21                         };\n 22         // send client query to all worker processes\n 23         neg[workerHandles]@\\:(remoteFunction;.z.w;query);\n 24         // defer response\n 25         -30!(::);\n 26         };\n 27\n 28\n 29 // callback function to be called by worker processes when returning result to the gateway\n 30 callback:{[clientHandle;result]\n 31         // append current result to the pending results for particular client\n 32         pending[clientHandle],:enlist result;\n 33         // check if we already have all expected results for this client\n 34         if[count[workerHandles]=count pending[clientHandle];\n 35                 // check if any of the responses includes an error\n 36                 isError:0<sum pending[clientHandle][;0];\n 37                 // grab the results: either error string or data\n 38                 result:pending[clientHandle][;1];\n 39                 // return the first error or the reduced result to the client\n 40                 r:$[isError;{first x where 10h=type each x};reduceFunction] result;\n 41                 // send result to client\n 42                 -30!(clientHandle;isError;r);\n 43                 // reset pending results for this client\n 44                 pending[clientHandle]:();\n 45         ];\n 46         };\n'})}),"\n",(0,t.jsx)(n.h4,{id:"client",children:"Client"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)h(`getTradeData;`AAPL)                                                                                                 \ndate       time         sym  price    qty                                                                                \n-----------------------------------------                                                                                \n2025.03.09 06:16:08.787 AAPL 63.46716 360                                                                                \n2025.03.09 07:14:17.624 AAPL 23.06385 257                                                                                \n2025.03.09 08:50:31.645 AAPL 94.9975  858                                                                                \n2025.03.09 09:01:27.840 AAPL 43.9081  585                                                                                \n2025.03.10 14:17:41.480 AAPL 8.123546 959                                                                                \n2025.03.11 18:21:54.926 AAPL 15.08133 865                                                                                \n2025.03.11 20:02:15.145 AAPL 15.67317 344                                                                                \n2025.03.11 21:09:39.902 AAPL 70.43314 314                                                                                \n2025.03.12 04:25:17.604 AAPL 19.59907 257                                                                                \n2025.03.12 20:26:20.197 AAPL 69.19531 869\n"})}),"\n",(0,t.jsx)(n.p,{children:"The final step in our example is to launch all the processes, start a client, and test our implementation. Since the Gateway depends on the RDB and HDB, we need to start these processes first. Once they are up and running, we can start the Gateway. Finally, we launch a client and send a synchronous query to the Gateway to see everything in action. Let's do it!"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Deferred Response Example",src:s(21729).A+"",width:"3420",height:"2214"})}),"\n",(0,t.jsx)(n.p,{children:"And that wraps up our advanced IPC training! You're now a master of interprocess communication, at least when it comes to KDB/Q."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Happy coding!"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},39725:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/AsynchronousCallbackTestingCorrect-d883a2031e23bccf34c4aea4d00275a6.png"},58918:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/AsynchronousCallbackTestingIncorrect-2274598e335502bec6741f7b9c9474d4.png"},24140:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/AsynchronousCallbackVariadic-70a8b93a67beecca0109a6ea79b713f2.png"},43823:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/QATestingMeme-bc0b35b7ea54ee3903991d5e65558f07.jpeg"},99955:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/asynchronousCallback-3197916c1dec40ee33acd14cba16af3f.png"},4169:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/asynchronousCallback2-ae2c3ff4ed924fb2d70827d956c52914.png"},76585:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/deferredResponse-84d740fb42e87dac6b0d461003912760.gif"},38113:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/deferredResponse2-5e399ca83279813a9c43161c4df08702.gif"},21729:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/deferredResponseExample-2c05c3bbf930fe50d91f037f0d4cb960.gif"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);