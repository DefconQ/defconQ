"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4690],{273:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=n(4848),s=n(8453);const r={sidebar_position:2},a="KDB Tick Explained: A Walkthrough [PART 2]",o={id:"tutorials/tick2",title:"KDB Tick Explained: A Walkthrough [PART 2]",description:"In my previous tutorial I walked you through all the helper functions you can find in the u.q file of a plain vanilla Tickerplant. I provided a comprehensive overview of the inner workings of these functions and how they interact with each other. It is now time to circle back and continue with our step-by-step examination of the main tick.q file and complete complete our understanding of the Tickerplant. If you'd like to revisit our previous discussions or if you're new to this tutorial, you can access my earlier post here.",source:"@site/docs/tutorials/tick2.mdx",sourceDirName:"tutorials",slug:"/tutorials/tick2",permalink:"/docs/tutorials/tick2",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"KDB Tick Explained: A Walkthrough [PART 1]",permalink:"/docs/tutorials/tick"},next:{title:"Productivity Tools",permalink:"/docs/category/productivity-tools"}},l={},d=[{value:"<code>tick.q</code> - Continued",id:"tickq---continued",level:2},{value:"<code>.u.ld</code>",id:"uld",level:2},{value:"<code>.u.tick</code>",id:"utick",level:2},{value:"<code>.u.endofday</code>",id:"uendofday",level:2},{value:"Connection handles",id:"connection-handles",level:3},{value:"<code>.u.ts</code>",id:"uts",level:2},{value:"Tickerplant Batch mode: <code>.z.ts</code> and <code>.u.upd</code>",id:"tickerplant-batch-mode-zts-and-uupd",level:2},{value:"<code>.z.ts</code>",id:"zts",level:3},{value:"Each-both <code>&#39;</code>",id:"each-both-",level:3},{value:"Namespacing",id:"namespacing",level:3},{value:"Amend",id:"amend",level:3},{value:"<code>.u.upd</code>",id:"uupd",level:3},{value:"Tickerplant Tick mode: <code>.z.ts</code> and <code>.u.upd</code>",id:"tickerplant-tick-mode-zts-and-uupd",level:2},{value:"<code>.z.ts</code>",id:"zts-1",level:3},{value:"<code>.u.upd</code>",id:"uupd-1",level:3},{value:"The Real-Time Database (RDB) Code Explained- <code>r.q</code>",id:"the-real-time-database-rdb-code-explained--rq",level:2},{value:"<code>upd</code>",id:"upd",level:3},{value:"<code>.u.end</code>",id:"uend",level:3},{value:"<code>.u.rep</code>",id:"urep",level:3},{value:"RDB startup",id:"rdb-startup",level:3},{value:"Limitations of KDB/Q Tick",id:"limitations-of-kdbq-tick",level:2},{value:"Tickerplant doesn&#39;t deal with corrupt Tickerplant Log files",id:"tickerplant-doesnt-deal-with-corrupt-tickerplant-log-files",level:3},{value:"Process location: One host only",id:"process-location-one-host-only",level:3},{value:"Unnecessary serialisation of messages",id:"unnecessary-serialisation-of-messages",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"kdb-tick-explained-a-walkthrough-part-2",children:"KDB Tick Explained: A Walkthrough [PART 2]"}),"\n",(0,i.jsxs)(t.p,{children:["In my previous tutorial I walked you through all the helper functions you can find in the ",(0,i.jsx)(t.code,{children:"u.q"})," file of a plain vanilla Tickerplant. I provided a comprehensive overview of the inner workings of these functions and how they interact with each other. It is now time to circle back and continue with our step-by-step examination of the main ",(0,i.jsx)(t.code,{children:"tick.q"})," file and complete complete our understanding of the Tickerplant. If you'd like to revisit our previous discussions or if you're new to this tutorial, you can access my earlier post ",(0,i.jsx)(t.a,{href:"https://defconq.tech/docs/tutorials/tick",children:"here"}),"."]}),"\n",(0,i.jsxs)(t.h2,{id:"tickq---continued",children:[(0,i.jsx)(t.code,{children:"tick.q"})," - Continued"]}),"\n",(0,i.jsxs)(t.p,{children:["The first function definition we encounter in the ",(0,i.jsx)(t.code,{children:"tick.q"})," file is the one of ",(0,i.jsx)(t.code,{children:".u.ld"}),". For simplicity, we ignore the namespace change ",(0,i.jsx)(t.code,{children:"\\d .u"})," and will provide the full compound name of the functions."]}),"\n",(0,i.jsx)(t.h2,{id:"uld",children:(0,i.jsx)(t.code,{children:".u.ld"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.ld"})," is used to create a new Tickerplant Log file and establish a connection to it. It does this by initially verifying the existence of a Tickerplant Log file. If it doesn't exist, a new one is created. Subsequently, it replays the Tickerplant Log file. If an existing Tickerplant Log file was found, the replay will restore the state of the world for all real-time subscribers. If a new file was created, the replay works on an empty file, having no impact. Following this, the function checks the success of the replay and opens a handle to the Tickerplant Log file, returning it. However, if the replay was unsuccessful, it will raise an error, resulting in the Tickerplant aborting. The function ",(0,i.jsx)(t.code,{children:".u.ld"})," is  used within ",(0,i.jsx)(t.code,{children:".u.tick"})," as well as within ",(0,i.jsx)(t.code,{children:".u.endofday"}),"."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["If you aren't familiar with the Tickerplant Log file, I've given a brief explanation of what they are and their purpose in one of my earlier blog posts. Feel free to take a look at it for more details. ",(0,i.jsx)(t.a,{href:"https://defconq.tech/docs/architecture/plain#the-tp-log-file",children:"The Tickerplant Log file"})]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// @param:\tx (date) - the date for which we want to create a Tickerplant Log file\n// @return:\tthe file handle to the Tickerplant Log file for the current day\n.u.ld:{\n        if[not type key .u.L::`$(-10_string .u.L),string x; .[.u.L;();:;()]];\n        .u.i::.u.j::-11!(-2;.u.L);\n        if[0<=type .u.i;-2 (string L)," is a corrupt log. Truncate to length ",(string last .u.i),"and restart";exit 1]\n        hopen .u.L\n        };\n'})}),"\n",(0,i.jsxs)(t.p,{children:["First we need to check for the existence of the Tickerplant Log file. To accomplish this, we must construct the file name. We achieve this by taking the current Tickerplant Log file name stored in ",(0,i.jsx)(t.code,{children:".u.L"})," and converting it to a string. Then, we use the drop operator to eliminate the last 10 characters from the string. This demonstrates how operators can have various overloads. We've previously encountered the drop operator when removing the i-th element from a list, but here we're using it to eliminate the first or last n-elements from a list."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q)string `:sym2023.10.10\n":sym2023.10.10"\nq)-10_string `:sym2023.10.10\n":sym"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Next, we convert the current date contained in variable ",(0,i.jsx)(t.code,{children:"x"})," to a string and append it to the initial Tickerplant Log file name that we acquired earlier. Subsequently, we utilize the double-colon ",(0,i.jsx)(t.code,{children:"::"})," operator to assign this new Tickerplant Log file name to the global variable ",(0,i.jsx)(t.code,{children:".u.L"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).u.L::`$(-10_string .u.L),string x\nq)`$(-10_string `:sym2023.10.10),string 2023.10.11\n`:sym2023.10.11\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We can now use the ",(0,i.jsx)(t.code,{children:"key"})," operator to verify the existence of a file. While the ",(0,i.jsx)(t.code,{children:"key"})," operator is normally used to retrieve the keys of a dictionary or keyed table, it can also be used to to confirm the existence of a variable, file, or directory. When ",(0,i.jsx)(t.code,{children:"key"})," is applied to a variable name or a file path, it will return the variable name or file path if the variable or file exists; otherwise, it will return a null result. In the case of a directory, ",(0,i.jsx)(t.code,{children:"key"})," will return the directory's content if it exists, and nothing if it does not."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's have a look at some examples. We are currently in the directory ",(0,i.jsx)(t.code,{children:"testing"})," in the location ",(0,i.jsx)(t.code,{children:'"/Users/Alexander/repos/testing"'}),". The directory contains a directory named ",(0,i.jsx)(t.code,{children:"folder"}),", two tables ",(0,i.jsx)(t.code,{children:"newTable"})," and ",(0,i.jsx)(t.code,{children:"t"}),", a Tickerplant Log file called ",(0,i.jsx)(t.code,{children:"sym2023.10.10"}),". The directory ",(0,i.jsx)(t.code,{children:"folder"})," contains two more files ",(0,i.jsx)(t.code,{children:"file1.txt"})," and ",(0,i.jsx)(t.code,{children:"file2.txt"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q)\\pwd\n"/Users/Alexander/repos/testing"\nq)\\ls\n"folder"\n"newTable"\n"sym2023.10.10"\n,"t"\n"test.txt"\nq)a:9\nq)key `a\n`a\nq)key `b\nq)key `:sym2023.10.10\n`:sym2023.10.10\nq)key `:sym2023.10.11\nq)key `:folder\n`file1.txt`file2.txt\nq)\\ls folder\n"file1.txt"\n"file2.txt"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["If the Tickerplant Log file doesn't exist, and nothing is returned, ",(0,i.jsx)(t.code,{children:"type"})," will return 0b. We use ",(0,i.jsx)(t.code,{children:"not"})," to create the logical complement (negation) to return ",(0,i.jsx)(t.code,{children:"1b"})," true if the file doesn't exist. If the file exist and the file name is returned as symbol, ",(0,i.jsx)(t.code,{children:"type"})," will return ",(0,i.jsx)(t.code,{children:"-11h"}),", the type of a symbol atom, and ",(0,i.jsx)(t.code,{children:"not"})," will thus return ",(0,i.jsx)(t.code,{children:"0b"}),", false."]}),"\n",(0,i.jsxs)(t.p,{children:["If the Tickerplant Log file doesn't exist, and the if-statement evaluates to ",(0,i.jsx)(t.code,{children:"true"}),", we use ",(0,i.jsx)(t.code,{children:".[.u.L;();:;()]"})," to create an empty Tickerplant Log file. You might be curious about what that expression does, and I'm going to share a neat trick. However, this should be used with caution. If you have some knowledge of the history of the Q programming language, you're aware that Q is based on ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/K_programming_language",children:"K"})," (which is the foundation of KDB). In a Q console, you can access the K mode and inspect the underlying K code of a Q function. Let me demonstrate this for you."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).Q.dpft\nk){[d;p;f;t;s]if[` in f,c:!+r:`. . `\\:t;'`domain];if[~f in c;'f];i:<t f;r:+enxs[$;d;r;s];{[d;t;i;u;x]@[d;x;:;u t[x]i]}[d:par[d;p;t];r;i;]'[(::;`p#)f=c;c];@[d;`.d;:;f,c@&~f=c];t}[;;;;`sym]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As evident, K code can be even less readable than Q and quite complex. Therefore, I strongly discourage attempting to write K code, especially since ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/basics/exposed-infrastructure/",children:"KX advises against it"}),", as certain functionality might not be guaranteed. However, for simple functions and inspection purposes only, we can take a peek. Let's explore how the ",(0,i.jsx)(t.code,{children:"set"})," function is implemented."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)set\nk){$[@x;.[x;();:;y];-19!((,y),x)]}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["When we examine the middle part of the ",(0,i.jsx)(t.code,{children:"set"})," function's implementation, we notice that the code is similar of how we create an empty Tickerplant Log file. In essence, ",(0,i.jsx)(t.code,{children:".[.u.L;();:;()]"}),"  accomplishes precisely that. If we replace ",(0,i.jsx)(t.code,{children:"x"})," with ",(0,i.jsx)(t.code,{children:".u.L"}),", the file path to the Tickerplant Log file and ",(0,i.jsx)(t.code,{children:"y"})," with the empty list ",(0,i.jsx)(t.code,{children:"()"}),", we can observe that we are essentially generating an empty file."]}),"\n",(0,i.jsxs)(t.p,{children:["The last thing that is left to do, is to replay the Tickerplant Log file, ensure that it's not corrupted, open a connection handle to it and return it. We replay the Tickerplant Log file with ",(0,i.jsx)(t.code,{children:"-11!"})," and the ",(0,i.jsx)(t.code,{children:"-2"})," option. The ",(0,i.jsx)(t.code,{children:"-2"})," option can be used to replay corrupted Tickerplant Log files. In case the Tickerplant Log file is corrupt, it will return the number of valid chunks in the Tickerplant Log file and the corresponding length of them. If the Tickerplant Log isn't corrupt, it simply returns the number of valid chunks."]}),"\n",(0,i.jsxs)(t.p,{children:["We proceed by replaying the Tickerplant Log file using the ",(0,i.jsx)(t.code,{children:"-2"})," option and assigning the number of valid chunks to the global variables ",(0,i.jsx)(t.code,{children:".u.i"})," and ",(0,i.jsx)(t.code,{children:".u.j"}),". We then verify whether the Tickerplant Log file was corrupt or not. If the Tickerplant Log file was corrupt, using ",(0,i.jsx)(t.code,{children:"-11!(-2;logFile)"})," will return the number of valid chunks and their respective sizes. Therefore, if we receive a list as the return value, the type will be positive (as a list always has a positive type value). In such a case, we throw an error indicating that the Tickerplant Log file needs to be truncated to the valid part and then abort. However, if the Tickerplant Log file wasn't corrupt, we establish a connection to it using ",(0,i.jsx)(t.code,{children:"hopen"})," and return this connection handle."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if[0<=type .u.i;-2 (string L)," is a corrupt log. Truncate to length ",(string last .u.i),"and restart";exit 1]\nhopen .u.L\n'})}),"\n",(0,i.jsx)(t.h2,{id:"utick",children:(0,i.jsx)(t.code,{children:".u.tick"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.tick"})," is the first function that is executed when the Tickerplant starts up. It proceeds by first invoking ",(0,i.jsx)(t.code,{children:".u.init"})," to set up ",(0,i.jsx)(t.code,{children:".u.t"})," and ",(0,i.jsx)(t.code,{children:".u.w"}),". Following that, it ensures that all tables defined in the schema file have ",(0,i.jsx)(t.code,{children:"time and sym"})," as their first columns. If this condition isn't met, the Tickerplant will raise an error and terminate. As a subsequent step, the ",(0,i.jsx)(t.code,{children:"g"})," (grouped) attribute is applied to the sym column of each table, a measure taken for performance enhancement, resulting in quicker query times for user queries against the Real-time Database (RDB)."]}),"\n",(0,i.jsxs)(t.p,{children:["Afterwards, the function initializes ",(0,i.jsx)(t.code,{children:".u.d"})," with the current date and then concludes by executing ",(0,i.jsx)(t.code,{children:".u.ld"})," to create the Tickerplant Log file and establish a connection to the file."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// @param:\tx (String) - The name of the schema file containing the definition of all tables, without file ending \n// @param:\ty (String) - The path to the directory where the Tickerplant Log and HDB should be stored\n// @return:\tNone\n.u.tick:{[x;y]\n        .u.init[];\n        if[not min(`time`sym~2#key flip value@)each .u.t;\'`timesym];\n        @[;`sym;`g#] each .u.t;\n        .u.d:.z.D;\n        if[.u.l::count y;.u.L::`$":",y,"/",x,10#".";.u.l::.u.ld[.u.d]]\n        };\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Even though ",(0,i.jsx)(t.code,{children:".u.tick"})," seems to be a long function with quite a lot going on, it's actually relatively simple and straight forward. After the invocation of ",(0,i.jsx)(t.code,{children:".u.init"}),", which initializes ",(0,i.jsx)(t.code,{children:".u.t"})," and ",(0,i.jsx)(t.code,{children:".u.w"}),", it proceeds to validate that all tables defined in the schema file ",(0,i.jsx)(t.code,{children:"sym.q"})," indeed feature ",(0,i.jsx)(t.code,{children:"time"})," and ",(0,i.jsx)(t.code,{children:"sym"})," columns as their initial columns. Let's delve into the code to better understand how this is accomplished."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// verify that each table has a time and sym column as their first columns\nif[not min (`time`sym~2#key flip value@)each .u.t;'`timesym]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Let's break this code further down: We first iterate over every table defined in ",(0,i.jsx)(t.code,{children:".u.t"})," using the ",(0,i.jsx)(t.code,{children:"each"})," iterator. Within the parenthesis we then apply ",(0,i.jsx)(t.code,{children:"value"})," in order to obtain the actual content of each table. Remember, ",(0,i.jsx)(t.code,{children:".u.t"})," only contains the symbol names of all tables. Using ",(0,i.jsx)(t.code,{children:"value"})," we can actually retrieve the data stored in a variable. We then ",(0,i.jsx)(t.code,{children:"flip"})," the table transforming the table into a dictionary."]}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsx)(t.p,{children:"A table is essentially a flipped column dictionary and is stored as such. A column dictionary is a dictionary where each key in the dictionary has the same number of elements as their corresponding values, making the column dictionary rectangular. When we flip such a column dictionary, it transforms into a table. However, it's important to note that KDB/Q doesn't actually transpose the data; it merely marks the data as a table. By keeping the data stored as lists, KDB/Q minimizes memory usage and enhances performance by allowing vectorized operations. This also simplifies the process of storing the table to disk. If we examine the internal representation of a table, we can observe that it is, in fact, a flipped column dictionary."}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)0N!flip `key1`key2`key3!(`valueA`valueB`valueC;`valueX`valueY`valueZ;`E`F`G)\n+`key1`key2`key3!(`valueA`valueB`valueC;`valueX`valueY`valueZ;`E`F`G)\nkey1   key2   key3\n------------------\nvalueA valueX E\nvalueB valueY F\nvalueC valueZ G\n"})}),(0,i.jsxs)(t.p,{children:["Note: The ",(0,i.jsx)(t.code,{children:"+"})," operator is the K symbol for the Q ",(0,i.jsx)(t.code,{children:"flip"})," operator"]})]}),"\n",(0,i.jsxs)(t.p,{children:["After transposing the table into a dictionary, we extract the keys using the ",(0,i.jsx)(t.code,{children:"key"})," operator and select the first two of them. These two keys are then compared with the symbol list ",(0,i.jsx)(t.code,{children:"time`sym"})," using the equality operator ",(0,i.jsx)(t.code,{children:"~"}),". If there is a match, the result is ",(0,i.jsx)(t.code,{children:"1b"}),". This process is repeated for all tables, resulting in a boolean vector that contains ",(0,i.jsx)(t.code,{children:"1b"})," for tables with ",(0,i.jsx)(t.code,{children:"time"})," and ",(0,i.jsx)(t.code,{children:"sym"})," as their first columns and ",(0,i.jsx)(t.code,{children:"0b"})," for tables that don't meet this criteria. By applying the ",(0,i.jsx)(t.code,{children:"min"})," function to this boolean vector, we can determine if all tables have ",(0,i.jsx)(t.code,{children:"time"})," and ",(0,i.jsx)(t.code,{children:"sym"})," as their first columns. If at least one table does not meet this condition, the ",(0,i.jsx)(t.code,{children:"min"})," function will return ",(0,i.jsx)(t.code,{children:"0b"}),", resulting in an error being thrown."]}),"\n",(0,i.jsxs)(t.p,{children:["Next, we add the grouped g attribute to the sym column of each table. While the Tickerplant holds no or little data in memory, depending on the mode it runs in, this attribute will be passed to all real-time subscribers when they subscribe to a table. This will ultimately enhance the performance of user queries. Using the apply operator ",(0,i.jsx)(t.code,{children:"@"})," we create a projection applying the grouped ",(0,i.jsx)(t.code,{children:"g"})," attribute to the ",(0,i.jsx)(t.code,{children:"sym"})," column. Finally we iterate over this projection for every table in the ",(0,i.jsx)(t.code,{children:".u.t"})," list."]}),"\n",(0,i.jsxs)(t.p,{children:["Following that, we set the global variable ",(0,i.jsx)(t.code,{children:".u.d"})," to the current date, which is obtained using ",(0,i.jsx)(t.code,{children:".z.D"}),". Finally, we invoke ",(0,i.jsx)(t.code,{children:".u.ld"})," to generate a new Tickerplant Log file and establish a connection to it. In this process, we first validate whether the path to the TickerplantP Log file is defined. If it is, we create a temporary Tickerplant Log file name with the format ",(0,i.jsx)(t.code,{children:":pathToLogFile/filename........."})," by appending ten dots ",(0,i.jsx)(t.code,{children:"."})," at the end of the file name. These dots serve as a temporary placeholder for the actual date, which will be appended to the Tickerplant Log filename during the execution of ",(0,i.jsx)(t.code,{children:".u.ld"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"uendofday",children:(0,i.jsx)(t.code,{children:".u.endofday"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:".u.endofday"})," function has three essential tasks:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["It initiates the execution of ",(0,i.jsx)(t.code,{children:".u.end"}),", which sends an asynchronous message to all real-time subscribers, thereby triggering their respective end-of-day functions."]}),"\n",(0,i.jsxs)(t.li,{children:["It increments the Tickerplant's current date, which is stored in the ",(0,i.jsx)(t.code,{children:".u.d"})," global variable, by one to account for the start of the new day."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:".u.endofday"})," safely closes the connection to the current Tickerplant Log file, generates a new Tickerplant Log file for the new date, and establishes a connection to the newly created file."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:".u.endofday"})," function is called from within the ",(0,i.jsx)(t.code,{children:".u.ts"})," function, but only if it's past midnight and we started a new day."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @params: None\n// @return: None\n.u.endofday:{\n        .u.end[.u.d];\n        .u.d+:1;\n        if[.u.l;hclose .u.l;.u.l::0(`.u.ld;.u.d)];\n        };\n"})}),"\n",(0,i.jsx)(t.h3,{id:"connection-handles",children:"Connection handles"}),"\n",(0,i.jsxs)(t.p,{children:["The majority of the code in ",(0,i.jsx)(t.code,{children:".u.endofday"})," is straightforward. We start by calling ",(0,i.jsx)(t.code,{children:".u.end"})," with the current date and then increment the current date by one. The final step involves closing the handle to the current Tickerplant Log file (if it exists) and calling ",(0,i.jsx)(t.code,{children:".u.ld"}),", which creates a new Tickerplant Log file, opens a handle to it, and returns the handle. However, when calling ",(0,i.jsx)(t.code,{children:".u.ld"}),", we encounter a new concept. We invoke ",(0,i.jsx)(t.code,{children:".u.ld"})," using one of the three permanent ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/basics/handles/",children:"system handles"}),": ",(0,i.jsx)(t.code,{children:"0"})," is the system handle for the console, ",(0,i.jsx)(t.code,{children:"1"})," is the system handle for ",(0,i.jsx)(t.code,{children:"stdout"}),", and ",(0,i.jsx)(t.code,{children:"2"})," is the system handle for ",(0,i.jsx)(t.code,{children:"stderr"}),". Let's explore how we can use the system handle ",(0,i.jsx)(t.code,{children:"0"})," to execute a function."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// We first define a simple function\nq)f:{x+x}\n// We can now invoke the function by using the system handle 0\nq)0(`f;2)\n4\n"})}),"\n",(0,i.jsx)(t.h2,{id:"uts",children:(0,i.jsx)(t.code,{children:".u.ts"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.ts"})," is responsible for verifying whether we have reached the end of the day and passed midnight. It is called from within ",(0,i.jsx)(t.code,{children:".z.ts"}),", which is the system function executed at regular intervals by a timer."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// @param:\tx (date) - the current date (.z.D is passed)\n// @return:\tNone\n.u.ts:{[x]\n        if[.u.d<x;\n          if[.u.d<x-1; system "t 0";\'"more than one day?"];\n          .u.endofday[]];\n        };\n'})}),"\n",(0,i.jsxs)(t.p,{children:["First, we check if ",(0,i.jsx)(t.code,{children:".u.d"}),", the current date for which the Tickerplant publishes data for, is less than the current date, represented by ",(0,i.jsx)(t.code,{children:".z.D"})," passed as ",(0,i.jsx)(t.code,{children:"x"}),". If this condition is satisfied, we ensure that we've published data for only one day and not more than that by comparing ",(0,i.jsx)(t.code,{children:".u.d"})," to ",(0,i.jsx)(t.code,{children:"x-1"}),", which is the date preceding the current one. If we indeed only published data for one day, we proceed to invoke ",(0,i.jsx)(t.code,{children:".u.endofday"}),". However, if the first condition is not met, meaning we haven't reached the end of the day yet, we don't take any action. In such a case, ",(0,i.jsx)(t.code,{children:".u.ts"})," will be invoked again at the next timer interval, and the checks will be performed again."]}),"\n",(0,i.jsxs)(t.p,{children:["We're now approaching the final section of the Tickerplant code, and we'll encounter different behaviors depending on the mode in which the Tickerplant is running. The Tickerplant can operate in two modes: batch mode and tick mode. In batch mode, incoming data is accumulated for ",(0,i.jsx)(t.code,{children:"N"})," milliseconds and then dispatched to all real-time subscribers. In contrast, tick mode delivers incoming data immediately, with minimal delay. Let's delve deeper into these two modes:"]}),"\n",(0,i.jsxs)(t.h2,{id:"tickerplant-batch-mode-zts-and-uupd",children:["Tickerplant Batch mode: ",(0,i.jsx)(t.code,{children:".z.ts"})," and ",(0,i.jsx)(t.code,{children:".u.upd"})]}),"\n",(0,i.jsxs)(t.p,{children:["In batch mode, the timer interval for invoking the system function ",(0,i.jsx)(t.code,{children:".z.ts"})," is established at startup through the ",(0,i.jsx)(t.code,{children:"-t"})," flag. In this mode, incoming data is temporarily stored in memory for ",(0,i.jsx)(t.code,{children:"N"})," milliseconds, and then it is published when the timer triggers after this interval. We check whether a timer interval was set or not using an ",(0,i.jsx)(t.code,{children:"if"})," statement and the system command ",(0,i.jsx)(t.code,{children:'system "t"'}),". If this condition evaluates to ",(0,i.jsx)(t.code,{children:"true"}),", we can determine that we are in batch mode and subsequently define ",(0,i.jsx)(t.code,{children:".z.ts"})," and ",(0,i.jsx)(t.code,{children:".u.upd"})," accordingly."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if[sytem "t";\t// If true, we run in the batch mode\n'})}),"\n",(0,i.jsx)(t.h3,{id:"zts",children:(0,i.jsx)(t.code,{children:".z.ts"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @param:\tx (timestamp) - .z.ts is invoked with the current timestamp\n// @return:\tNone\n.z.ts:{\n\t.u.pub'[.u.t;value each .u.t];\n        @[`.;.u.t;@[;`sym;`g#]0#];\n        .u.i::.u.j;\n        .u.ts[.z.D];\n\t};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Initially, we publish all the updates that have been batched in memory to the real-time subscribers. This is accomplished by utilizing ",(0,i.jsx)(t.code,{children:".u.pub"})," along with ",(0,i.jsx)(t.code,{children:"each-both"})," and a pair of list comprising table names and their corresponding data."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".u.pub'[.u.t;value each .u.t];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The expression ",(0,i.jsx)(t.code,{children:"value each .u.t"})," generates a list of data, with each item representing the complete content of a specific table. Since ",(0,i.jsx)(t.code,{children:".u.t"})," holds the list of all available tables in our Tickerplant, the expression ",(0,i.jsx)(t.code,{children:"[.u.t;value each .u.t]"})," forms a pair of lists that include all table names and their respective data. By using ",(0,i.jsx)(t.code,{children:"each-both"})," along with the dyadic (two-parameter) function ",(0,i.jsx)(t.code,{children:".u.pub"}),", we can proceed to publish each table and its associated data to the real-time subscribers."]}),"\n",(0,i.jsxs)(t.h3,{id:"each-both-",children:["Each-both ",(0,i.jsx)(t.code,{children:"'"})]}),"\n",(0,i.jsxs)(t.p,{children:["Let's have a closer look how ",(0,i.jsx)(t.code,{children:"each-both"})," works:\nAccording to ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/6_Functions/#672-each",children:"Q for Mortals"})," ",(0,i.jsxs)(t.em,{children:["The iterator Each ",(0,i.jsx)(t.code,{children:"'"})," modifies a binary function (operator, keyword) to apply pairwise to corresponding list items."]})," The following examples should illustrate this behavior"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q)0N!(`One`Two`Three),\'(1;2;3)\n((`One;1);(`Two;2);(`Three;3))\n`One   1\n`Two   2\n`Three 3\nq)("abc"; "uv"),\'("de"; "xyz")\n"abcde"\n"uvxyz"\n'})}),"\n",(0,i.jsx)(t.h3,{id:"namespacing",children:"Namespacing"}),"\n",(0,i.jsxs)(t.p,{children:["Next we use ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/amend/",children:"amend-at"})," to clear the contents of the tables in memory. We do this by leveraging the fact that in KDB/Q ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/12_Workspace_Organization/",children:"namespacing"})," is implemented with dictionaries. Consequently, we can directly access the root namespace, using our table names as keys, to retrieve or modify the content of the tables."]}),"\n",(0,i.jsxs)(t.p,{children:["Assume we have defined the tables trade and quote, a variable a and a function f in our current KDB/Q process. ",(0,i.jsx)(t.code,{children:"key `."})," will then show the content of the root namespace"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)key `.\n`quote`trade`a`f\nq)@[`.;`trade`qutote]\n+`time`sym`price`size!(`timespan$();`symbol$();`float$();`int$())\n+`time`sym`bid`ask`bsize`asize!(`timespan$();`symbol$();`float$();`float$();`..\nq)a\n1\nq)f\n{x+x}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"amend",children:"Amend"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/amend/",children:"amend-at"})," operator is highly practical for making modifications at specific indices within data structures. This functionality extends to both simple and nested indexes, depending on the operator being used. For instance, if we wish to replace particular characters in a string, we can employ the ",(0,i.jsx)(t.code,{children:"amend @"})," operator along with the unary function ",(0,i.jsx)(t.code,{children:"upper"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q)@["alexander";0 2 4 6 8;upper]\n"AlExAnDeR\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Combining this newly acquired knowledge with the knowledge about namespaces, we can create an expression that deletes the content of all tables and applies the grouped ",(0,i.jsx)(t.code,{children:"g"})," attribute to the ",(0,i.jsx)(t.code,{children:"sym"})," column of each table."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"@[`.;.u.t;@[;`sym;`g#]0#]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The expression above accesses the root namespace to fetch the content of all tables, removes all rows with ",(0,i.jsx)(t.code,{children:"0#"}),", assigns the grouped ",(0,i.jsx)(t.code,{children:"g"})," attribute to the ",(0,i.jsx)(t.code,{children:"sym"})," column, and subsequently replaces each table with an empty one using their corresponding table names."]}),"\n",(0,i.jsxs)(t.p,{children:["We proceed by setting the global variable ",(0,i.jsx)(t.code,{children:".u.j"})," to the value of ",(0,i.jsx)(t.code,{children:".u.i"}),", updating the number of messages stored in the Tickerplant Log file, and then calling ",(0,i.jsx)(t.code,{children:".u.ts"})," with the current date to check if midnight has been reached."]}),"\n",(0,i.jsx)(t.h3,{id:"uupd",children:(0,i.jsx)(t.code,{children:".u.upd"})}),"\n",(0,i.jsxs)(t.p,{children:["We now define ",(0,i.jsx)(t.code,{children:".u.upd"})," for the case the timer is on startup and we run in batch mode. This function differs based on whether a timer was set or not. When a timer is configured, we publish all incoming messages within the ",(0,i.jsx)(t.code,{children:".z.ts"})," system function rather than within ",(0,i.jsx)(t.code,{children:".u.upd"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:".u.upd"})," function is triggered by the Feedhandler whenever it publishes data to the Tickerplant. It begins by verifying whether the first column of the incoming data is of type time. If it isn't, the function prefixes the current timestamp to the incoming records. Subsequently, it inserts the data into the corresponding table specified within the Tickerplant, and it persists these newly arrived messages to the Tickerplant Log file. This log file serves the purpose of data playback, allowing for the recreation of the state of the world at any given point in time. Lastly, ",(0,i.jsx)(t.code,{children:".u.upd"})," increments the message counter ",(0,i.jsx)(t.code,{children:".u.j"})," by 1. It's worth noting that ",(0,i.jsx)(t.code,{children:".u.j"})," maintains a record of the total number of messages received, encompassing those saved to the Tickerplant Log file and those held in memory."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["When operating in batch mode, ",(0,i.jsx)(t.code,{children:".u.upd"})," refrains from immediately publishing messages to the real-time subscriber. Instead, this action occurs when triggered by a timer, invoked by ",(0,i.jsx)(t.code,{children:".z.ts"}),"."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// @param:\tx (symbol) - the table name of the data published by the Feedhandler\n// @param:\ty (data)   - the data to be published. This can be in form of a single record or a list of records\n// @return:\tNone\n.u.upd can handle both, single record updates as well as multiple/bulk records updates\nExample:\nSingle record update:           .u.upd[`trade;(08:00:00;`GOOG;123.4;1000)]\nMultiple record update:         .u.upd[`trade;(08:30:00.000 08:30:00.001;`MSFT`AAPL;320.4 180.9;100 250)]\n.u.upd:{[t;x]\n        if[not -16=type first first x;\n                if[.u.d<"d"$a:.z.P;.z.ts[]];\n                a:"n"$a;\n                x:$[0>type first x;a,x;(enlist(count first x)#a),x];\n        ];\n        t insert x;\n        if[.u.l;.u.l enlist (`upd;t;x);.u.j+:1];\n        };\n'})}),"\n",(0,i.jsx)(t.p,{children:"There's a lot happening, but it's fairly straightforward. Let's break it down line by line and understand its functionality."}),"\n",(0,i.jsxs)(t.p,{children:["First, we verify the data type of the initial element in the incoming data to be of type 16 (timespan). As ",(0,i.jsx)(t.code,{children:".u.upd"})," manages updates for both single and multiple records simultaneously, the incoming data could be either a single row or multiple rows. If it's a single row, the first element is an atom, while in the case of multiple rows, it's a list. To ensure accurate type comparison, we need to apply the ",(0,i.jsx)(t.code,{children:"first"})," function twice for obtaining a single element."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"if[not -16=type first first x;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If the ",(0,i.jsx)(t.code,{children:"if-statement"})," evaluates to true, and the incoming data does not contain a time column, we examine if the Tickerplant's date is earlier than the current date. We derive the present date from ",(0,i.jsx)(t.code,{children:".z.P"}),", capturing the current date and time and storing it in variable ",(0,i.jsx)(t.code,{children:"a"}),". If it's earlier, we trigger ",(0,i.jsx)(t.code,{children:".z.ts"}),", responsible for publishing the data in memory and calling the end-of-day function. If the Tickerplant date is not preceding the current date, indicating that we're within the same day, we proceed by converting the present date and timespan into a timespan datatype to obtain the current timespan. This will serve as the Tickerplant time, indicating when the record was received."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if[.u.d<"d"$a:.z.P;.z.ts[]];\na:"n"$a;\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Next, we use the conditional operator ",(0,i.jsx)(t.code,{children:"$"})," to assess whether the initial element of the received record is a single atom (negative types are atoms, and positive types are lists) or a list."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"x:$[0>type first x;a,x;(enlist(count first x)#a),x];\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Case 1"}),": ",(0,i.jsx)(t.code,{children:"0>type first x"})," evaluates to ",(0,i.jsx)(t.code,{children:"true"})," meaning we received a single record and the first element is an atom.\nWe prepend the current timespan to the single record we received, and this updated record is stored in the variable ",(0,i.jsx)(t.code,{children:"x"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"a,x\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Case 2"}),": We've received multiple records, which means we need to create a list of timespans with the same length as the number of records we've received.\nFirst, we use ",(0,i.jsx)(t.code,{children:"count"})," to identify the number of records received. Then, we create a list of timespans, consisting of ",(0,i.jsx)(t.code,{children:"count first x"})," copies of the current timespan, ",(0,i.jsx)(t.code,{children:"a"}),". To prepend this list to another list, we need to convert it into a singleton list (a list containing one element that is a list itself). Otherwise, the elements would be individually prepended rather than as one unified list."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)1 2 3,((4 5 6);(7 8 9))\n1\n2\n3\n4 5 6\n7 8 9\nq)enlist[1 2 3],((4 5 6);(7 8 9))\n1 2 3\n4 5 6\n7 8 9\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Subsequently, we prepend the singleton list of timespans to the received records for the bulk update. Eventually, this updated set of records is reassigned to the variable ",(0,i.jsx)(t.code,{children:"x"}),". These modified records are stored in the Tickerplant memory."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"(enlist(count first x)#a),x\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Up to this point, we were contained within the initial ",(0,i.jsx)(t.code,{children:"if"})," statement block. Now, we exit this statement. The first column of the records that are to be inserted now holds timespan values. These values could be the ones sent by the Feedhandler or, in cases where no timespan value was provided, they hold the timespan recorded by the Tickerplant."]}),"\n",(0,i.jsxs)(t.p,{children:["We proceed to insert the received records into their respective tables in memory and store them in the Tickerplant Log file, assuming the file exists. After verifying that there is a handle to the Tickerplant Log file,we form a ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/wp/parse-trees/",children:"parse tree"}),", including the function name for when the Tickerplant Log file is replayed as the first element, the table name for the stored data as the second element, and the data itself as the third element. This is only executed if a Tickerplant Log file is confirmed to exist."]}),"\n",(0,i.jsxs)(t.p,{children:["We then use ",(0,i.jsx)(t.code,{children:"enlist"})," and the Tickerplant Log file handle ",(0,i.jsx)(t.code,{children:".u.l"})," to append the records to the Tickerplant Log file. When a process replays the Tickerplant Log file,  defined as first element in the parse tree, the  will be invoked with ",(0,i.jsx)(t.code,{children:"t"})," and  ",(0,i.jsx)(t.code,{children:"x"}),". Finally we increase ",(0,i.jsx)(t.code,{children:".u.j"})," by 1."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"t insert x;\nif[.u.l;.u.l enlist (`upd;t;x);.u.j+:1];\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["For the Tickerplant Log file replay to work, the dyadic function ",(0,i.jsx)(t.code,{children:"upd"})," as well the schemas of all tables present in the Tickerplant Log file have to be defined first. A simple example of ",(0,i.jsx)(t.code,{children:"upd"})," would be ",(0,i.jsx)(t.code,{children:"insert"})," as defined in the Real-time Database (RDB). You can obtain the table schemas from the schema file ",(0,i.jsx)(t.code,{children:"sym.q"})]})}),"\n",(0,i.jsxs)(t.p,{children:["This concludes the definition of ",(0,i.jsx)(t.code,{children:".u.upd"}),". Now that we've defined both .z.ts and .u.upd for the Tickerplant when running in batch mode based on a predefined timer, let's shift our focus to the Tickerplant publishing every incoming record as it arrives."]}),"\n",(0,i.jsxs)(t.h2,{id:"tickerplant-tick-mode-zts-and-uupd",children:["Tickerplant Tick mode: ",(0,i.jsx)(t.code,{children:".z.ts"})," and ",(0,i.jsx)(t.code,{children:".u.upd"})]}),"\n",(0,i.jsx)(t.p,{children:"As explained previously, if a Tickerplant runs in tick mode, it will publish the incoming data straight to all real-time subscribers. Additionally, a timer will verify every second whether we reached the end of the day or not."}),"\n",(0,i.jsxs)(t.p,{children:["We first verify that there was no timer set and if this is true, we know that we should publish all incoming data to all real-time subscriber as soon as it arrives. However, we still have to set a timer to invoke ",(0,i.jsx)(t.code,{children:".z.ts"})," and verifiy if we have reached the end of the day or not. We do this by using the ",(0,i.jsx)(t.code,{children:"system"})," command, setting the interval to invoke the timer to 1 second."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if[not system "t";system "t 1000";\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In the next step, we define ",(0,i.jsx)(t.code,{children:".z.ts"})," for the case we run in tick mode."]}),"\n",(0,i.jsx)(t.h3,{id:"zts-1",children:(0,i.jsx)(t.code,{children:".z.ts"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".z.ts"})," is the system function that will be invoked on each timer interval defined with ",(0,i.jsx)(t.code,{children:'system "t N"'}),", where ",(0,i.jsx)(t.code,{children:"N"})," is the interval in milliseconds. Given that we publish all incoming data as soon as it arrives, the only purpose of ",(0,i.jsx)(t.code,{children:".z.ts"})," is to invoke ",(0,i.jsx)(t.code,{children:".u.ts"})," which verifies whether we are past midnight or not."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".z.ts"})," will be invoked every ",(0,i.jsx)(t.code,{children:"N"})," milliseconds and the current timestamp is passed as only argument:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q).z.ts:{show x}\nq)\\t 1000\nq)2023.11.11D16:40:30.981221000\n2023.11.11D16:40:31.981221000\n2023.11.11D16:40:32.981221000\n2023.11.11D16:40:33.981221000\n\\t 0\nq).z.p\n2023.11.11D16:40:49.621176000\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The definition of ",(0,i.jsx)(t.code,{children:".z.ts"})," is hence straightforward: we invoke ",(0,i.jsx)(t.code,{children:".u.ts"})," with the current date ",(0,i.jsx)(t.code,{children:".z.D"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// @param:\tx (timestamp) - the current timestamp, .z.P\n// @return:\tNone\n.z.ts:{.u.ts[.z.D]}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"uupd-1",children:(0,i.jsx)(t.code,{children:".u.upd"})}),"\n",(0,i.jsxs)(t.p,{children:["Given that there is no timer set on startup and our Tickerplant runs in tick mode, we will publish all incoming data as soon as it is received by the Tickerplant to achieve the lowest latency possible. The following actions are performed by ",(0,i.jsx)(t.code,{children:".u.upd"}),": It first calls ",(0,i.jsx)(t.code,{children:".u.ts"})," to verify whether we reached the end of day or not and the end of day actions need to be performed. The function then checks if the incoming records contain a timespan as first column; if not, it prefixes them with the current timespan. Subsequently, it publishes all records to real-time subscribers, writes them to the Tickerplant Log file, and increases the overall message count, ",(0,i.jsx)(t.code,{children:".u.i"}),", by one."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// @param:\tx (symbol) - the table name of the data published by the Feedhandler\n// @param:\ty (data)   - the data to be published. This can be in form of a single record or a list of records\n// @return:\tNone\n.u.upd:{[t;x]\n        .u.ts "d"$a:.z.P;\n        if[not -16=type first first x;\n                a:"n"$a;\n                x:$[0>type first x;a,x;(enlist (count first x)#a),x]];\n        f:key flip value t;\n        .u.pub[t;$[0>type first x;enlist f!x;flip f!x]];\n        if[.u.l;.u.l enlist (`upd;t;x);.u.i+:1];\n        };\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The initial section of the ",(0,i.jsx)(t.code,{children:".u.upd"})," definition mirrors the one we've previously discussed. First, the current timestamp is stored in the local variable ",(0,i.jsx)(t.code,{children:"a"}),", which will serve as the Tickerplant timestamp. Then, this timestamp is converted to a date, and ",(0,i.jsx)(t.code,{children:".u.ts"})," is called to confirm whether we've moved past midnight and require the execution of the end-of-day function."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'.u.ts "d"$a:.z.P;\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Similar to the previous process, we check if the incoming data's first column is a timestamp. If not, the current timestpan is prepended to the data. This involves converting the variable ",(0,i.jsx)(t.code,{children:"a"}),"\u2014holding the present timestamp\u2014to a timespan. Using the conditional operator ",(0,i.jsx)(t.code,{children:"$"}),", we distinguish between a single record or a bulk update to adapt the data. A single record receives a singular atom timespan as a prefix, while a bulk update generates a list of timespans, matching the number of received records, and applies it as a prefix."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if[not -16=type first first x;\n\ta:"n"$a;\n\tx:$[0>type first x;a,x;(enlist (count first x)#a),x]];\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The final segment of this function distinguishes itself from the previous definition as it immediately publishes the records upon arrival. It involves obtaining the column names of the received data by flipping the target table to a dictionary format. Using the ",(0,i.jsx)(t.code,{children:"key"})," operator, we retrieve the dictionary's keys, representing the table's column names. It's essential to note that as ",(0,i.jsx)(t.code,{children:"t"})," stores the table name as a symbol, using ",(0,i.jsx)(t.code,{children:"value"})," is required to access the content of the table ",(0,i.jsx)(t.code,{children:"t"}),", even if it's currently an empty table."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"f:key flip value t;\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["The above result could have achieved using the ",(0,i.jsx)(t.code,{children:"cols"})," operator on the table."]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)trade:([] sym:`symbol$(); price:`float$())\nq)key flip value `trade\n`sym`price\nq)cols value `trade\n`sym`price\nq)(cols value `trade)~key flip value `trade\n1b\n"})})]}),"\n",(0,i.jsxs)(t.p,{children:["Next we publish the data to all real-time subscribers by using the ",(0,i.jsx)(t.code,{children:".u.pub"})," function."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".u.pub[t;$[0>type first x;enlist f!x;flip f!x]];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We first check if we are publishing a single record or a bulk update. Similar to previous checks, we evaluate the type of the initial record in our data. A negative response to the ",(0,i.jsx)(t.code,{children:"type"})," function, indicated by ",(0,i.jsx)(t.code,{children:"0>type first x"}),", confirms that we are publishing a single record. On the contrary, a ",(0,i.jsx)(t.code,{children:"false"})," result denotes the publication of multiple records. Employing the conditional operator ",(0,i.jsx)(t.code,{children:"$"})," allows us to take appropriate action for both scenarios. If we're dealing with a single record, we create a dictionary by mapping the column names stored in variable ",(0,i.jsx)(t.code,{children:"f"})," to the actual data stored in variable ",(0,i.jsx)(t.code,{children:"x"}),", thus creating a column-dictionary. We then enlist this dictionary, transforming it from a column-dictionary, into a single-row table."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"enlist f!x\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsx)(t.p,{children:"A KDB/Q table is basically a list of dictionaries, meaning that if you enlist a dictionary, you obtain a single row of a table. If you flip a column dictionary, a dictionary where each key contains a list of values of the same length, you obtain a table. On the other hand, if you take only one row of a table, the data will be represented as a dictionary"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)`sym`price!(`GOOG;200.0)\nsym  | `GOOG\nprice| 200f\nq)enlist `sym`price!(`GOOG;200.0)\nsym  price\n----------\nGOOG 200\nq)flip  `sym`price!(`GOOG`APPL`MSFT;200.0 145.9 332.34)\nsym  price\n-----------\nGOOG 200\nAPPL 145.9\nMSFT 332.34\nq)trade:([] sym:`GOOG`APPL`MSF;price:200.0 145.9 332.34)\nq)trade\nsym  price\n-----------\nGOOG 200\nAPPL 145.9\nMSF  332.34\nq)first trade\nsym  | `GOOG\nprice| 200f\nq)trade[1]\nsym  | `APPL\nprice| 145.9\nq)last trade\nsym  | `MSF\nprice| 332.34\n"})})]}),"\n",(0,i.jsx)(t.p,{children:"If we are dealing with a bulk update on the other hand, we map the column names to the list of data records, creating a column dictionary. Subsequently, this column dictionary is flipped to form a table."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"flip f!x\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Finally, the data can be published using ",(0,i.jsx)(t.code,{children:".u.pub"}),", the corresponding table name ",(0,i.jsx)(t.code,{children:"t"})," and the updated data records stored in ",(0,i.jsx)(t.code,{children:"x"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".u.pub[t;$[0>type first x;enlist f!x;flip f!x]];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The final step involves inserting the received data into the Tickerplant Log, provided it exists, and updating the overall message count ",(0,i.jsx)(t.code,{children:".u.i"})," by one.  As previously explained, we ensure that the handle to the Tickerplant Log exists, and if so, the function appends a parse tree that comprises the ",(0,i.jsx)(t.code,{children:"upd"})," function as the initial element, the table name t as the second element, and the data as the third element. Subsequently, the function utilizes enlist to add the records to the Tickerplant Log by writing to its handle ",(0,i.jsx)(t.code,{children:".u.l"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"if[.u.l;.u.l enlist (`upd;t;x);.u.i+:1];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We have now defined all necessary functions to operate our lightweight Tickerplant. The final line in the tick.q file calls the ",(0,i.jsx)(t.code,{children:".u.tick"})," function with the name of the file that contains the schema definitions and the designated path to store the Tickerplant Log file."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".u.tick[src;.z.x. 1]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We've completed our Tickerplant walkthrough. Next, we'll briefly examine the ",(0,i.jsx)(t.code,{children:"r.q"})," file containing the Real-time Database code."]}),"\n",(0,i.jsxs)(t.h2,{id:"the-real-time-database-rdb-code-explained--rq",children:["The Real-Time Database (RDB) Code Explained- ",(0,i.jsx)(t.code,{children:"r.q"})]}),"\n",(0,i.jsx)(t.p,{children:"The RDB, or Real-time Database, is a crucial component in any KDB/Q Tick setup. It preserves all intraday data in memory, ensuring accessibility for business users and other services requiring intraday data queries. Despite its simplicity, the standard Real-time Database, comprised of just three functions, closely resembles RDBs in more sophisticated and advanced KDB/Q Tick configurations."}),"\n",(0,i.jsx)(t.p,{children:"Let's delve into the code, dissecting it line by line:"}),"\n",(0,i.jsxs)(t.p,{children:["We first verify whether our KDB/Q Tick system is running on a Windows or Unix operating system and if we are running on the later we are invoking a ",(0,i.jsx)(t.code,{children:"sleep"})," system command to pause the process for one second. This allows the system to register our process before establishing any interprocess communication (TCP/IP)"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if[not "w"=first string .z.o;system "sleep 1"];\n'})}),"\n",(0,i.jsx)(t.h3,{id:"upd",children:(0,i.jsx)(t.code,{children:"upd"})}),"\n",(0,i.jsxs)(t.p,{children:["Next we define the update ",(0,i.jsx)(t.code,{children:"upd"})," function that is invoked by the Tickerplant whenever data is published to the Real-time Database. In most cases, the ",(0,i.jsx)(t.code,{children:"upd"})," function is defined as a simple ",(0,i.jsx)(t.code,{children:"insert"}),". Remember, the Tickerplant sends a parse tree, consisting of ",(0,i.jsx)(t.code,{children:"upd"})," as the function, the first element, followed by the table name and the actual data as parameters. Defining ",(0,i.jsx)(t.code,{children:"upd"})," as ",(0,i.jsx)(t.code,{children:"insert"})," will ensure that any new data is added to the end of the respective table."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"upd:insert\n"})}),"\n",(0,i.jsx)(t.p,{children:"Below examples should illustrate this behavior"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)trade:([] time:`timestamp$();sym:`symbol$();price:`float$());\nq)quote:([] time:`timestamp$();sym:`symbol$();bid:`float$();ask:`float$());\nq)upd:insert\nq)// single row update\nq)value (`upd;`trade;(.z.P;`GOOG;400.4))\n,0\nq)trade\ntime                          sym  price\n----------------------------------------\n2023.11.13D21:35:46.676306000 GOOG 400.4\nq)// multiple row update\nq)value (`upd;`trade;(3#.z.P;`GOOG`MSFT`APPL;400.4 134.56 234.5))\n1 2 3\nq)trade\ntime                          sym  price\n-----------------------------------------\n2023.11.13D21:35:46.676306000 GOOG 400.4\n2023.11.13D21:36:11.973625000 GOOG 400.4\n2023.11.13D21:36:11.973625000 MSFT 134.56\n2023.11.13D21:36:11.973625000 APPL 234.5\nq)value (`upd;`quote;(3#.z.P;`GOOG`MSFT`APPL;400.4 134.56 234.5;400.5 144.9 235.1))\n0 1 2\nq)quote\ntime                          sym  bid    ask\n-----------------------------------------------\n2023.11.13D21:37:06.689310000 GOOG 400.4  400.5\n2023.11.13D21:37:06.689310000 MSFT 134.56 144.9\n2023.11.13D21:37:06.689310000 APPL 234.5  235.1\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["We use ",(0,i.jsx)(t.code,{children:"value"})," to evalute the simple parse tree. You can read more about parse trees and how to create and evaluate them ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/wp/parse-trees/",children:"here"})]})}),"\n",(0,i.jsxs)(t.p,{children:["We assign the Tickerplant (TP) port and Historical Database (HDB) port provided as startup parameters to the global variable ",(0,i.jsx)(t.code,{children:".u.x"}),". In the case where no ports are provided upon startup, we assign the default ports ",(0,i.jsx)(t.code,{children:"5010"})," and ",(0,i.jsx)(t.code,{children:"5012"})," to the Tickerplant and Historical Database, respectively."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'.u.x:.z.x,(count .z.x)_(":5010";":5012");\n'})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["The system function ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/dotz/#zx-argv",children:(0,i.jsx)(t.code,{children:".z.x"})})," allows you to access all the parameters passed to a KDB/Q process. ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/dotq/#opt-command-parameters",children:(0,i.jsx)(t.code,{children:".Q.opt"})})," can be used to format the passed command line parameters."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q test.q 5010 5012 --debug 1b --test hello\nKDB+ 4.0 2023.01.20 Copyright (C) 1993-2023 Kx Systems\nq).z.x\n"5010"\n"5012"\n"--debug"\n"1b"\n"--test"\n"hello"\nq).z.x 0\n"5010"\nq).z.x 1\n"5012"\nq).Q.opt .z.x\n-debug| "1b"\n-test | "hello"\n'})}),"\n",(0,i.jsx)(t.h3,{id:"uend",children:(0,i.jsx)(t.code,{children:".u.end"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:".u.end"})," is the function invoked when the end-of-day process starts. At this point, the Tickerplant send an asynchronous message to all real-time subscribers and invokes their corresponding end-of-day function ",(0,i.jsx)(t.code,{children:".u.end"}),". As part of the Real-time Database (RDB), it performs the following tasks: it collects the names of all currently defined tables, selecting the subset of tables with the ",(0,i.jsx)(t.code,{children:"g"})," grouped attribute applied. It then uses the ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/dotq/#hdpf-save-tables",children:(0,i.jsx)(t.code,{children:".Q.hdpf"})})," function to save the current day's data in memory to disk partitions and proceeds to clear the tables in memory, triggers a reload message to the HDB, and lastly, reapplies the grouped attribute ",(0,i.jsx)(t.code,{children:"g"})," to the relevant tables."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// @param:\tx (date) - the current date\n// @return:\tNone\n.u.end:{[x]\n\tt:tables`.;\n  \tt@:where `g=attr each t@\\:`sym;\n  \t.Q.hdpf[`$":",.u.x 1;`:.;x;`sym];\n  \t@[;`sym;`g#] each t;\n  };\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The initial line of code is quite simple; it essentially retrieves the list of tables defined within the current process and stores them in the variable ",(0,i.jsx)(t.code,{children:"t"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"t:tables`.;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Next we retrieve the subset of tables that have the grouped attribute ",(0,i.jsx)(t.code,{children:"g"})," applied and re-assign it to variable ",(0,i.jsx)(t.code,{children:"t"}),". We do this by first indexing into the ",(0,i.jsx)(t.code,{children:"sym"})," column of each table using the ",(0,i.jsx)(t.code,{children:"each-left"})," operator in conjunction with the ",(0,i.jsx)(t.code,{children:"apply @"})," operator. For each ",(0,i.jsx)(t.code,{children:"sym"})," column we then use the ",(0,i.jsx)(t.code,{children:"attr"})," operator to check for applied attributes. This produces a list of attributes, which we can compare to the symbol representing the grouped attribute ",(0,i.jsx)(t.code,{children:"g"}),". This comparison generates a boolean mask that marks ",(0,i.jsx)(t.code,{children:"true (1b)"})," if a table has the grouped attribute ",(0,i.jsx)(t.code,{children:"g"})," applied and ",(0,i.jsx)(t.code,{children:"false (0b)"})," if it does not. Using this boolean mask in combination with ",(0,i.jsx)(t.code,{children:"where"}),", we index into the list of table names to retrieve only those with the grouped attribute ",(0,i.jsx)(t.code,{children:"g"})," applied. Finally, we overwrite the ",(0,i.jsx)(t.code,{children:"t"})," variable with this updated list."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"t@:where `g=attr each t@\\:`sym;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Using ",(0,i.jsx)(t.code,{children:".Q.hdpf"})," we then save all in-memory tables into a partitioned Historical Database (HDB), clear the in memory tables and instruct the Historical Database (HDB) to reload. ",(0,i.jsx)(t.code,{children:".Q.hdpf"})," takes the following parameters as arguements"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:".Q.hdpf[historicalport;directory;partition;`p#field]\n"})}),"\n",(0,i.jsx)(t.p,{children:"In our case this equates to the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'.Q.hdpf[`$":",.u.x 1;`:.;x;`sym];\nwhere\n- historicalport: the location of our HDB `$":",.u.x 1 \n- directory: the root directory of our HDB, the current directory `:.\n- partition: the partition to write the data to, x the input/date passed to .u.end\n- `p#field: the column to sort for and apply the parted attribute `p on, `sym in this case\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Finally, we re-apply the grouped attribute ",(0,i.jsx)(t.code,{children:"g"})," to the tables that had the attribute applied before the data purge."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"@[;`sym;`g#] each t;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This concludes our end-of-day function, and we can proceed to the last function defined in the ",(0,i.jsx)(t.code,{children:"r.q"})," file: the replay function ",(0,i.jsx)(t.code,{children:".u.rep."})]}),"\n",(0,i.jsx)(t.h3,{id:"urep",children:(0,i.jsx)(t.code,{children:".u.rep"})}),"\n",(0,i.jsxs)(t.p,{children:["The last function in our Real-time Database (RDB) is also one of the most crucial ones. ",(0,i.jsx)(t.code,{children:".u.rep"})," is the function responsible for replaying the Tickerplant Log file and is initially invoked when the RDB starts up. It receives a list of pairs constisting of the table names and their corresponding schema as the first parameter. This information is used to  initialise all tables with their respective schema. The second parameter is a list consisting of the total number of messages the Tickerplant has received so far as first element and the location of the Tickerplant Log file as second element. This information is then utilized to replay the Tickerplant Log file, ensuring that the RDB reflects the current state of the world. Let's examine the functionality of ",(0,i.jsx)(t.code,{children:".u.rep"})," together:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// @param:\tx (List) - List of pairs containing table names as first element and their corresponding table schema as second element\n// @param:\ty (List) - List consisting of the total number of elements the Tickerplant has received so far and the Tickerplant Log file location \n// @return:\tNone\n.u.rep:{\n\t(.[;();:;].)each x;\n\tif[null first y;:()];\n\t-11!y;\n\tsystem "cd ",1_-10_string first reverse y\n\t};\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Before we dive deeper into the functionality of ",(0,i.jsx)(t.code,{children:".u.rep"})," let's have a quick look at the structure of that first parameter ",(0,i.jsx)(t.code,{children:"x"})," that the function takes. If you remember, whenever a real-timer subscriber subscribes to the Tickerplant by invoking ",(0,i.jsx)(t.code,{children:".u.sub"})," it will receive a list of pairs consisting of table names and their corresponding schema. This structure is illustrated in the code below. If we examine the content as a whole and then break it down into individual elements, we can observe that each element of the list is a pair, with the table name as the first element and the respective empty schema as the second element:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)x\n`quote +`time`sym`bid`ask`bsize`asize!(`timespan$();`g#`symbol$();`float$();`float$();`int$();`int$())\n`trade +`time`sym`price`size!(`timespan$();`g#`symbol$();`float$();`int$())\nq)x 0\n`quote\n+`time`sym`bid`ask`bsize`asize!(`timespan$();`g#`symbol$();`float$();`float$();`int$();`int$())\nq)x 1\n`trade\n+`time`sym`price`size!(`timespan$();`g#`symbol$();`float$();`int$())\nq)x[0;0]\n`quote\nq)x[0;1]\ntime sym bid ask bsize asize\n----------------------------\nq)x[1;0]\n`trade\nq)x[1;1]\ntime sym price size\n-------------------\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The initial line of code may seem familiar. As previously discussed in the context of ",(0,i.jsx)(t.code,{children:".u.ld"}),", I explained that ",(0,i.jsx)(t.code,{children:".[x;();:;y]"})," is essentially equivalent to the K implementation of the ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/get/#set",children:(0,i.jsx)(t.code,{children:"set"})})," operator. This code, combined with the ",(0,i.jsx)(t.code,{children:"dot-apply ."})," operator, enables us to initialize each table with its respective table schema."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Illustration of dot-apply\nq){x+y} . (2;3)\n5\nq)x\n`quote +`time`sym`bid`ask`bsize`asize!(`timespan$();`g#`symbol$();`float$();`float$();`int$();`int$())\n`trade +`time`sym`price`size!(`timespan$();`g#`symbol$();`float$();`int$())\nq)(.[;();:;].) each x\n`quote`trade\nq)quote\ntime sym bid ask bsize asize\n----------------------------\nq)trade\ntime sym price size\n-------------------\n"})}),"\n",(0,i.jsxs)(t.p,{children:["After initializing all tables with their corresponding schema, we check whether the number of messages received by the Tickerplant so far is null or not. This is done by examining the first element of the parameter ",(0,i.jsx)(t.code,{children:"y"}),". If there were no messages received, and the value is null, we terminate the function early and return an empty list. Otherwise, we proceed to replay the Tickerplant Log file using the system function ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/basics/internal/#-11-streaming-execute",children:(0,i.jsx)(t.code,{children:"-11!"})})," and the parameter ",(0,i.jsx)(t.code,{children:"y"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Given that ",(0,i.jsx)(t.code,{children:"y"})," contains the number of received messages and the path to the Tickerplant Log file, ",(0,i.jsx)(t.code,{children:"-11!"})," will replay the first ",(0,i.jsx)(t.code,{children:"N"})," messages of the Tickerplant Log file"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"-11!y;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Finally, we change the current directory to the directory of the Historical Database (HDB) to ensure data is saved to the correct location when the RDB invokes the end-of-day save down and calls ",(0,i.jsx)(t.code,{children:".Q.hdpf"}),". In the plain vanilla Tick setup, the Tickerplant Log and the Historical Database are saved under the same path. Therefore, we can extract the first part of the path and use it to change the current directory."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'system "cd ",1_-10_string first reverse y\n'})}),"\n",(0,i.jsx)(t.h3,{id:"rdb-startup",children:"RDB startup"}),"\n",(0,i.jsxs)(t.p,{children:["The final line of code in ",(0,i.jsx)(t.code,{children:"r.q"})," is, in fact, the only line that gets executed. Upon startup of the Real-time Database, after initializing all functions with their definitions, it calls ",(0,i.jsx)(t.code,{children:'.u.rep . (hopen `$":",.u.x 0)"(.u.sub[`;`];`.u `i`L)";'}),". This establishes a connection to the Tickerplant and sends a synchronous message, invoking the ",(0,i.jsx)(t.code,{children:".u.sub"})," function to subscribe to all available tables for all symbols. Additionally, the Real-time Database accesses the ",(0,i.jsx)(t.code,{children:".u"})," namespace to retrieve ",(0,i.jsx)(t.code,{children:".u.i"})," and ",(0,i.jsx)(t.code,{children:".u.L"})," \u2013 the number of received messages (",(0,i.jsx)(t.code,{children:".u.i"}),") and the path to the Tickerplant Log file (",(0,i.jsx)(t.code,{children:".u.L"}),"). This results in a two-item list, where the first item is a list of pairs containing a table name and an empty table schema. The second item of the list consists of the total number of messages received by the Tickerplant and the path to the Tickerplant Log file."]}),"\n",(0,i.jsxs)(t.p,{children:['ChatGPT\nObserve the elegance of "Q-style" retrieval for ',(0,i.jsx)(t.code,{children:".u.i"})," and ",(0,i.jsx)(t.code,{children:".u.L"}),": Instead of individually retrieving ",(0,i.jsx)(t.code,{children:".u.i"})," and ",(0,i.jsx)(t.code,{children:".u.L"}),", we take advantage of the fact that you can pass multiple indices to a data structure for retrieving their elements. This functionality extends across all data structures, including lists, dictionaries, or tables. Because a namespace (",(0,i.jsx)(t.code,{children:".u"})," in this case) is represented as a dictionary, this also applies to namespaces. The following example illustrates this concept."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// Namespace\nq).u.i:345345\nq).u.L:system "pwd"\nq).u.L\n"/Users/Alexander/repos/testing"\nq).u `i`L\n345345\n,"/Users/Alexander/repos/testing"\n// List\nq)list:1 2 3 4 5\nq)list 0 1 4\n1 2 5\n// Table\nq)table:([] a:`a`b`c; b:1 2 3)\nq)table 1 2\na b\n---\nb 2\nc 3\n// Dictionary\nq)dict:`a`b`c!1 2 3\nq)dict `c`a\n3 1\n'})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:"While you generally want to keep all communication asynchronous within a KDB/Q Tick setup, the subscription of a real-time subscriber to the Tickerplant must be synchronous. The initialisation of the table schemas as well as the Tickerplant replay is crucial for the real-time subscriber to bring itself up to date with the current state of the world as well as be able to receive future updates, which would not be possible without the table schema"})}),"\n",(0,i.jsxs)(t.p,{children:["This two-item list is then passed as parameters to the dyadic function ",(0,i.jsx)(t.code,{children:".u.rep"}),", which proceeds to initialize all tables with their corresponding table schemas. It further checks whether the Tickerplant Log file contains any messages and, if so, replays the Tickerplant Log file to synchronize the real-time subscriber with the current state of the world."]}),"\n",(0,i.jsx)(t.p,{children:"This concludes our comprehensive walkthrough of a complete, vanilla  KDB/Q Tick setup, providing you with a thorough understanding of its inner workings. We delved into each process in detail, explaining key KDB/Q concepts along the way."}),"\n",(0,i.jsx)(t.h2,{id:"limitations-of-kdbq-tick",children:"Limitations of KDB/Q Tick"}),"\n",(0,i.jsx)(t.p,{children:"Although this setup serves as an excellent foundation for capturing real-time data, it is essential to acknowledge some inherent limitations, which will be discussed in the following sections."}),"\n",(0,i.jsx)(t.h3,{id:"tickerplant-doesnt-deal-with-corrupt-tickerplant-log-files",children:"Tickerplant doesn't deal with corrupt Tickerplant Log files"}),"\n",(0,i.jsxs)(t.p,{children:["** The Problem:**\nOne of the primary drawbacks of our basic Tickerplant is its inability to address corrupted Tickerplant Log files. Upon reviewing the ",(0,i.jsx)(t.code,{children:".u.ld"})," function, you'll notice that encountering a corrupted Tickerplant Log file leads to the termination of the Tickerplant with an error message. While a corrupt Log file is indeed a critical issue requiring manual attention, there are alternative approaches to handle this situation. If your Tickerplant is inactive, it implies potential data loss."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Possible solution:"})}),"\n",(0,i.jsxs)(t.p,{children:["One possible solution is to utilize the ",(0,i.jsx)(t.code,{children:"-2"})," option of ",(0,i.jsx)(t.code,{children:"-11!"})," to identify the count of valid messages in the Tickerplant Log File, replay them, and then generate an alert message to a monitoring service, prompting investigation into the cause of the Log file corruption."]}),"\n",(0,i.jsx)(t.h3,{id:"process-location-one-host-only",children:"Process location: One host only"}),"\n",(0,i.jsxs)(t.p,{children:["** The Problem:**\nThe architecture of this KDB/Q Tick system mandates the Real-time Database or any other real-time subscriber to replay the Tickerplant Log on startup for recreating the current state of the world and retrieving all messages received by the Tickerplant up to that moment. However, this requires the Tickerplant Log file to be present on the same host or server as the process attempting to replay the log file. As we pass the path of the Tickerplant Log file as a parameter to ",(0,i.jsx)(t.code,{children:"-11!"}),", the function used for replaying the log file, this requirement not only dictates that all real-time subscribers must be on the same host, impacting our hardware needs, but it also makes our system less flexible and limits its extensibility."]}),"\n",(0,i.jsx)(t.p,{children:"** Possible Solution:**"}),"\n",(0,i.jsx)(t.p,{children:"A potential solution to this challenge could involve creating an independent process dedicated to replaying the Tickerplant Log file whenever necessary and forwarding the messages to the real-time subscriber that triggered the replay. Another alternative could be the introduction of a Chained Tickerplant (CTP) residing on a secondary host. The CTP would subscribe to the main Tickerplant on the primary host and maintain a local Tickerplant Log file accessible to all real-time subscribers on that specific host. Both solutions require additional design and implementation, and a detailed explanation goes beyond the scope of this post. Nevertheless, they serve as potential ideas for consideration."}),"\n",(0,i.jsx)(t.h3,{id:"unnecessary-serialisation-of-messages",children:"Unnecessary serialisation of messages"}),"\n",(0,i.jsxs)(t.p,{children:["** The problem:**\nThe existing implementation of ",(0,i.jsx)(t.code,{children:".u.pub"})," disseminates all messages received by the Tickerplant to each real-time subscriber separately. In other words, the messages are serialized and dispatched to each subscriber individually. This could potentially increase the latency of our system."]}),"\n",(0,i.jsx)(t.p,{children:"** Possible Solution:**"}),"\n",(0,i.jsxs)(t.p,{children:["This problem only has a partial solution, depending on the KDB/Q version your system is running on. In ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/releases/ChangesIn3.4/",children:"version 3.4"}),"  KX introduced asynchronous broadcast ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/basics/internal/#-25x-async-broadcast",children:(0,i.jsx)(t.code,{children:"-25!"})}),", which serialises outgoing messages only once. If your system is running on version 3.4 or above, you can take advantage of this functionality and reduce CPU and memory load as well as latency."]}),"\n",(0,i.jsx)(t.p,{children:"That's all folks. Happy coding!"})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(6540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);