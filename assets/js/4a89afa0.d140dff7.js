"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2585],{4151:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var n=s(4848),o=s(8453);const i={sidebar_position:6},a="QSQL - Querying Your Data",r={id:"concepts/qsql",title:"QSQL - Querying Your Data",description:"In our latest blog post, we've covered a lot about Dictionaries and Tables and explored how to store large volumes of data. Now, it's time to take the next step and dive into how we can access this data. How do we query it, filter for what we need, and manipulate the information to gain valuable insights? Just like other databases, KDB/Q comes with its own built-in querying language: Q-SQL. Contrary to popular belief, I find Q-SQL easier to use than traditional SQL, and it's significantly more performant. Thanks to KDB/Q's column-oriented database structure, which stores data as collections of lists rather than rows and keeps columns in contiguous memory, it's perfectly optimized for vectorized operations, delivering near-instant results. In this blog post, we'll explore the key concepts of the Q-SQL query language and how you can effectively access your data.",source:"@site/docs/concepts/qsql.mdx",sourceDirName:"concepts",slug:"/concepts/qsql",permalink:"/docs/concepts/qsql",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Dictionaries and Tables",permalink:"/docs/concepts/dictionariesTables"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},l={},c=[{value:"The <code>select</code> Statement",id:"the-select-statement",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"qsql---querying-your-data",children:"QSQL - Querying Your Data"}),"\n",(0,n.jsxs)(t.p,{children:["In our latest blog post, we've covered a lot about ",(0,n.jsx)(t.a,{href:"https://www.defconq.tech/docs/concepts/dictionariesTables",children:"Dictionaries and Tables"})," and explored how to store large volumes of data. Now, it's time to take the next step and dive into how we can access this data. How do we query it, filter for what we need, and manipulate the information to gain valuable insights? Just like other databases, KDB/Q comes with its own built-in querying language: Q-SQL. Contrary to popular belief, I find Q-SQL easier to use than traditional SQL, and it's significantly more performant. Thanks to KDB/Q's column-oriented database structure, which stores data as collections of lists rather than rows and keeps columns in contiguous memory, it's perfectly optimized for vectorized operations, delivering near-instant results. In this blog post, we'll explore the key concepts of the Q-SQL query language and how you can effectively access your data."]}),"\n",(0,n.jsxs)(t.h2,{id:"the-select-statement",children:["The ",(0,n.jsx)(t.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#93-the-select-template",children:(0,n.jsx)(t.code,{children:"select"})})," Statement"]}),"\n",(0,n.jsxs)(t.p,{children:["The most common way to query your data is through the ",(0,n.jsx)(t.code,{children:"select"})," statement, which can range from simple, basic queries to more advanced and powerful data retrieval. In the following section, we\u2019ll discuss the syntax of the select statement and explore various methods for selecting data. Let\u2019s get started!"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Syntax"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:" select <columns phrase> <by phrase> from T<exp> <where phrase>\n"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"column(s) phrase"}),":"]})," This specifies the columns you want to select. You can use the column phrase to rename or aggregate columns."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"by phrase"}),":"]})," To group your data by specific column(s), you can use the ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"by"})})," phrase to organize the results accordingly."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"T<exp>"}),":"]})," You can either select data directly from a specific table or use an expression as the data source for your select statement"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsxs)(t.strong,{children:[(0,n.jsx)(t.code,{children:"where phrase"}),":"]})," The where clause allows you to filter your dataset, narrowing it down to a smaller subset before making your (final) selection."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["It\u2019s crucial to remember the order in which the individual clauses of a ",(0,n.jsx)(t.code,{children:"select"})," statement are evaluated, particularly when optimizing queries for maximum efficiency. The evaluation order is as follows:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Texp"}),": The first clause to be evaluated is the ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"from T<exp>"})})," expression, which defines the data source. If this is a straightforward table, no evaluation is necessary, making it almost instantaneous. However, as previously mentioned, ",(0,n.jsx)(t.code,{children:"T<exp>"})," can be any KDB/Q expression that returns a table."]}),"\n",(0,n.jsxs)(t.li,{children:["The next step is the evaluation of the ",(0,n.jsx)(t.strong,{children:"where phrase"}),". his filters your data, starting with the leftmost condition and progressively narrowing down the dataset for subsequent conditions. You can significantly improve performance by prioritizing the most restrictive condition first. We\u2019ll dive deeper into this later."]}),"\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.strong,{children:"by clause"})," is evaluated next, grouping your data based on specific columns."]}),"\n",(0,n.jsxs)(t.li,{children:["Lastly, the ",(0,n.jsx)(t.strong,{children:"column phrase"})," is executed, selecting the desired columns. You can also rename columns, perform calculations, or apply aggregations during this step."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Let's look at the individual phrases in more detail. To demonstrate the various forms, we\u2019ll create a simple ",(0,n.jsx)(t.code,{children:"trade"})," table as an example."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>r});var n=s(6540);const o={},i=n.createContext(o);function a(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);