"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8581],{35610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Intro","href":"/docs/intro","docId":"intro","unlisted":false},{"type":"category","label":"KDB/Q Study Roadmap","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Choosing the Right KDB/Q Study Plan","href":"/docs/studyPlan/intro","docId":"studyPlan/intro","unlisted":false},{"type":"link","label":"KDB/Q Pre-School: Your first Baby Steps","href":"/docs/studyPlan/babySteps","docId":"studyPlan/babySteps","unlisted":false},{"type":"link","label":"Aspiring KDB/Q Developers: Your Path to Mastery","href":"/docs/studyPlan/kdbDevs","docId":"studyPlan/kdbDevs","unlisted":false},{"type":"link","label":"Non-KDB/Q Developers: Transitioning to the Power of KDB/Q","href":"/docs/studyPlan/nonKdbDevs","docId":"studyPlan/nonKdbDevs","unlisted":false},{"type":"link","label":"Quants and Quant Devs: Unlocking the Full Potential of KDB/Q","href":"/docs/studyPlan/quants","docId":"studyPlan/quants","unlisted":false},{"type":"link","label":"Data & Business Analysts: Efficient Querying with KDB/Q","href":"/docs/studyPlan/dataBA","docId":"studyPlan/dataBA","unlisted":false},{"type":"link","label":"KDB/Q for Managers: Demystifying Data for Non-Tech Leaders","href":"/docs/studyPlan/mangers","docId":"studyPlan/mangers","unlisted":false}],"href":"/docs/category/kdbq-study-roadmap"},{"type":"category","label":"KDB/Q Language","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"KDB/Q Unveiled: A Journey into the Pinnacle of Database Technology","href":"/docs/language/history","docId":"language/history","unlisted":false},{"type":"link","label":"Unlocking Unmatched Performance: The Speed Secrets of KDB/Q","href":"/docs/language/speed","docId":"language/speed","unlisted":false},{"type":"link","label":"Unleashing the Power of Time-Series Analysis and Big Data: Why KDB/Q Reigns Supreme","href":"/docs/language/why_KDB","docId":"language/why_KDB","unlisted":false}],"href":"/docs/category/kdbq-language"},{"type":"category","label":"KDB Architecture","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"The Plain Vanilla Tick Setup","href":"/docs/architecture/plain","docId":"architecture/plain","unlisted":false}],"href":"/docs/category/kdb-architecture"},{"type":"category","label":"Important Concepts","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Attributes","href":"/docs/concepts/attributes","docId":"concepts/attributes","unlisted":false},{"type":"link","label":"Memory Management","href":"/docs/concepts/memoryManagement","docId":"concepts/memoryManagement","unlisted":false},{"type":"link","label":"Garbage Collection","href":"/docs/concepts/garbageCollection","docId":"concepts/garbageCollection","unlisted":false},{"type":"link","label":"Amend, Amend At: The Swiss Army knife among KDB/Q operators","href":"/docs/concepts/amend","docId":"concepts/amend","unlisted":false},{"type":"link","label":"Dictionaries and Tables","href":"/docs/concepts/dictionariesTables","docId":"concepts/dictionariesTables","unlisted":false},{"type":"link","label":"QSQL - Querying Your Data","href":"/docs/concepts/qsql","docId":"concepts/qsql","unlisted":false},{"type":"link","label":"Mastering the Art of Filtering: An In-Depth Look at fby in KDB/Q","href":"/docs/concepts/fby","docId":"concepts/fby","unlisted":false},{"type":"link","label":"Embracing Terseness: Functional Forms and Parse Trees","href":"/docs/concepts/functionalSelect","docId":"concepts/functionalSelect","unlisted":false},{"type":"link","label":"Joins: Connecting the Dots for Data Clarity","href":"/docs/concepts/joins","docId":"concepts/joins","unlisted":false},{"type":"link","label":"Iterators: Navigating Vectors Without the Need for Loops","href":"/docs/concepts/iterators","docId":"concepts/iterators","unlisted":false},{"type":"link","label":"Fundamentals of Interprocess Communication (IPC)","href":"/docs/concepts/ipc","docId":"concepts/ipc","unlisted":false},{"type":"link","label":"Beyond the Fundamentals: Next Level Interprocess Communications","href":"/docs/concepts/ipcNextLevel","docId":"concepts/ipcNextLevel","unlisted":false}],"href":"/docs/category/important-concepts"},{"type":"category","label":"Tutorials","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"KDB Tick Explained: A Walkthrough [PART 1]","href":"/docs/tutorials/tick","docId":"tutorials/tick","unlisted":false},{"type":"link","label":"KDB Tick Explained: A Walkthrough [PART 2]","href":"/docs/tutorials/tick2","docId":"tutorials/tick2","unlisted":false},{"type":"link","label":"A Real Time Stock Market Feed","href":"/docs/tutorials/realTimeStocks","docId":"tutorials/realTimeStocks","unlisted":false}],"href":"/docs/category/tutorials"},{"type":"category","label":"Productivity Tools","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Pulse","href":"/docs/productivity/pulse","docId":"productivity/pulse","unlisted":false}],"href":"/docs/category/productivity-tools"}]},"docs":{"architecture/plain":{"id":"architecture/plain","title":"The Plain Vanilla Tick Setup","description":"A basic KDB/Q Tick setup consists of three  essential elements such as a Tickerplant (TP), a Real-Time Database (RDB), and a Historical Database (HDB). Additionally, this configuration involves the integration of two external processes, namely a Data Feed and a Feed Handler. The provided image below serves as a visual representation of this architectural arrangement.","sidebar":"tutorialSidebar"},"concepts/amend":{"id":"concepts/amend","title":"Amend, Amend At: The Swiss Army knife among KDB/Q operators","description":"Whenever I encounter the @ or . amend or amend at operators, I\'m inevitably reminded of a Swiss Army pocketknife. Just like this versatile multi-tolled knife, the @ or . operators in KDB/Q are multi-functional, capable of solving various tasks. When combined with the expertise of a skilled KDB/Q developer, akin to the resourcefulness of a highly trained soldier or agent like MacGyver, the possibilities are limitless \u2013 you can conquer any challenge with ease.","sidebar":"tutorialSidebar"},"concepts/attributes":{"id":"concepts/attributes","title":"Attributes","description":"A cornerstone principle in KDB/Q, integral to query optimization, is the concept of Attributes. Attributes serve as metadata that can be attached to lists of special forms, dictionaries, or table columns (which are basically lists), amplifying data retrieval speed and consequently enhancing query efficiency and performance. By attaching metadata about the implied structure of the list associated with a specific Attribute, the Q interpreter can enact optimizations, resulting in a notable performance boost. This post not only provides a comprehensive explanation of various Attributes and their properties but also emphasizes their strategic utilization and optimal placement in different scenarios.","sidebar":"tutorialSidebar"},"concepts/dictionariesTables":{"id":"concepts/dictionariesTables","title":"Dictionaries and Tables","description":"In this blog post, we explore two key data types native to KDB/Q: Dictionaries and Tables. Unlike mainstream programming languages like Java, which lack native support for these data types and require alternative structures (e.g., Java HashMap for dictionaries or Java ArrayList for lists of rows to represent tables), KDB/Q inherently supports both Dictionaries and Tables. Understanding these data structures is crucial for leveraging the speed and performance of KDB/Q to build efficient big data applications. In the following sections, we will examine the most important concepts of both data types, a in detail explanation of dictionaries and tables is beyond the scope of this blog post and can be found in Chapter 5 - Dictionaries and Chapter 8 - Tables of Q for Mortals.","sidebar":"tutorialSidebar"},"concepts/fby":{"id":"concepts/fby","title":"Mastering the Art of Filtering: An In-Depth Look at fby in KDB/Q","description":"Graffiti Filter Byfby","sidebar":"tutorialSidebar"},"concepts/functionalSelect":{"id":"concepts/functionalSelect","title":"Embracing Terseness: Functional Forms and Parse Trees","description":"Over the past few weeks, we\'ve explored a lot about querying data, starting with Q-SQL and progressing to the powerful capabilities of the fby operator. Now, there are only two topics left to dive into: the functional form of Q-SQL statements and parse trees. The functional form offers a more concise way of writing Q-SQL, and it ties closely to the concept of parse trees, which we will also cover. After that, we\'ll move on to joins, which will be explored in an upcoming blog post.","sidebar":"tutorialSidebar"},"concepts/garbageCollection":{"id":"concepts/garbageCollection","title":"Garbage Collection","description":"In this blog post, we cover another crucial concept, which if fully understood, can set you apart. Today\'s topic is Garbage Collection, and here\'s the news upfront: There\'s no such thing as Garbage in KDB/Q!! Yes, you read it correctly. Don\'t be caught off guard like I was, discovering this information in a job interview with \\"the QGOD\\" among all KDB/Q developers. Keep reading and learn everything you need to know about this essential topic.","sidebar":"tutorialSidebar"},"concepts/ipc":{"id":"concepts/ipc","title":"Fundamentals of Interprocess Communication (IPC)","description":"We have now covered most of the key KDB/Q concepts, with just one crucial topic left before you\'re fully equipped to build a complete KDB/Q application: Interprocess Cummincation (OPC). The last piece of the puzzle is understanding how KDB/Q processes communicate with each other. In the following section, we will explore how to establish a connection to a KDB/Q process, using connection handles to send messages, the differences between synchronous and asynchronous communication, their respective advantages, and when to use each. While IPC can be complex in many mainstream programming languages, KDB/Q provides it out of the box. So, without further delay, let\'s jump into the world of IPC!","sidebar":"tutorialSidebar"},"concepts/ipcNextLevel":{"id":"concepts/ipcNextLevel","title":"Beyond the Fundamentals: Next Level Interprocess Communications","description":"In my last blog post, we covered the essential concepts of Interprocess Communication (IPC) in KDB/Q. Now, it\'s time to take things up a notch!","sidebar":"tutorialSidebar"},"concepts/iterators":{"id":"concepts/iterators","title":"Iterators: Navigating Vectors Without the Need for Loops","description":"In this blog post, we cover one of the most advanced and challenging concepts in the KDB/Q programming language: Iterators (formerly known as Adverbs). In grammar, an adverb is described as \\"a word that modifies or describes a verb, an adjective, another adverb, or even a whole sentence\\" [1]. Similarly, in KDB/Q, adverbs - or as they\u2019re now called, iterators - or as they\u2019re now called, iterators - are higher-order functions that modify how other functions are applied to lists. As someone passionate about finance, I like to think of them as derivatives, as they derive new functionality from the underlying function.","sidebar":"tutorialSidebar"},"concepts/joins":{"id":"concepts/joins","title":"Joins: Connecting the Dots for Data Clarity","description":"So far, we\u2019ve explored how to query data using Q-SQL and how to translate those queries into their corresponding functional forms. Now, let\u2019s take it a step further and dive into joining datasets with KDB/Q. Joins are one of the most powerful tools in KDB/Q, and they play a significant role in its unmatched efficiency for big data analysis. Compared to other languages, KDB/Q joins are not only faster and more efficient but also uniquely versatile, featuring specialized joins like the asof join and window join.","sidebar":"tutorialSidebar"},"concepts/memoryManagement":{"id":"concepts/memoryManagement","title":"Memory Management","description":"This blog post dives into a crucial aspect of real-time data handling: Memory Management. Despite its significance in architectural system design, this topic is not extensively covered in the official KX documentation. A profound comprehension of Memory Management in KDB/Q is crucial for understanding the workings of Garbage Collection in the same environment. In this blog post, I aim to provide a comprehensive overview of Memory Management in KDB/Q, shedding light on essential considerations for designing an efficient system.","sidebar":"tutorialSidebar"},"concepts/qsql":{"id":"concepts/qsql","title":"QSQL - Querying Your Data","description":"In our latest blog post, we\'ve covered a lot about Dictionaries and Tables and explored how to store large volumes of data. Now, it\'s time to take the next step and dive into how we can access this data. How do we query it, filter for what we need, and manipulate the information to gain valuable insights? Just like other databases, KDB/Q comes with its own built-in querying language: Q-SQL. Contrary to popular belief, I find Q-SQL easier to use than traditional SQL, and it\'s significantly more performant. Thanks to KDB/Q\'s column-oriented database structure, which stores data as collections of lists rather than rows and keeps columns in contiguous memory, it\'s perfectly optimized for vectorized operations, delivering near-instant results. In this blog post, we\'ll explore the key concepts of the Q-SQL query language and how you can effectively access your data.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Intro","description":"Before we can start learning KDB/Q we first need to have a running version of q installed. Let\'s kickstart our journey!","sidebar":"tutorialSidebar"},"language/history":{"id":"language/history","title":"KDB/Q Unveiled: A Journey into the Pinnacle of Database Technology","description":"In the ever-evolving landscape of programming languages, KDB/Q stands as a testament to innovation and efficiency. This post delves into the origins, evolution, and the ingenious mind behind KDB/Q, unraveling the layers that make it an exceptional database language.","sidebar":"tutorialSidebar"},"language/speed":{"id":"language/speed","title":"Unlocking Unmatched Performance: The Speed Secrets of KDB/Q","description":"In the world of time-series databases, KDB/Q stands as a powerhouse, setting itself apart with unparalleled performance and speed. At the core of its efficiency lies a combination of design principles and unique features that make it the preferred choice for industries dealing with massive datasets and demanding real-time analytics.","sidebar":"tutorialSidebar"},"language/why_KDB":{"id":"language/why_KDB","title":"Unleashing the Power of Time-Series Analysis and Big Data: Why KDB/Q Reigns Supreme","description":"In the vast landscape of programming languages, one particular gem stands out like a beacon of efficiency and unparalleled capabilities \u2014 KDB/Q. This article is not merely a declaration of superiority but a journey into its distinctive features, and unparalleled advantages that make KDB/Q the undisputed champion for time-series analysis and big data applications.","sidebar":"tutorialSidebar"},"productivity/pulse":{"id":"productivity/pulse","title":"Pulse","description":"In this post, we are going to look at Pulse, a real-time data visualization tool that allows you to quickly develop interactive, real-time dashboards with little to no effort and easily share it with your colleagues or users. It excels in presenting real-time trade blotters, price graphs, or any contextual or positional data crucial for traders. Tailored specifically for the financial industry, Pulse is particular well suited for managing big data in a time-critical and responsive manner.","sidebar":"tutorialSidebar"},"studyPlan/babySteps":{"id":"studyPlan/babySteps","title":"KDB/Q Pre-School: Your first Baby Steps","description":"When it comes to KDB/Q, there are core fundamentals that everyone should understand, regardless of their role or level of involvement in development work. Gaining this foundational knowledge can help you to make more informed decisions, ultimately contributing to your success. In the following section, I\u2019ll highlight these key concepts, explain why they\u2019re essential, and provide a study plan to help you acquire this knowledge.","sidebar":"tutorialSidebar"},"studyPlan/dataBA":{"id":"studyPlan/dataBA","title":"Data & Business Analysts: Efficient Querying with KDB/Q","description":"As a Data and/or Business Analyst, you often bridge the gap between business and tech, collaborating closely with Quants and KDB/Q developers to interpret, visualize, and analyze data. The extent of your interaction with KDB/Q can vary, but having foundational KDB/Q knowledge is always a valuable asset. Even if you don\u2019t need it in your current role, it could come in handy in the future, and you\u2019ll be glad to have the basics under your belt. The study plan below is designed to give you just that\u2014a fundamental understanding of KDB/Q, so you\'re ready to dive in when needed.","sidebar":"tutorialSidebar"},"studyPlan/intro":{"id":"studyPlan/intro","title":"Choosing the Right KDB/Q Study Plan","description":"As you likely already know, KDB/Q is incredibly powerful and versatile, especially when it comes to big data, time series analysis, and number crunching. It\u2019s important to have a clear idea of what you want to use KDB/Q for before choosing your study plan. While there\'s no harm in studying KDB/Q in-depth, even if you end up not using it as much as expected, the knowledge will still benefit you\u2014shaping your mindset and helping you approach problems differently. That said, I understand that time is valuable, so a brief overview of the various roles should help you pick the study plan that suits you best.","sidebar":"tutorialSidebar"},"studyPlan/kdbDevs":{"id":"studyPlan/kdbDevs","title":"Aspiring KDB/Q Developers: Your Path to Mastery","description":"Before we start","sidebar":"tutorialSidebar"},"studyPlan/mangers":{"id":"studyPlan/mangers","title":"KDB/Q for Managers: Demystifying Data for Non-Tech Leaders","description":"As a manager, your days are likely filled with meetings, navigating processes, and handling the administrative tasks that come with managing a larger team. While you may occasionally engage in technical discussions, you likely have technical leads to make key decisions in those areas. Perhaps you come from a technical background and once worked hands-on as a developer, but it\'s been a while since you\u2019ve written code. However, it\u2019s still essential to understand the KDB/Q landscape. Given the niche nature of this technology, you may not have encountered it before, and some concepts may be new to you. Don\u2019t worry\u2014I\u2019ve got you covered. The study plan below provides everything a manager needs to know about KDB/Q.","sidebar":"tutorialSidebar"},"studyPlan/nonKdbDevs":{"id":"studyPlan/nonKdbDevs","title":"Non-KDB/Q Developers: Transitioning to the Power of KDB/Q","description":"Before we start","sidebar":"tutorialSidebar"},"studyPlan/quants":{"id":"studyPlan/quants","title":"Quants and Quant Devs: Unlocking the Full Potential of KDB/Q","description":"As a Quant or Quant Dev in a front-office role, you\'re often focused on business-critical tasks like pricing models, trade cost analysis, price impact analysis, and more. While Python is often the go-to for initial research or prototyping, and Java or C++ for production code, KDB/Q provides a much more powerful alternative to these mainstream languages. Its array-based structure and terse syntax offer a competitive edge for those who master it. The study plan below will guide you through a structured path to gain proficiency in KDB/Q.","sidebar":"tutorialSidebar"},"tutorials/realTimeStocks":{"id":"tutorials/realTimeStocks","title":"A Real Time Stock Market Feed","description":"In this tutorial, we\'ll walk through building a real-time stock market data feed and streaming that data into a simplified KDB/Q Tick architecture. We\'ll use Python, specifically the yfinance library, to fetch live market data from Yahoo Finance, and then publish it to a custom KDB/Q Tickerplant (TP), which will forward the data to a Real-Time Database (RDB). We\'ll use the qpython library to connect our Feedhandler to the Tickerplant, enabling us to stream real-time data for further processing.","sidebar":"tutorialSidebar"},"tutorials/tick":{"id":"tutorials/tick","title":"KDB Tick Explained: A Walkthrough [PART 1]","description":"In this blog post, we\'re diving into the code of a simple Tickerplant. We\'ll break it down line by line, explaining what each part does and how it fits into the big picture. This will not only demystify Tickerplants but also shed light on important KDB/Q programming concepts. By doing so, you\'ll gain insights into the inner workings of a Tickerplant and acquire a deeper understanding of key concepts in the KDB/Q programming language.","sidebar":"tutorialSidebar"},"tutorials/tick2":{"id":"tutorials/tick2","title":"KDB Tick Explained: A Walkthrough [PART 2]","description":"In my previous tutorial I walked you through all the helper functions you can find in the u.q file of a plain vanilla Tickerplant. I provided a comprehensive overview of the inner workings of these functions and how they interact with each other. It is now time to circle back and continue with our step-by-step examination of the main tick.q file and complete complete our understanding of the Tickerplant. If you\'d like to revisit our previous discussions or if you\'re new to this tutorial, you can access my earlier post here.","sidebar":"tutorialSidebar"}}}')}}]);