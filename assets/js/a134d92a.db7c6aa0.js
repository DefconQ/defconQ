"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3134],{5768:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var i=n(4848),s=n(8453);const r={sidebar_position:1},a="Attributes",o={id:"concepts/attributes",title:"Attributes",description:"A cornerstone principle in KDB/Q, integral to query optimization, is the concept of Attributes. Attributes serve as metadata that can be attached to lists of special forms, dictionaries, or table columns (which are basically lists), amplifying data retrieval speed and consequently enhancing query efficiency and performance. By attaching metadata about the implied structure of the list associated with a specific Attribute, the Q interpreter can enact optimizations, resulting in a notable performance boost. This post not only provides a comprehensive explanation of various Attributes and their properties but also emphasizes their strategic utilization and optimal placement in different scenarios.",source:"@site/docs/concepts/attributes.mdx",sourceDirName:"concepts",slug:"/concepts/attributes",permalink:"/docs/concepts/attributes",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Important Concepts",permalink:"/docs/category/important-concepts"},next:{title:"Memory Management",permalink:"/docs/concepts/memoryManagement"}},l={},h=[{value:"What are Attributes",id:"what-are-attributes",level:2},{value:"Sorted (<code>`s#</code>)",id:"sorted-s",level:3},{value:"Unique (<code>`u#</code>)",id:"unique-u",level:3},{value:"Parted (<code>`p#</code>)",id:"parted-p",level:3},{value:"Grouped (<code>`g#</code>)",id:"grouped-g",level:3},{value:"Applying Attributes",id:"applying-attributes",level:2},{value:"Removing Attributes",id:"removing-attributes",level:2},{value:"Applying Attributes to table columns",id:"applying-attributes-to-table-columns",level:2},{value:"Operations on lists with Attributes",id:"operations-on-lists-with-attributes",level:2},{value:"Operations on Attributes in Memory",id:"operations-on-attributes-in-memory",level:3},{value:"Sorted Lists",id:"sorted-lists",level:4},{value:"Unique Lists",id:"unique-lists",level:4},{value:"Parted Lists",id:"parted-lists",level:4},{value:"Grouped Lists",id:"grouped-lists",level:4},{value:"Operations on Attributes on Disk",id:"operations-on-attributes-on-disk",level:3},{value:"Sorted Lists on Disk",id:"sorted-lists-on-disk",level:4},{value:"Memory Overhead of Attributes",id:"memory-overhead-of-attributes",level:2},{value:"When to use Attributes",id:"when-to-use-attributes",level:2},{value:"Attributes in the KDB-Tick Stack",id:"attributes-in-the-kdb-tick-stack",level:2},{value:"Attributes and the Tickerplant",id:"attributes-and-the-tickerplant",level:3},{value:"Real-time Database (RDB) and other Real-Time Subscribers (RTS)",id:"real-time-database-rdb-and-other-real-time-subscribers-rts",level:3},{value:"Attributes and the Historical Database (HDB)",id:"attributes-and-the-historical-database-hdb",level:3},{value:"Attributes and Joins",id:"attributes-and-joins",level:2},{value:"Special Application of Attributes",id:"special-application-of-attributes",level:2},{value:"Step Dictionary",id:"step-dictionary",level:3},{value:"Sorted Attribute on Keyed Tables",id:"sorted-attribute-on-keyed-tables",level:3},{value:"Conclustion",id:"conclustion",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"attributes",children:"Attributes"}),"\n",(0,i.jsx)(t.p,{children:"A cornerstone principle in KDB/Q, integral to query optimization, is the concept of Attributes. Attributes serve as metadata that can be attached to lists of special forms, dictionaries, or table columns (which are basically lists), amplifying data retrieval speed and consequently enhancing query efficiency and performance. By attaching metadata about the implied structure of the list associated with a specific Attribute, the Q interpreter can enact optimizations, resulting in a notable performance boost. This post not only provides a comprehensive explanation of various Attributes and their properties but also emphasizes their strategic utilization and optimal placement in different scenarios."}),"\n",(0,i.jsx)(t.h2,{id:"what-are-attributes",children:"What are Attributes"}),"\n",(0,i.jsxs)(t.p,{children:["As mentioned earlier, ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/8_Tables/#88-attributes",children:"Attributes"})," serve as metadata that can be assigned to lists with a special form, dictionaries, and table columns to accelerate retrieval functions and other operations. All Attributes, except for the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute, are descriptive rather than prescriptive. This means that applying an Attribute merely asserts that a list has a special form without altering or recreating its structure; this responsibility lies entirely with the developer. KDB/Q features four Attributes: ",(0,i.jsx)(t.strong,{children:"sorted"})," (s), ",(0,i.jsx)(t.strong,{children:"unique"})," (u), ",(0,i.jsx)(t.strong,{children:"parted"})," (p), and ",(0,i.jsx)(t.strong,{children:"grouped"})," (g), and while their names provide a basic understanding, there's more complexity to Attributes than meets the eye. Let's delve deeper into their nuances."]}),"\n",(0,i.jsx)(t.h3,{id:"sorted-s",children:(0,i.jsxs)(t.a,{href:"https://code.kx.com/q4m3/8_Tables/#881-sorted-s",children:["Sorted (",(0,i.jsx)(t.code,{children:"`s#"}),")"]})}),"\n",(0,i.jsxs)(t.p,{children:["In KDB/Q, the default search algorithm is a linear search, which can be quite slow for large datasets since it requires traversing the entire list to find an element. Applying the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute (````s#```) to a list, indicates that the elements of the list are in ascending order, thereby replacing the linear search algorithm with a more efficient binary search. Consequently, operations like ",(0,i.jsxs)(t.a,{href:"https://code.kx.com/q/ref/find/",children:["Find ",(0,i.jsx)(t.code,{children:"?"})]}),", ",(0,i.jsxs)(t.a,{href:"https://code.kx.com/q/ref/equal/",children:["Equal ",(0,i.jsx)(t.code,{children:"="})]}),", ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/in/",children:"in"}),", and ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/within/",children:"within"})," become faster with the application of this Attribute."]}),"\n",(0,i.jsxs)(t.p,{children:["An additional optimization carried out automatically when applying the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute involves the operations executed when applying ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/min/",children:"min"})," and ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/max/",children:"max"})," to a sorted list. Since the list is arranged in ascending order, ",(0,i.jsx)(t.code,{children:"min"})," essentially corresponds to the first element, while ",(0,i.jsx)(t.code,{children:"max"})," corresponds to the last. Let's examine how the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute enhances performance through a few simple examples."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// First we generate a list of numbers from 0 to 100000000 \nq)x:til 100000000\n// We then try to search for the last element in our list and see that this takes 134 milliseconds to do so\nq)\\t x?last x\n134\n// Let's now apply the sorted Attribute and repeat the searches \nq)s:`s#x\nq)\\t s?last s\n0\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["You can use the ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/basics/syscmds/#t-timer",children:(0,i.jsx)(t.code,{children:"\\t"})})," system command to time how long a function takes to execute. Additionally, the system command ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/basics/syscmds/#ts-time-and-space",children:(0,i.jsx)(t.code,{children:"\\ts"})})," gives you information about the execution time in milliseconds and the space used in bytes."]})}),"\n",(0,i.jsxs)(t.p,{children:["As you can see, applying the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute to a list speeds up operations significantly. Even though both lists are sorted from the smallest element to the largest (remember, ",(0,i.jsx)(t.code,{children:"til n"})," creates a list of numbers from ",(0,i.jsx)(t.code,{children:"0 to n-1"}),"), searching for the last element in the list without the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute applied takes roughly 0.2 seconds, while the search in the list with the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute applied returned immediately."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute is the only Attribute that adds no memory overhead when being applied to the data"]})}),"\n",(0,i.jsx)(t.h3,{id:"unique-u",children:(0,i.jsxs)(t.a,{href:"https://code.kx.com/q4m3/8_Tables/#882-unique-u",children:["Unique (",(0,i.jsx)(t.code,{children:"`u#"}),")"]})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute, as the name implies, indicates that the elements of a list are distinct. Applying the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute to a list significantly speeds up the performance of operations such as searching, as KDB/Q can terminate the search upon finding the initial occurrence. When applying the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute to a list, KDB/Q generates a hash table in the background, mapping each unique element of the list to its corresponding index. This transformation shifts the linear search algorithm to a constant lookup with ",(0,i.jsx)(t.code,{children:"O(1)"})," time complexity. As your dataset grows, the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute yields the most substantial performance enhancement, establishing it as the fastest Attribute for lookups among the four Attributes."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's explore what the metadata of the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute might resemble behind the scenes:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:-10?10\n4 3 8 2 9 5 7 0 1 6\nq)group l\n4| 0\n3| 1\n8| 2\n2| 3\n9| 4\n5| 5\n7| 6\n0| 7\n1| 8\n6| 9\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Attempting to apply the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute to a list of non-unique elements results in my favorite ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/B_Error_Messages/",children:"KDB/Q error"})," of all time: u-fail. It's KDB/Q's unique way of telling you that you that there's still much to learn."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)`u#1 2 2 3 4\n'u-fail\n  [0]  `u#1 2 2 3 4\n         ^\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"danger",children:(0,i.jsxs)(t.p,{children:["Each of the three Attributes\u2014",(0,i.jsx)(t.strong,{children:"unique"}),", ",(0,i.jsx)(t.strong,{children:"grouped"}),", and ",(0,i.jsx)(t.strong,{children:"parted"}),"\u2014introduces a memory overhead when being applied to a list. Further details on this topic will be covered in a subsequent section of this post."]})}),"\n",(0,i.jsx)(t.h3,{id:"parted-p",children:(0,i.jsxs)(t.a,{href:"https://code.kx.com/q4m3/8_Tables/#883-parted-p",children:["Parted (",(0,i.jsx)(t.code,{children:"`p#"}),")"]})}),"\n",(0,i.jsxs)(t.p,{children:["Assigning the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute to a list indicates that elements with the same value are adjacent, appearing next to one another. The following, simple example should illustrate a parted list."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)p:2 2 3 3 3 4 4 4 9 9 1 1 1 1\n"})}),"\n",(0,i.jsxs)(t.p,{children:["While the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute is the optimal choice for a list without duplicate elements, the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute can be applied to a list with duplicate values. However, it's essential to note that, to apply the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute, all elements with the same value must be adjacent to each other. This can be easily achieved by sorting the list."]}),"\n",(0,i.jsx)(t.p,{children:"Let's check this out"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Create a list of 20 random values between 0 and 2\nq)20?3\n2 1 2 1 1 0 2 2 0 0 0 0 2 2 1 1 2 2 1 1\n// sort the list\nq)asc 20?3\n`s#0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2\n// Apply the parted Attribute\nq)`p#asc 20?3\n`p#0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 2 2 2 2 2\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["As you can see, KDB/Q automatically applies the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute when you sort a list (this can be seen by the ",(0,i.jsx)(t.code,{children:"`s#"})," symbol in front of the list). However, we can still apply the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute after we sorted the list using ",(0,i.jsx)(t.code,{children:"`p#"})]})}),"\n",(0,i.jsxs)(t.p,{children:["Like the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute, when you apply the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute to a list, KDB/Q generates a hash table in the background. This hash table maps each unique element of the list to the starting index of the block of equal elements. Essentially, it associates the first index of each contiguous block with its corresponding unique element. The following example should provide a clearer understanding of this concept."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Let's consider the previous example of a list of 20 random numbers between 0 and 3\nq)show l:asc 20?3\n`s#0 0 0 0 0 0 1 1 1 1 1 1 2 2 2 2 2 2 2 2\nq)first each group l\n0| 0\n1| 6\n2| 12\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As evident from the above example, we have a list of three numbers repeated multiple times. Sorting the list creates contiguous blocks where each element with the same value is adjacent. The ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute will then map the first index of each distinct element to the corresponding element and store this mapping in a hash table."]}),"\n",(0,i.jsx)(t.p,{children:"As you can see, the element with the value 0 starts at index 0, the element with value 1 starts at index 6 and the element with value 2 starts at index 12."}),"\n",(0,i.jsx)(t.h3,{id:"grouped-g",children:(0,i.jsxs)(t.a,{href:"https://code.kx.com/q4m3/8_Tables/#884-grouped-g",children:["Grouped (",(0,i.jsx)(t.code,{children:"`g#"}),")"]})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute stands out as the most versatile Attribute, as it can be applied to any list, regardless of its structure. When applying the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute, KDB/Q generates a hash table in the background, mapping each index of every distinct element to its corresponding hash value. Due to the maintenance of a hash table with all indexes, the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute incurs the highest memory overhead and is most effective when handling data without a specific order. Further details on this can be found in the later section of this post."]}),"\n",(0,i.jsx)(t.p,{children:"Below example should illustrate the functionality of the group Attribute:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:100?10\n6 0 1 4 7 6 8 1 8 3 0 7 6 4 6 5 4 2 5 7 7 7 6 2 9 2 4 4 7 9 3 2 1 8 3 1 7 2 0 8 0 5 8 9 6 6 3 8 6 5 7 7 0 4 5 0 1 7 8 3 2 1 8 7 6 0 7 7 5 5 0 8 9 7 4 7 7 5 9 1 4 3 9 8 9 9 5 4 0 4 3 8 0 7 9 7 8 9 3 9\nq)group l\n6| 0 5 12 14 22 44 45 48 64\n0| 1 10 38 40 52 55 65 70 88 92\n1| 2 7 32 35 56 61 79\n4| 3 13 16 26 27 53 74 80 87 89\n7| 4 11 19 20 21 28 36 50 51 57 63 66 67 73 75 76 93 95\n8| 6 8 33 39 42 47 58 62 71 83 91 96\n3| 9 30 34 46 59 81 90 98\n5| 15 18 41 49 54 68 69 77 86\n2| 17 23 25 31 37 60\n9| 24 29 43 72 78 82 84 85 94 97 99\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As evident, the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute establishes a mapping of every index for each distinct element to its corresponding element. This characteristic makes the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute unique as it is the only Attribute that remains consistently maintained when appending elements to the list."]}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["When adding a new element to the end of a sorted list which has the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute applied, KDB/Q  will only keep the Attribute pesisted if the new element adheres to the sorted property of the list."]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:`s#til 5\n`s#0 1 2 3 4\nq)show l,:5\n`s#0 1 2 3 4 5\nq)show l,:2\n0 1 2 3 4 5 2\n"})})]}),"\n",(0,i.jsx)(t.h2,{id:"applying-attributes",children:"Applying Attributes"}),"\n",(0,i.jsxs)(t.p,{children:["Having explored the definition of each Attribute and its functioning, let's delve into something more hands-on and take a look at how Attributes are assigned to a list that aligns with the properties of the corresponding Attribute. Applying an Attribute couldn't be easier, you simply use the character symbol of the respective Attribute and use ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/set-attribute/#set-attribute",children:(0,i.jsx)(t.code,{children:"#"})})," to apply the Attribute. Let's look at some examples"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Sorted Attribute"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:`s#til 10\n`s#0 1 2 3 4 5 6 7 8 9\nq)show l:asc 10?100\n`s#22 22 38 50 51 51 52 57 79 81\n// Applying the sorted Attribute on a non-sorted list will throws a s-fail error\nq)`s#10?100\n's-fail\n  [0]  `s#10?100\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["Sorting a list in ascending order will automatically apply the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute"]})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Unique Attribute"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"/// Generate 10 random numers between 0 and 100 without repetition\nq)show l:`u#-10?100\n`u#82 69 49 62 97 67 34 0 83\n// Applying the unique Attribute to a non-unique list of elements throws a u-fail error\nq)`u#2 2 3 4 5 5 6\n'u-fail\n  [0]  `u#2 2 3 4 5 5 6\n         ^\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Parted Attribute"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:`p#raze 3#'1 2 3\n`p#1 1 1 2 2 2 3 3 3\n// !!!! Applying the parted Attribute to a non-parted list will also throw a u-fail error !!!!\nq)show l:`p#raze 3#'1 2 3 1\n'u-fail\n  [0]  show l:`p#raze 3#'1 2 3 1\n                ^\nq))\\\nq)raze 3#'1 2 3 1\n1 1 1 2 2 2 3 3 3 1 1\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Grouped Attribute"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:`g#10?3\n`g#0 0 1 0 0 0 2 1 1 0\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute is the only Attribute that can be applied to any list"]})}),"\n",(0,i.jsx)(t.h2,{id:"removing-attributes",children:"Removing Attributes"}),"\n",(0,i.jsxs)(t.p,{children:["In order to remove an Attribute, simply use the empty symbol character ",(0,i.jsx)(t.code,{children:"`"})," and the the ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/set-attribute/#set-attribute",children:(0,i.jsx)(t.code,{children:"`#"})})," operator"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)l:`s#1 2 2\nq)l\n`s#1 2 2\nq)`#l\n1 2 2\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Verifying the Attribute applied on a list"})}),"\n",(0,i.jsxs)(t.p,{children:["You can verify whether a list has an Attribute or not by using the ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/attr/",children:(0,i.jsx)(t.code,{children:"attr"})})," keyword."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)attr 2 3 4\n`\nq)attr asc 2 3 4\n`s\nq)attr `#2 3 4\n`\nq)attr `s#2 3 4\n`s\n"})}),"\n",(0,i.jsx)(t.h2,{id:"applying-attributes-to-table-columns",children:"Applying Attributes to table columns"}),"\n",(0,i.jsxs)(t.p,{children:["Given that the individual columns of a table are basically lists, applying an Attribute to a column of a table is as straightforward as applying an Attribute to a list. The syntax however is slightly different and you have to use an ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#95-the-update-template",children:(0,i.jsx)(t.code,{children:"update"})}),"  statement. ",(0,i.jsx)(t.strong,{children:"Note:"})," If you are not familiar with ",(0,i.jsx)(t.code,{children:"q-sql"})," and how to query tables I suggest to read ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/",children:"Chapter 9: Queries - q-sql"}),' of "Q for Mortals" by Jeffry A. Borror.']}),"\n",(0,i.jsx)(t.p,{children:"Let's create a table first"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)table:([] a:10?100; b:10?`3)\nq)show table:([] a:10?100; b:10?`3)\na  b\n------\n53 lcb\n40 jap\n34 glk\n49 lmj\n32 ajb\n43 khi\n21 pho\n43 kib\n20 fod\n38 ecj\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We then use the ",(0,i.jsx)(t.code,{children:"meta"})," keyword to inspect the meta data of our table and see that there is no Attribute (column a) applied."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)meta table\nc| t f a\n-| -----\na| j\nb| s\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["You can use ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/meta/",children:"meta"})," to inspect the meta data of a table"]})}),"\n",(0,i.jsxs)(t.p,{children:["Sorting a table will automatically apply the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute rather than the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)meta asc table\nc| t f a\n-| -----\na| j   p\nb| s\n"})}),"\n",(0,i.jsxs)(t.p,{children:["However, we can apply the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute to a table with the following update statement:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)meta t:update `s#a from asc table\nc| t f a\n-| -----\na| j   s\nb| s\n"})}),"\n",(0,i.jsx)(t.h2,{id:"operations-on-lists-with-attributes",children:"Operations on lists with Attributes"}),"\n",(0,i.jsxs)(t.p,{children:["Because Attributes, except for the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute, are rather descriptive than prescriptive, any operation on lists that contradicts the property of the applied Attribute will result in the removal of the Attribute from the list. The ",(0,i.jsx)(t.strong,{children:"sorted"}),", ",(0,i.jsx)(t.strong,{children:"grouped"}),", and ",(0,i.jsx)(t.strong,{children:"unique"})," Attributes are retained in memory when you add a new element to a list, provided the new element adheres to the properties of the Attribute. The ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute on the other hand will always be removed, no matther the operation."]}),"\n",(0,i.jsx)(t.h3,{id:"operations-on-attributes-in-memory",children:"Operations on Attributes in Memory"}),"\n",(0,i.jsx)(t.p,{children:"As explained preserving the applied Attribute when adding elements to a list depends on the new element adhering to the properties of the Attribute. Conversely, removing elements from a list always results in the removal of the Attribute. Naturally, any operation that contravenes the properties of the Attribute will also lead to its removal."}),"\n",(0,i.jsx)(t.h4,{id:"sorted-lists",children:"Sorted Lists"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:`s#1 2 3\n`s#1 2 3\n// Amend an element that maintains the sorted Attribute\nq)show l,:4\n`s#1 2 3 4\n// Amend an element that removes the sorted Attribute\nq)show l,:3\n1 2 3 4 3\n// Create a sorted list again\nq)show l:`s#1 2 3 4\n`s#1 2 3 4\n//  Deleting the element at index 1 will remove the sorted Attribute \nq)l _ 1\n1 3 4\nq)l except 2\n1 3 4\n// Deleting the first element of the list removes the sorted Attribute\nq)1_l\n2 3 4\n// Deleting the last element of the list removes the sorted Attribute\nq)-1_l\n1 2 3\n"})}),"\n",(0,i.jsx)(t.h4,{id:"unique-lists",children:"Unique Lists"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"q)show l:`u#1 2 3\n`u#1 2 3\nq)show l,:4\n`u#1 2 3 4\nq)show l,:4\n1 2 3 4 4\nq)l except 4\n1 2 3\nq)l _ 1\n1 3 4\nq)1_l\n2 3 4\nq)-1_l\n1 2 3\n"})}),"\n",(0,i.jsx)(t.h4,{id:"parted-lists",children:"Parted Lists"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Create a parted list\nq)show l:`p#raze 3#'1 2 3\n`p#1 1 1 2 2 2 3 3 3\n// Amending an element to a parted list will remove the Attribute even if the parted structure is maintained\nq)show l,:4\n1 1 1 2 2 2 3 3 3 4\nq)show l:`p#raze 3#'1 2 3\n`p#1 1 1 2 2 2 3 3 3\n// Deleting elements from a parted list will remove the Atttribute\nq)show l _ 1\n1 1 2 2 2 3 3 3\nq)show l:`p#raze 3#'1 2 3\n`p#1 1 1 2 2 2 3 3 3\nq)show l _:1\n1 1 2 2 2 3 3 3\nq)show l:`p#raze 3#'1 2 3\n`p#1 1 1 2 2 2 3 3 3\nq)show l:l except 2\n1 1 1 3 3 3\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"danger",children:(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute is distinctive in that it will be removed irrespective of the operation applied. Even when appending a new element that aligns with the properties of the parted list, the Attribute will still be eliminated."]})}),"\n",(0,i.jsx)(t.h4,{id:"grouped-lists",children:"Grouped Lists"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Create a grouped list\nq)show l:`g#10?2\n`g#1 1 1 0 1 1 1 1 1 1\n// Amending a new element to a grouped list will maintain the grouped Attribute no matter what\nq)show l,:1\n`g#1 1 1 0 1 1 1 1 1 1 1\nq)show l,:2\n`g#1 1 1 0 1 1 1 1 1 1 1 2\nq)show l _ 1\n1 1 0 1 1 1 1 1 1 1 2\nq)show l _ 2\n1 1 0 1 1 1 1 1 1 1 2\nq)show l except 1\n0 2\nq)show 1_l\n1 1 0 1 1 1 1 1 1 1 2\nq)show -1_l\n1 1 1 0 1 1 1 1 1 1 1\n"})}),"\n",(0,i.jsx)(t.p,{children:"Checking whether the mentioned properties are valid for in-memory tables is a task left for the curious reader."}),"\n",(0,i.jsx)(t.h3,{id:"operations-on-attributes-on-disk",children:"Operations on Attributes on Disk"}),"\n",(0,i.jsx)(t.p,{children:"Let's now have a look at what behaviour operations on Attributes on Disk have:"}),"\n",(0,i.jsx)(t.h4,{id:"sorted-lists-on-disk",children:"Sorted Lists on Disk"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'q)\\pwd\n"/Users/Alexander/repos/testing/attributes"\nq)\\ls\n// Create a sorted list and save it to disk\nq)`:l set `s#1 2 3\n`:l\n// Load the content of the variable back into memory\nq)get `:l\n`s#1 2 3\n// Amend a new element that preservers the sorted Attribute and save it to disk\nq).[`:l;();,;4]\n`:l\n// When loading the variable back to memory, we can see that the sorted Attribute was maintained\nq)get `:l\n`s#1 2 3 4\n'})}),"\n",(0,i.jsx)(t.h2,{id:"memory-overhead-of-attributes",children:"Memory Overhead of Attributes"}),"\n",(0,i.jsxs)(t.p,{children:["While adding Attributes to your structured list can enhance performance significantly, they also introduce some memory overhead. All Attributes except the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute will contribute to memory overhead in your processes. Only the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute will not introduce any memory overhead. The subsequent section will discuss his memory overhead and should be thoroughly examined for the optimal application of Attributes. Individual testing is recommended to assess whether the performance improvement resulting from the application of an Attribute is justified."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Attribute"}),(0,i.jsx)(t.th,{children:"Memory overhead in bytes [*]"}),(0,i.jsx)(t.th,{children:"Notes"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["sorted ",(0,i.jsx)(t.code,{children:"`s#"})]}),(0,i.jsx)(t.td,{children:"0"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["unique ",(0,i.jsx)(t.code,{children:"`u#"})]}),(0,i.jsx)(t.td,{children:"16*n"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["parted ",(0,i.jsx)(t.code,{children:"`p#"})]}),(0,i.jsx)(t.td,{children:"24*u"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["grouped ",(0,i.jsx)(t.code,{children:"`g#"})]}),(0,i.jsx)(t.td,{children:"(24*u)+4*n"}),(0,i.jsxs)(t.td,{children:["Since Q ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/releases/ChangesIn3.0/",children:"v3.0"})," this should be 8 bytes as integer changed from 32bit to 64 bit"]})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["[*] Source: ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/wp/data-management/",children:"https://code.kx.com/q/wp/data-management/"})]}),"\n",(0,i.jsx)(t.p,{children:"If you're curious about how we arrived at these figures, allow me to provide an explanation."}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute is clear-cut; it's the sole Attribute that doesn't introduce any memory overhead. However, for the remaining Attributes\u2014",(0,i.jsx)(t.strong,{children:"unique"}),", ",(0,i.jsx)(t.strong,{children:"parted"}),", and ",(0,i.jsx)(t.strong,{children:"grouped"}),"\u2014KDB/Q generates a hash map in the background. Each distinct element gets hashed to a GUID ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/#datatypes",children:"datatype"}),", which occupies 16 bytes. Consequently, the ",(0,i.jsx)(t.strong,{children:"unique"})," Attribute incurs a memory overhead of 16 bytes multiplied by ",(0,i.jsx)(t.code,{children:"n"}),", where ",(0,i.jsx)(t.code,{children:"n"})," represents the count of unique elements."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute similarly consumes 16 bytes for each unique element ",(0,i.jsx)(t.code,{children:"u"}),". However, due to the nature of the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute, which retains the index of the initial element in a block of contiguous, distinct elements, this index points to a list of uniform values. A pointer to a list requires 8 bytes, thereby leading to the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute requiring ",(0,i.jsx)(t.code,{children:"(16+8)"})," bytes times ",(0,i.jsx)(t.code,{children:"u"})," elements."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute, being the most memory-intensive among all Attributes, demands precisely the same number of bytes as the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute. However, since the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute stores not only the initial index of a continuous list of unique elements but also every index of all unique elements dispersed throughout the list, it consumes an extra 4 bytes per index of each element (as indexes are represented as integers requiring 4 bytes). Consequently, the total memory required for the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute is ",(0,i.jsx)(t.code,{children:"(16+8)*u+4n"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"when-to-use-attributes",children:"When to use Attributes"}),"\n",(0,i.jsx)(t.p,{children:"Due to the above mentioned memory overhead, KX does not advise utilizing Attributes on data structures with fewer than 1 million elements. This is also the reason why Attributes are not applied by default to lists that conform to the structure of a respective Attribute. Additionally, as your dataset expands, and KDB/Q is required to maintain a hash table in the background, operations may experience a slowdown since the hash table needs updates whenever a new element is inserted into the list. It is crucial to test your specific use case to determine whether applying an Attribute yields performance benefits. Blindly applying Attributes is discouraged."}),"\n",(0,i.jsx)(t.h2,{id:"attributes-in-the-kdb-tick-stack",children:"Attributes in the KDB-Tick Stack"}),"\n",(0,i.jsx)(t.p,{children:"So far we have we have covered quite a bit of theoretical knowledge about Attributes with some basic applications on simple lists or tables. However, as a KDB/Q developer our task is to build large, efficient systems, that go far beyond the application of simple lists. Let's direct our attention to the KDB/Q Tick setup, exploring where Attributes should be applied and identifying the most suitable Attribute for each of the processes."}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["To revisit your understanding of the KDB/Q Tick setup, you can review my earlier post available ",(0,i.jsx)(t.a,{href:"https://www.defconq.tech/docs/architecture/plain",children:"here"})]})}),"\n",(0,i.jsx)(t.h3,{id:"attributes-and-the-tickerplant",children:"Attributes and the Tickerplant"}),"\n",(0,i.jsxs)(t.p,{children:["In any KDB/Q Tick setup, the central component is the Tickerplant. Despite the fact that this process stores minimal or no data in memory (and, if it does, it's only for a brief duration), it remains crucial to apply the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute to the ",(0,i.jsx)(t.code,{children:"time"})," column and the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute to the ",(0,i.jsx)(t.code,{children:"sym"})," column of each table in the schemas held in memory. This practice is of upmost importance. When a real-time subscriber connects to the Tickerplant, it receives an empty schema for each table it subscribes to. Upon initializing these schemas, the Tickerplant's Attributes are retained within the schemas of the real-time subscriber."]}),"\n",(0,i.jsxs)(t.p,{children:["Despite the fact that the Tickerplant receives real-time data in chronological order, it is crucial for us to apply the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute to the ",(0,i.jsx)(t.code,{children:"time"})," column of each process. As a reminder, applying the sorted Attribute to a list in KDB/Q changes the linear search algorithm to a binary search, resulting in a substantial enhancement in the performance of search queries."]}),"\n",(0,i.jsxs)(t.p,{children:["The second Attribute we implement in the table schemas of our Tickerplant is the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute. Considering the scattered structure of the data we capture, it is logical to apply the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute to the ",(0,i.jsx)(t.code,{children:"sym"})," column of our tables. Unlike other Attributes, the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute doesn't demand a specific structure for our lists and remains intact when adding new items to the list. Again, this Attribute will be retained in the schemas of every real-time subscriber that subscribes to the tables of the Tickerplant."]}),"\n",(0,i.jsx)(t.h3,{id:"real-time-database-rdb-and-other-real-time-subscribers-rts",children:"Real-time Database (RDB) and other Real-Time Subscribers (RTS)"}),"\n",(0,i.jsxs)(t.p,{children:["As previously mentioned, the Real-time Database, along with any other Real-time Subscriber connected to the Tickerplant, will automatically adopt the Attributes applied to the table schemas in the Tickerplant. This results in the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute being applied to the ",(0,i.jsx)(t.code,{children:"time"})," column of our tables, and the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute being applied to the ",(0,i.jsx)(t.code,{children:"sym"})," column. Considering the scattered nature of the symbols in our data, any Attribute other than the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute would be impractical. Applying the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute, for instance, would result in losing the Attribute as soon as the second message is received, as the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute does not persist through updates. Additionally, achieving a parted structure would require sorting the data by symbol after every update, which, given the typical volume of real-time data, would be time-consuming and render the Real-Time Database pretty much useless."]}),"\n",(0,i.jsxs)(t.p,{children:["While it is possible to apply more than one ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute to a table\u2014such as using the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute on the ",(0,i.jsx)(t.code,{children:"sym"})," column and another ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute on the ",(0,i.jsx)(t.code,{children:"exchange"})," column\u2014I would generally discourage this practice. Primarily, the memory overhead significantly increases with each additional ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute, as the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute incurs the highest memory cost. Moreover, as your dataset expands, the time required to update the hash table maintained by KDB/Q for each ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute becomes increasingly expensive."]}),"\n",(0,i.jsx)(t.h3,{id:"attributes-and-the-historical-database-hdb",children:"Attributes and the Historical Database (HDB)"}),"\n",(0,i.jsxs)(t.p,{children:["The final process we examine is our Historical Database (HDB). Once intraday data is stored on disk, it typically remains unaltered, with no new data appended. Consequently, we can sort our data before saving it to disk and apply the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute to the ",(0,i.jsx)(t.code,{children:"sym"})," column without concern about losing the Attribute during updates."]}),"\n",(0,i.jsxs)(t.p,{children:["As the data remains static after being stored on disk, applying extra ",(0,i.jsx)(t.strong,{children:"grouped"})," Attributes to columns other than the ",(0,i.jsx)(t.code,{children:"sym"})," poses little to no concern about performance impact as the hash table maintained by KDB/Q is only updates once, specifically during Attribute creation. Additionally, the ample disk memory available compared to process memory eliminates worries about the memory overhead associated with the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute."]}),"\n",(0,i.jsxs)(t.p,{children:["You might be curious about why we would apply multiple ",(0,i.jsx)(t.strong,{children:"grouped"})," Attributes to a table. In the evaluation of the where clause in a q-sql statement, once the first column is employed to narrow down the search, any subsequent Attributes on the remaining columns are disregarded, and a linear search is used for all remaining columns. Since we may not always know all the use cases of our users' q-sql queries, and they might not necessarily want to query the ",(0,i.jsx)(t.code,{children:"sym"})," column as the first column, applying the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute to several columns ensures a performance improvement regardless of the column our users choose to query."]}),"\n",(0,i.jsx)(t.h2,{id:"attributes-and-joins",children:"Attributes and Joins"}),"\n",(0,i.jsx)(t.p,{children:"The main motivation for applying Attributes is to increase the efficiency and performance of search operations. One operation KDB/Q is particularly famous for are joins, asof and window joins to be more specific. During a join operation, one table's column needs to be searched and matched with the keys of the columns in the table to be matched. This scenario is a perfect use case for our Attributes, as they substantially boost the performance of join operations."}),"\n",(0,i.jsxs)(t.p,{children:["When executing an ",(0,i.jsx)(t.code,{children:"asof or window join"})," on in-memory tables, it is crucial to ensure that the ",(0,i.jsx)(t.strong,{children:"grouped"})," Attribute is applied to the ",(0,i.jsx)(t.code,{children:"sym"})," column. Conversely, when conducting a join on data that has been persisted to disk, the ",(0,i.jsx)(t.strong,{children:"parted"})," Attribute enhances the performance of the join operation."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["You can read everything about joins ",(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#99-joins",children:"here"})]})}),"\n",(0,i.jsx)(t.h2,{id:"special-application-of-attributes",children:"Special Application of Attributes"}),"\n",(0,i.jsx)(t.h3,{id:"step-dictionary",children:"Step Dictionary"}),"\n",(0,i.jsxs)(t.p,{children:["A special use case of the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute is when you apply the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute to the keys of a dictionary, essentially creating a step dictionary. This modified dictionary now functions as a step function, enabling you to index into it with a key that may not be present, and it will return the value associated with the key immediately preceding the one you provided. Let me illustrate this with an example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// We first create a dictionary without the sorted Attribute applied\nq)d:0 1 5 10 15!`A`B`C`D`E\nq)d\n0 | A\n1 | B\n5 | C\n10| D\n15| E\n// If we now index into this dictionary with a key that doesn't exists, you will see the null symbol is returned \nq)d 4\n`\n// Now let's apply the sorted Attribute to the dictionary, creating a step function\nq)d:`s#0 1 5 10 15!`A`B`C`D`E\n// Et voila, using 4 as the index, returns B, the value of the largest index smaller than the index we passed\nq)d 4\n`B\n// Using an existing index works as expected \nq)d 5\n`C\n// One more example of a non existing index\nq)d 13\n`D\n"})}),"\n",(0,i.jsx)(t.h3,{id:"sorted-attribute-on-keyed-tables",children:"Sorted Attribute on Keyed Tables"}),"\n",(0,i.jsxs)(t.p,{children:["The notion of a step dictionary functions identically for a keyed table. Applying the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute to a keyed table results in the same step function behavior as observed in a step dictionary. For those interested in understanding, this similarity arises because a keyed table is essentially a dictionary composed of two simple tables. Let's delve into this explanation."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// Create two simple tables\nq)show t1:([] a:0 1 5 10 15)\na\n--\n0\n1\n5\n10\n15\nq)show t2:([] b:5?`3)\nb\n---\nbgh\nifn\nfoh\nkdj\neeg\n// Create a keyed table as dictionary of two simple tables\nq)show kt:t1!t2\na | b\n--| ---\n0 | bgh\n1 | ifn\n5 | foh\n10| kdj\n15| eeg\n// verify the type of kt to show that it's effectively a dictionary\nq)type kt\n99h\n// Index into the keyed table with an existing index\nq)kt 0\nb| bgh\nq)kt 5\nb| foh\n// Index into the keyed table with a non-existing index returns nothing\nq)kt 3\nb|\n// Apply the sorted Attribute to the keyed table to create a step-function behaviour \nq)show kts:`s#kt:t1!t2\na | b\n--| ---\n0 | bgh\n1 | ifn\n5 | foh\n10| kdj\n15| eeg\nq)meta kts\nc| t f a\n-| -----\na| j   s\nb| s\n// Index into the keyed table with an existing index\nq)kts 0\nb| bgh\n// Indexing into the keyed table with a non-existing index will now return a result\nq)kts 3\nb| ifn\nq)kts 12\nb| kdj\n"})}),"\n",(0,i.jsx)(t.h2,{id:"conclustion",children:"Conclustion"}),"\n",(0,i.jsxs)(t.p,{children:["In this post, we took a deep dive into a comprehensive understanding of Attributes, explaining their functionality, application to both simple lists and tables, and the impact of operations on them. We then explored their strategic utilization within a KDB/Q Tick system, emphasizing the importance of ",(0,i.jsx)(t.strong,{children:"sorted"}),",",(0,i.jsx)(t.strong,{children:"grouped"})," and ",(0,i.jsx)(t.strong,{children:"parted"})," Attributes in enhancing performance. Concluding our exploration, we highlighted two special use cases showcasing the versatility of the ",(0,i.jsx)(t.strong,{children:"sorted"})," Attribute in creating step-function dictionaries and keyed tables. This comprehensive overview equips developers with a nuanced understanding of Attributes and their optimal integration into KDB/Q systems."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://code.kx.com/q4m3/8_Tables/#88-attributes",children:"Q For Mortals"})," by Jeffry A. Borror"]}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://code.kx.com/q/ref/set-attribute/",children:"KDB/Q Reference Card - Set Attribute"})}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://amzn.to/40a01Hv",children:"Q Tips"})," by Nick Psaris"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://code.kx.com/q/wp/data-management/",children:"Data Management Whitepaper"})," by Simon Mescal, KX"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://dataintellect.com/blog/adventure-in-retrieving-memory-size-of-kdb-object/",children:"Adventure in retrieving memory size of KDB+ Object"})," by Data Intellect"]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(6540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);