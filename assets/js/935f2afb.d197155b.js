"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8581],{5610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Intro","href":"/docs/intro","docId":"intro","unlisted":false},{"type":"category","label":"KDB/Q Language","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"KDB/Q Unveiled: A Journey into the Pinnacle of Database Technology","href":"/docs/language/history","docId":"language/history","unlisted":false},{"type":"link","label":"Unlocking Unmatched Performance: The Speed Secrets of KDB/Q","href":"/docs/language/speed","docId":"language/speed","unlisted":false},{"type":"link","label":"Unleashing the Power of Time-Series Analysis and Big Data: Why KDB/Q Reigns Supreme","href":"/docs/language/why_KDB","docId":"language/why_KDB","unlisted":false}],"href":"/docs/category/kdbq-language"},{"type":"category","label":"KDB Architecture","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"The Plain Vanilla Tick Setup","href":"/docs/architecture/plain","docId":"architecture/plain","unlisted":false}],"href":"/docs/category/kdb-architecture"},{"type":"category","label":"Important Concepts","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Attributes","href":"/docs/concepts/attributes","docId":"concepts/attributes","unlisted":false},{"type":"link","label":"Memory Management","href":"/docs/concepts/memoryManagement","docId":"concepts/memoryManagement","unlisted":false},{"type":"link","label":"Garbage Collection","href":"/docs/concepts/garbageCollection","docId":"concepts/garbageCollection","unlisted":false},{"type":"link","label":"Amend, Amend At: The Swiss Army knife among KDB/Q operators","href":"/docs/concepts/amend","docId":"concepts/amend","unlisted":false},{"type":"link","label":"Dictionaries and Tables","href":"/docs/concepts/dictionariesTables","docId":"concepts/dictionariesTables","unlisted":false}],"href":"/docs/category/important-concepts"},{"type":"category","label":"Tutorials","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"KDB Tick Explained: A Walkthrough [PART 1]","href":"/docs/tutorials/tick","docId":"tutorials/tick","unlisted":false},{"type":"link","label":"KDB Tick Explained: A Walkthrough [PART 2]","href":"/docs/tutorials/tick2","docId":"tutorials/tick2","unlisted":false}],"href":"/docs/category/tutorials"},{"type":"category","label":"Productivity Tools","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Pulse","href":"/docs/productivity/pulse","docId":"productivity/pulse","unlisted":false}],"href":"/docs/category/productivity-tools"}]},"docs":{"architecture/plain":{"id":"architecture/plain","title":"The Plain Vanilla Tick Setup","description":"A basic KDB/Q Tick setup consists of three  essential elements such as a Tickerplant (TP), a Real-Time Database (RDB), and a Historical Database (HDB). Additionally, this configuration involves the integration of two external processes, namely a Data Feed and a Feed Handler. The provided image below serves as a visual representation of this architectural arrangement.","sidebar":"tutorialSidebar"},"concepts/amend":{"id":"concepts/amend","title":"Amend, Amend At: The Swiss Army knife among KDB/Q operators","description":"Whenever I encounter the @ or . amend or amend at operators, I\'m inevitably reminded of a Swiss Army pocketknife. Just like this versatile multi-tolled knife, the @ or . operators in KDB/Q are multi-functional, capable of solving various tasks. When combined with the expertise of a skilled KDB/Q developer, akin to the resourcefulness of a highly trained soldier or agent like MacGyver, the possibilities are limitless \u2013 you can conquer any challenge with ease.","sidebar":"tutorialSidebar"},"concepts/attributes":{"id":"concepts/attributes","title":"Attributes","description":"A cornerstone principle in KDB/Q, integral to query optimization, is the concept of Attributes. Attributes serve as metadata that can be attached to lists of special forms, dictionaries, or table columns (which are basically lists), amplifying data retrieval speed and consequently enhancing query efficiency and performance. By attaching metadata about the implied structure of the list associated with a specific Attribute, the Q interpreter can enact optimizations, resulting in a notable performance boost. This post not only provides a comprehensive explanation of various Attributes and their properties but also emphasizes their strategic utilization and optimal placement in different scenarios.","sidebar":"tutorialSidebar"},"concepts/dictionariesTables":{"id":"concepts/dictionariesTables","title":"Dictionaries and Tables","description":"In this blog post, we explore two key data types native to KDB/Q: Dictionaries and Tables. Unlike mainstream programming languages like Java, which lack native support for these data types and require alternative structures (e.g., Java HashMap for dictionaries or Java ArrayList for lists of rows to represent tables), KDB/Q inherently supports both Dictionaries and Tables. Understanding these data structures is crucial for leveraging the speed and performance of KDB/Q to build efficient big data applications. In the following sections, we will examine the most important concepts of both data types, a in detail explanation of dictionaries and tables is beyond the scope of this blog post and can be found in Chapter 5 - Dictionaries and Chapter 8 - Tables of Q for Mortals.","sidebar":"tutorialSidebar"},"concepts/garbageCollection":{"id":"concepts/garbageCollection","title":"Garbage Collection","description":"In this blog post, we cover another crucial concept, which if fully understood, can set you apart. Today\'s topic is Garbage Collection, and here\'s the news upfront: There\'s no such thing as Garbage in KDB/Q!! Yes, you read it correctly. Don\'t be caught off guard like I was, discovering this information in a job interview with \\"the QGOD\\" among all KDB/Q developers. Keep reading and learn everything you need to know about this essential topic.","sidebar":"tutorialSidebar"},"concepts/memoryManagement":{"id":"concepts/memoryManagement","title":"Memory Management","description":"This blog post dives into a crucial aspect of real-time data handling: Memory Management. Despite its significance in architectural system design, this topic is not extensively covered in the official KX documentation. A profound comprehension of Memory Management in KDB/Q is crucial for understanding the workings of Garbage Collection in the same environment. In this blog post, I aim to provide a comprehensive overview of Memory Management in KDB/Q, shedding light on essential considerations for designing an efficient system.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Intro","description":"Before we can start learning KDB/Q we first need to have a running version of q installed. Let\'s kickstart our journey!","sidebar":"tutorialSidebar"},"language/history":{"id":"language/history","title":"KDB/Q Unveiled: A Journey into the Pinnacle of Database Technology","description":"In the ever-evolving landscape of programming languages, KDB/Q stands as a testament to innovation and efficiency. This post delves into the origins, evolution, and the ingenious mind behind KDB/Q, unraveling the layers that make it an exceptional database language.","sidebar":"tutorialSidebar"},"language/speed":{"id":"language/speed","title":"Unlocking Unmatched Performance: The Speed Secrets of KDB/Q","description":"In the world of time-series databases, KDB/Q stands as a powerhouse, setting itself apart with unparalleled performance and speed. At the core of its efficiency lies a combination of design principles and unique features that make it the preferred choice for industries dealing with massive datasets and demanding real-time analytics.","sidebar":"tutorialSidebar"},"language/why_KDB":{"id":"language/why_KDB","title":"Unleashing the Power of Time-Series Analysis and Big Data: Why KDB/Q Reigns Supreme","description":"In the vast landscape of programming languages, one particular gem stands out like a beacon of efficiency and unparalleled capabilities \u2014 KDB/Q. This article is not merely a declaration of superiority but a journey into its distinctive features, and unparalleled advantages that make KDB/Q the undisputed champion for time-series analysis and big data applications.","sidebar":"tutorialSidebar"},"productivity/pulse":{"id":"productivity/pulse","title":"Pulse","description":"In this post, we are going to look at Pulse, a real-time data visualization tool that allows you to quickly develop interactive, real-time dashboards with little to no effort and easily share it with your colleagues or users. It excels in presenting real-time trade blotters, price graphs, or any contextual or positional data crucial for traders. Tailored specifically for the financial industry, Pulse is particular well suited for managing big data in a time-critical and responsive manner.","sidebar":"tutorialSidebar"},"tutorials/tick":{"id":"tutorials/tick","title":"KDB Tick Explained: A Walkthrough [PART 1]","description":"In this blog post, we\'re diving into the code of a simple Tickerplant. We\'ll break it down line by line, explaining what each part does and how it fits into the big picture. This will not only demystify Tickerplants but also shed light on important KDB/Q programming concepts. By doing so, you\'ll gain insights into the inner workings of a Tickerplant and acquire a deeper understanding of key concepts in the KDB/Q programming language.","sidebar":"tutorialSidebar"},"tutorials/tick2":{"id":"tutorials/tick2","title":"KDB Tick Explained: A Walkthrough [PART 2]","description":"In my previous tutorial I walked you through all the helper functions you can find in the u.q file of a plain vanilla Tickerplant. I provided a comprehensive overview of the inner workings of these functions and how they interact with each other. It is now time to circle back and continue with our step-by-step examination of the main tick.q file and complete complete our understanding of the Tickerplant. If you\'d like to revisit our previous discussions or if you\'re new to this tutorial, you can access my earlier post here.","sidebar":"tutorialSidebar"}}}')}}]);