"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1831],{80522:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var s=n(74848),i=n(28453);const a={sidebar_position:6},r="Pulse Powered Alpha: Building your First Trading Strategy with KDB-X and Pulse",o={id:"tutorials/strategy",title:"Pulse Powered Alpha: Building your First Trading Strategy with KDB-X and Pulse",description:"In the previous tutorials, we explored how to build a Tickerplant, pull real-time market data from providers like Yahoo and Databento, and create a research-focused historical database. Now it\u2019s time to bring all these pieces together. In this tutorial, we\u2019ll build our first (simple) trading strategy, visualize it in a dashboard, and even demonstrate how to create a backtesting engine to evaluate its performance.",source:"@site/docs/tutorials/strategy.mdx",sourceDirName:"tutorials",slug:"/tutorials/strategy",permalink:"/docs/tutorials/strategy",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Streaming Smarter: Real-Time Market Data with Kola, Python, and Databento",permalink:"/docs/tutorials/realTimeStocksUpdate"},next:{title:"Productivity Tools",permalink:"/docs/category/productivity-tools"}},l={},d=[{value:"Before We Dive In: Gearing Up for the Strategy Build",id:"before-we-dive-in-gearing-up-for-the-strategy-build",level:2},{value:"Blueprints Before Code: Designing Your Trading Engine the Right Way",id:"blueprints-before-code-designing-your-trading-engine-the-right-way",level:2},{value:"Feeding the Beast: Bringing Data Into Your Trading Engine",id:"feeding-the-beast-bringing-data-into-your-trading-engine",level:2},{value:"Complex Event Processing Engine (CEP): Effortless Business Logic in Motion",id:"complex-event-processing-engine-cep-effortless-business-logic-in-motion",level:2},{value:"Pulse: The Catwalk for Your Data Model",id:"pulse-the-catwalk-for-your-data-model",level:2},{value:"Backtesting for Alpha: Turning Strategy Into Performance",id:"backtesting-for-alpha-turning-strategy-into-performance",level:2},{value:"Video Tutorial",id:"video-tutorial",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"pulse-powered-alpha-building-your-first-trading-strategy-with-kdb-x-and-pulse",children:"Pulse Powered Alpha: Building your First Trading Strategy with KDB-X and Pulse"}),"\n",(0,s.jsxs)(t.p,{children:["In the previous tutorials, we explored how to build a Tickerplant, pull real-time market data from providers like Yahoo and ",(0,s.jsx)(t.a,{href:"https://databento.com",children:"Databento"}),", and create a research-focused historical database. Now it\u2019s time to bring all these pieces together. In this tutorial, we\u2019ll build our first (simple) trading strategy, visualize it in a dashboard, and even demonstrate how to create a backtesting engine to evaluate its performance."]}),"\n",(0,s.jsx)(t.p,{children:"Here\u2019s what the final dashboard will look like."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard",src:n(28103).A+"",width:"1917",height:"1102"})}),"\n",(0,s.jsx)(t.h2,{id:"before-we-dive-in-gearing-up-for-the-strategy-build",children:"Before We Dive In: Gearing Up for the Strategy Build"}),"\n",(0,s.jsxs)(t.p,{children:["Since we\u2019ll be reusing parts of the code introduced in earlier tutorials, it\u2019s helpful to familiarise yourself with those foundations, they\u2019re explained in detail and will make this tutorial much easier to follow. Don\u2019t worry, though: all new additions will be fully explained as we go.\nTo visualise our trading strategy and build the dashboard, you\u2019ll also need to install ",(0,s.jsx)(t.strong,{children:"Pulse"}),". Installation instructions are provided below."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Prerequisites:"})}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Review the previous tutorials to understand the core building blocks we\u2019ll build on","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.defconq.tech/docs/tutorials/tick",children:"KDB Tick Explained: A Walkthrough [PART 1]"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.defconq.tech/docs/tutorials/tick2",children:"KDB Tick Explained: A Walkthrough [PART 2]"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.defconq.tech/docs/tutorials/researchHDB",children:"Back to the Future: Building Your Research HDB for Stock Market Insights"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.defconq.tech/docs/architecture/plain",children:"The Plain Vanilla Tick Setup"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["Install Pulse: Follow the instructions ",(0,s.jsx)(t.a,{href:"https://www.timestored.com/pulse/",children:"here"})]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"blueprints-before-code-designing-your-trading-engine-the-right-way",children:"Blueprints Before Code: Designing Your Trading Engine the Right Way"}),"\n",(0,s.jsxs)(t.p,{children:["Before we jump into writing any code, it\u2019s worth pausing to look at the most critical part of building any solid application: ",(0,s.jsx)(t.strong,{children:"the architecture"}),". Even a small, ",(0,s.jsx)(t.em,{children:"simple"})," system benefits enormously from a clean, extensible design. With that mindset, here\u2019s how we\u2019ll structure our trading engine:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Data Ingestion:"})," A dedicated process responsible for feeding market data into our Tickerplant."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Tickerplant:"})," The heartbeat of every KDB-X application. It streams incoming data to all real-time subscribers and writes each update to a Tickerplant Log file, ensuring the system can recover seamlessly if needed."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Complex Event Processing Engine (CEP):"})," This component serves as our trading engine, executing the strategy logic and generating signals based on the incoming data."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Architecture",src:n(37573).A+"",width:"651",height:"461"})}),"\n",(0,s.jsx)(t.h2,{id:"feeding-the-beast-bringing-data-into-your-trading-engine",children:"Feeding the Beast: Bringing Data Into Your Trading Engine"}),"\n",(0,s.jsx)(t.p,{children:"For this tutorial, we\u2019ll use end-of-day files from Yahoo Finance, the same dataset we worked with in an earlier tutorial. You can reuse those files or download fresh ones if you prefer. We'll write a function that loads these files into memory and publishes the data to our Tickerplant. And since we also want to build a backtesting engine, we\u2019ll stream the historical data on a timer to simulate a \u201ctime-lapse\u201d playback of market history."}),"\n",(0,s.jsx)(t.p,{children:"Let\u2019s get started."}),"\n",(0,s.jsxs)(t.p,{children:["First, we define the table schema for the data we want to load and gather the filenames of all historical data files into a variable. When following along, remember to update the file path to match the location of your own data. Also make sure that the folder contains only data files, as the ",(0,s.jsx)(t.code,{children:"key"})," operator will list everything inside that directory."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'// Define table schema for data we are going to load\ndata:([] time:`timestamp$(); sym:`symbol$(); feedHandlerTime: `timestamp$(); open: `float$(); high: `float$(); low: `float$(); close: `float$(); volume: `long$());\n\n// List of files we want to load (Change this path to your file location. Note:folder should only contain your data as everything in the folder will be loaded)\nfileList:key `$":/Users/alexanderunterrainer/repos/defconQ/projects/tradingStrategy/stock_data";\n\nloadData:{[file]\n    // Extract the name of the stock from the file name\n    name:`$first "_" vs string file;\n    // Load the data for the specific file, update the sym column with the stock name and a feedHandlerTime\n    `data insert update sym:name,`timestamp$`date$time,feedHandlerTime:time from `time`open`high`low`close`volume xcol ("PFFFFJ";enlist csv) 0:hsym file;\n };\n'})}),"\n",(0,s.jsx)(t.p,{children:"After defining our function, we can run it"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"q)loadData each fileList;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Before we can start streaming any data, we first need to bring up the Tickerplant. For this tutorial, we\u2019re using an even more stripped-down version of the plain vanilla Tickerplant. If you\u2019d like a detailed, line-by-line explanation of how it works, check out my walkthrough linked ",(0,s.jsx)(t.a,{href:"https://www.defconq.tech/docs/tutorials/tick",children:"here"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"For now, let\u2019s go ahead and start the Tickerplant."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"alexanderunterrainer@Mac:~/repos/defconQ/projects/tradingStrategy|master\u26a1 \u21d2  qx tick.q sym . -p 5010\nKDB-X 0.1.1 2025.09.29 Copyright (C) 1993-2025 Kx Systems\nq)stocks\ntime sym feedHandlerTime open high low close volume\n---------------------------------------------------\nq)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Once the Tickerplant is up and running, we can connect to it using ",(0,s.jsx)(t.code,{children:"hopen"}),", which creates a connection handle between our feed handler and the Tickerplant. From there, we\u2019re able to publish our data. Since we haven\u2019t started any real-time subscribers yet, the Tickerplant will simply write the updates to its log file without broadcasting them to any subscribers."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"q)h:hopen 5010\nq)h(`.u.upd;`stocks;data)\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now that our data pipeline is in place, it\u2019s time to build the Complex Event Processing Engine that will execute our trading strategy."}),"\n",(0,s.jsx)(t.h2,{id:"complex-event-processing-engine-cep-effortless-business-logic-in-motion",children:"Complex Event Processing Engine (CEP): Effortless Business Logic in Motion"}),"\n",(0,s.jsx)(t.p,{children:"For our trading strategy, we\u2019ll implement a straightforward moving average crossover model. It uses two averages: a short-term 50-day moving average and a long-term 200-day one. The signal rules are simple: when the short average crosses above the long average, we generate a buy signal; when it crosses below, we trigger a sell signal. This captures the classic idea that prices tend to revert toward their longer-term trend over time."}),"\n",(0,s.jsxs)(t.p,{children:["Calculating the moving averages couldn\u2019t be easier, KDB-X gives us the ",(0,s.jsx)(t.code,{children:"mavg"})," keyword out of the box. This is another perfect example of why it excels at analytical workloads. Using ",(0,s.jsx)(t.code,{children:"mavg"}),", we can directly update our table with both moving averages. The only detail to watch out for is that our dataset contains multiple symbols, so we need to compute the averages for each symbol. That\u2019s easily achieved using a ",(0,s.jsx)(t.code,{children:"by"})," clause as you can see in the line below"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"q)update sma50:mavg[50;close],sma200:mavg[200;close] by sym from `stocks\n`stocks\n"})}),"\n",(0,s.jsx)(t.p,{children:"So far so good, we\u2019ve made solid progress. But now it\u2019s time to bring our data to life. Let\u2019s start building our dashboard. As a reminder, this is what the final result will look like:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard",src:n(28103).A+"",width:"1917",height:"1102"})}),"\n",(0,s.jsx)(t.h2,{id:"pulse-the-catwalk-for-your-data-model",children:"Pulse: The Catwalk for Your Data Model"}),"\n",(0,s.jsxs)(t.p,{children:["For those who know me, I\u2019m much more of a backend person, I usually steer clear of UI and front-end work. But Pulse is so simple and intuitive that even I found myself ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"almost"})})," enjoying the UI side of things.\nOnce you\u2019ve installed Pulse (installation guide linked ",(0,s.jsx)(t.a,{href:"https://www.timestored.com/pulse/",children:"here"}),"), you can launch it directly from your terminal. This opens a new tab in your browser where you can begin designing your dashboard. The first step is to set up a connection to the KDB-X process that holds our data."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"// Start Pulse from your terminal. This will launch Pulse and open the landing page\nalexanderunterrainer@Mac:~|\u21d2  java -jar pulse.jar\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Landing Page",src:n(60071).A+"",width:"1917",height:"924"}),"\n",(0,s.jsx)(t.strong,{children:"Pulse Landing Page"})]}),"\n",(0,s.jsxs)(t.p,{children:["Now let\u2019s create a new connection by specifying the host and port. In our example, the process is running on ",(0,s.jsx)(t.code,{children:"localhost"})," using port ",(0,s.jsx)(t.code,{children:"5001"}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Add Connection",src:n(41774).A+"",width:"1065",height:"975"})}),"\n",(0,s.jsx)(t.p,{children:"With the connection configured, we can move on to creating our dashboard. Go ahead and add a new one to get started."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Add Connection",src:n(12464).A+"",width:"1217",height:"318"})}),"\n",(0,s.jsx)(t.p,{children:"A new dashboard will open in design mode, and we can start adding components right away. I\u2019m a big believer in the \u201clow-hanging fruit principle\u201d, tackle the easiest wins first. So let\u2019s begin by charting the volume.\nBefore that, though, let\u2019s quickly save and rename our dashboard."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Save Dashboard",src:n(73854).A+"",width:"500",height:"372"})}),"\n",(0,s.jsxs)(t.p,{children:["Once that\u2019s done, click the ",(0,s.jsx)(t.strong,{children:"Time Series"})," button in the top panel to add a new time-series chart."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Add TimeSeries",src:n(16789).A+"",width:"1522",height:"181"})}),"\n",(0,s.jsx)(t.p,{children:"Pulse will generate a placeholder chart with simulated data, which we can now replace by updating the query to display the volume we\u2019re interested in."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dummy TimeSeries",src:n(89855).A+"",width:"1920",height:"1078"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"// Query for volume\n`time xasc select time,volume from stocks\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Volume Time Series Chart",src:n(66629).A+"",width:"1916",height:"1070"})}),"\n",(0,s.jsxs)(t.p,{children:["Hold on, something looks off. There are far too many data points, and the volume fluctuations don\u2019t make much sense. That\u2019s because our ",(0,s.jsx)(t.code,{children:"stocks"})," table contains data for multiple symbols, so when we chart the volume directly, we\u2019re plotting everything at once. The fix is simple: we add a drop-down selector so we can choose the specific stock we want to display."]}),"\n",(0,s.jsxs)(t.p,{children:["To do this, add a ",(0,s.jsx)(t.strong,{children:"User Form"}),". Click the ",(0,s.jsx)(t.strong,{children:"User Form button"})," in the top panel and place it above your volume chart. Then, in the Form Editor on the right, add a Dropdown component. We can populate the drop-down with our stock symbols by running a simple KDB-X query. Details below."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse User Form",src:n(28692).A+"",width:"1920",height:"1105"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"asc select distinct sym from stocks\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse User Form Stock Query",src:n(39194).A+"",width:"1287",height:"569"}),"\n",(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Volume Stock Dropdown",src:n(54010).A+"",width:"459",height:"628"})]}),"\n",(0,s.jsx)(t.p,{children:"All that\u2019s left is to connect the drop-down to our volume chart so that selecting a symbol updates the chart accordingly. We can do this by referencing the drop-down\u2019s assigned key directly in the chart\u2019s query. The updated query looks like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"`time xasc select time,volume from stocks where sym=`${{key1}}\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard With Stock Dropdown",src:n(65134).A+"",width:"1914",height:"1103"})}),"\n",(0,s.jsx)(t.p,{children:"Not too bad, right? Since our historical dataset spans several decades, it\u2019s useful to control how much of it we display at once. Let\u2019s add another drop-down to let us choose the time range. Later, when we switch to real-time backtesting, this drop-down won\u2019t be needed anymore and can be removed."}),"\n",(0,s.jsx)(t.p,{children:"We start by adding another drop-down to choose the date range we want to display. This time, instead of populating the options with a Q-SQL query, we simply hard-code a list of day counts that correspond to 1, 2, 3, 5, 7, 10, and 15 years. We also include a large value to allow selecting the full time series."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard Period Dropdown",src:n(51296).A+"",width:"702",height:"485"}),"\n",(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard Period Dropdown",src:n(85643).A+"",width:"291",height:"445"})]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we update the volume query to incorporate the drop-down\u2019s key so the chart adjusts based on the selected range. For a small visual upgrade, we switch the chart from a ",(0,s.jsx)(t.strong,{children:"line plot"})," to a ",(0,s.jsx)(t.strong,{children:"bar chart"}),", and just like that, we have a clean, intuitive volume visualization for our stocks."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard Period Query",src:n(10210).A+"",width:"700",height:"466"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"-{{key2}}#select time,volume from stocks where sym=`${{key1}}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Alright, with the volume chart in place, it\u2019s time to move on to the price chart and start implementing our trading strategy. As before, we\u2019ll tackle the easy part first, plotting the price series along with the moving averages."}),"\n",(0,s.jsxs)(t.p,{children:["Just like we did for the volume chart, we\u2019ll add a new time-series component and define a Q-SQL query that selects the ",(0,s.jsx)(t.code,{children:"time"}),", ",(0,s.jsx)(t.code,{children:"close"}),", ",(0,s.jsx)(t.code,{children:"sma50"})," (50-day simple moving average), and ",(0,s.jsx)(t.code,{children:"sma200"})," (200-day simple moving average). As before, we\u2019ll use the values from our drop-downs to limit the chart to a specific stock and chosen time range."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard SMA Chart",src:n(50212).A+"",width:"1919",height:"689"})}),"\n",(0,s.jsx)(t.p,{children:"And just like that, we now have a clean visual of the price data alongside both moving averages. But how do we turn this into trading signals?\nOur rules are simple:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"buy"})," when the short-term moving average (",(0,s.jsx)(t.code,{children:"sma50"}),") crosses above the long-term average (",(0,s.jsx)(t.code,{children:"sma200"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"sell"})," when the short-term moving average (",(0,s.jsx)(t.code,{children:"sma50"}),") crosses below the long-term average (",(0,s.jsx)(t.code,{children:"sma200"}),")."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Instead of jumping straight into solving this on our full dataset, let\u2019s first strip the problem down and build the logic step by step. We\u2019ll start with two simple lists: one for the short moving average and one for the long moving average:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"s: 3 7 8 12 10 11 9 7"})," (short MA)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"l: 5 9 10 11 8 7 12 13"})," (long MA)"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["First, we subtract the long moving average ",(0,s.jsx)(t.code,{children:"l"})," from the short moving average ",(0,s.jsx)(t.code,{children:"s"}),". This tells us whether the short MA is above or below the long MA at each point."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we apply the built-in ",(0,s.jsx)(t.code,{children:"signum"})," function to that result. ",(0,s.jsx)(t.code,{children:"signum"})," returns ",(0,s.jsx)(t.code,{children:"-1"})," for ",(0,s.jsx)(t.strong,{children:"negative"})," values, ",(0,s.jsx)(t.code,{children:"1"})," for ",(0,s.jsx)(t.strong,{children:"positive"})," values, and ",(0,s.jsx)(t.code,{children:"0"})," when the input is ",(0,s.jsx)(t.strong,{children:"zero"}),". We then compare this list against ",(0,s.jsx)(t.code,{children:"0"})," to get a boolean mask indicating where the short MA is below the long MA. This effectively captures when the relationship between the two averages flips from negative to positive (or the other way around)."]}),"\n",(0,s.jsxs)(t.p,{children:["Finally, we use ",(0,s.jsx)(t.code,{children:"deltas"})," on this boolean sequence to generate our trading signals:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["A delta of ",(0,s.jsx)(t.code,{children:"+1"})," \u2192 we buy"]}),"\n",(0,s.jsxs)(t.li,{children:["A delta of ",(0,s.jsx)(t.code,{children:"-1"})," \u2192 we sell"]}),"\n",(0,s.jsxs)(t.li,{children:["A delta of ",(0,s.jsx)(t.code,{children:"0"})," \u2192 we do nothing"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"q)s:3 7 8 12 10 11 9 7\nq)l:5 9 10 11 8 7 12 13\nq)s-l\n-2 -2 -2 1 2 4 -3 -6\nq)signum s-l\n-1 -1 -1 1 1 1 -1 -1i\nq)0<signum s-l\n00011100b\nq)deltas 0<signum s-l\n0 0 0 1 0 0 -1 0i\nq)1+deltas 0<signum s-l\n1 1 1 2 1 1 0 1\nq)`sell`doNothing`buy 1+deltas 0<signum s-l\n`doNothing`doNothing`doNothing`buy`doNothing`doNothing`sell`doNothing\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The final step is to use the ",(0,s.jsx)(t.code,{children:"deltas"})," output as an index into a list of symbols, allowing us to map the numeric values directly to their corresponding trading signals."]}),"\n",(0,s.jsx)(t.p,{children:"Now let\u2019s integrate the signal-generation logic into our dashboard so we can produce a chart like the one shown below. It\u2019s not particularly complicated, but it does require a few lines of code. We\u2019ll also take advantage of some built-in Pulse features to display those nice visual marker, bubbles that highlight each buy or sell signal right on the chart."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard SMA Chart with Signal",src:n(90343).A+"",width:"1916",height:"685"})}),"\n",(0,s.jsx)(t.p,{children:"Pulse is extremely flexible and even lets you write logic directly inside the chart\u2019s code editor. However, to keep things clean and maintainable, we\u2019ll follow good coding practices and wrap our logic in a function that Pulse can call, with parameters controlled by the UI."}),"\n",(0,s.jsxs)(t.p,{children:["We\u2019ll create a function called ",(0,s.jsx)(t.code,{children:"priceChart"})," that takes two arguments: the stock symbol we want to plot and the time range (in days). We\u2019ll build it step by step. First, we reuse the original query that returns the price and the two moving averages."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"select time,sym,sma50:mavg[50;close],sma200:mavg[200;close],price:close from stocks where sym=stock\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then we extend that result with our signal-generation logic, keeping the numeric encoding for now: ",(0,s.jsx)(t.code,{children:"-1"})," for ",(0,s.jsx)(t.strong,{children:"sell"}),", ",(0,s.jsx)(t.code,{children:"1"})," for ",(0,s.jsx)(t.strong,{children:"buy"}),", and ",(0,s.jsx)(t.code,{children:"0"})," for ",(0,s.jsx)(t.strong,{children:"no action"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"update signal:deltas 0<signum sma50-sma200 from\nselect time,sym,sma50:mavg[50;close],sma200:mavg[200;close],price:close from stocks where sym=stock\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Next, we derive a trade action and the corresponding buy/sell price, which for simplicity we set to the closing price at the signal time (ignoring bid/ask). After that, we create the visual \u201cbubbles\u201d that mark buys and sells using Pulse\u2019s built-in conventions: if you add a column named ",(0,s.jsx)(t.code,{children:"<field>_SD_CIRCLE"})," and define ",(0,s.jsx)(t.code,{children:"<field>_SD_SIZE"}),", Pulse will draw a bubble of that size at the corresponding point. By adding four columns, ",(0,s.jsx)(t.code,{children:"buy_SD_CIRCLE"}),", ",(0,s.jsx)(t.code,{children:"buy_SD_SIZE"}),", ",(0,s.jsx)(t.code,{children:"sell_SD_CIRCLE"}),", and ",(0,s.jsx)(t.code,{children:"sell_SD_SIZE"}),", we get clear visual markers for our buy and sell signals."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"update buy_SD_CIRCLE:buy*signal,buy_SD_SIZE:10,sell_SD_CIRCLE:abs sell*signal,sell_SD_SIZE:10 from\nupdate action:`sell`doNothing`buy 1+signal,buy:?[signal=1;price;0N],sell:?[-1=signal;price;0n] from\nupdate signal:deltas 0<signum sma50-sma200 from\nselect time,sym,sma50:mavg[50;close],sma200:mavg[200;close],price:close from stocks where sym=stock\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the final step, we narrow things down to just the columns we care about and apply ",(0,s.jsx)(t.code,{children:"sublist"})," to restrict the output to the selected date range. Here\u2019s the full function in one piece."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"priceChart:{[stock;range]\n        sublist[range;] select time,price,sma50,sma200,buy_SD_CIRCLE,buy_SD_SIZE,sell_SD_CIRCLE,sell_SD_SIZE from\n        update buy_SD_CIRCLE:buy*signal,buy_SD_SIZE:10,sell_SD_CIRCLE:abs sell*signal,sell_SD_SIZE:10 from\n        update action:`sell`doNothing`buy 1+signal,buy:?[signal=1;price;0N],sell:?[-1=signal;price;0n] from\n        update signal:deltas 0<signum sma50-sma200 from\n        select time,sym,sma50:mavg[50;close],sma200:mavg[200;close],price:close from stocks where sym=stock}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Following the same good coding practices, let\u2019s also create a dedicated function for the volume chart."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"volumeChart:{[stock;range] select time, avgVolume:avg volume, volume from sublist[range;] select time,volume from stocks where sym=stock }\n"})}),"\n",(0,s.jsxs)(t.p,{children:["As you\u2019ve probably noticed, we also added the average volume to our volume chart. However, because KDB-X evaluates expressions from right to left, we can\u2019t just compute the average volume first and then apply ",(0,s.jsx)(t.code,{children:"sublist"}),", that would calculate the average over the ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"entire"})})," dataset, giving us the wrong value for the selected time window."]}),"\n",(0,s.jsxs)(t.p,{children:["To get the correct result, we must first extract the sublist for the chosen date range and ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"then"})})," compute the average volume on that subset."]}),"\n",(0,s.jsxs)(t.p,{children:["If you\u2019re wondering why we use ",(0,s.jsx)(t.code,{children:"sublist"})," instead of the ",(0,s.jsx)(t.strong,{children:"take"})," ",(0,s.jsx)(t.code,{children:"#"})," operator, it comes down to their different behaviors. When you use ",(0,s.jsx)(t.code,{children:"take #"})," on a list of ",(0,s.jsx)(t.code,{children:"5"})," elements and request ",(0,s.jsx)(t.code,{children:"7"}),", ",(0,s.jsx)(t.code,{children:"take"})," will start cycling through the list again from the beginning to reach the desired length. In contrast, ",(0,s.jsx)(t.code,{children:"sublist"})," returns only ",(0,s.jsx)(t.code,{children:"min(n; count list)"})," elements."]}),"\n",(0,s.jsxs)(t.p,{children:["This matters when a stock\u2019s price history is shorter than the time range the user selects, ",(0,s.jsx)(t.code,{children:"sublist"})," prevents accidental cycling and ensures we only return the data that actually exists."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"q)7#til 5\n0 1 2 3 4 0 1\nq)7 sublist til 5\n0 1 2 3 4\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now that our functions are in place, the final step is simply adding them into our Pulse dashboard. We just add the function calls to the TimeSeries code editor and pass in the selected stock and time-range values from our drop-down inputs. That\u2019s all it takes, let\u2019s hook everything up."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard Volume Chart with refactored analytics function",src:n(86168).A+"",width:"1918",height:"1080"})}),"\n",(0,s.jsx)(t.p,{children:"The last element to complete our dashboard is a summary table positioned at the top. This table presents key information at a glance, buy or sell price, the generated signal, volume, SMA50, SMA200, and the current price. It adds a numerical layer of context to complement the visual cues from our charts, rounding out the trading interface with clear, actionable insight."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard Summary Table",src:n(22171).A+"",width:"1920",height:"376"})}),"\n",(0,s.jsxs)(t.p,{children:["If we look closely at our ",(0,s.jsx)(t.code,{children:"priceChart"})," function, we\u2019ll notice that nearly all the data required for our summary table is already being produced. The only real difference is the set of columns we want to return. So instead of duplicating logic, we\u2019ll refactor the function, rename it to ",(0,s.jsx)(t.code,{children:"analytics"}),", and introduce a third parameter that specifies which column set we want, whether for the price chart or for the summary table."]}),"\n",(0,s.jsxs)(t.p,{children:["By using a ",(0,s.jsx)(t.code,{children:"functional select"}),", we can make the underlying query far more flexible and dynamic. It\u2019s yet another great example of how expressive and powerful KDB-X can be. You\u2019ll find the refactored version of the code below."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["You can read everything about functional selects on my dedicated blog post ",(0,s.jsx)(t.a,{href:"https://www.defconq.tech/docs/concepts/functionalSelect",children:"here"})]})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"analytics:{[stock;range;columns]\n         chartColumns:`time`price`sma50`sma200`buy_SD_CIRCLE`buy_SD_SIZE`sell_SD_CIRCLE`sell_SD_SIZE;\n         tableColumns:`time`sym`action`buy`sell`price`volume`sma50`sma200;\n         c:();\n         if[columns=`tab;c:tableColumns];\n         if[columns=`chart;c:chartColumns];\n         ?[;();0b;{x!x} c]\n         sublist[range;] `time xasc update buy_SD_CIRCLE:buy*signal,buy_SD_SIZE:10,sell_SD_CIRCLE:abs sell*signal,sell_SD_SIZE:10 from\n         update action:`sell`doNothing`buy 1+signal,buy:?[signal=1;price;0N],sell:?[-1=signal;price;0n] from\n         update signal:deltas 0<signum sma50-sma200 from\n         select time,sym,sma50:mavg[50;close],sma200:mavg[200;close],price:close,volume from stocks where sym=stock}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now all that remains is a bit of clean-up to make the dashboard look polished and professional. Rename each component to something meaningful, add some spacing to the left and right of the charts, and tidy up the layout. And just like that, voil\xe0, you\u2019ve got a sleek, production-ready dashboard that supports your traders\u2019 decision-making with clarity and style."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Margin Settings for Charts",src:n(22781).A+"",width:"689",height:"252"}),"\n",(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Dashboard Professional Version",src:n(43614).A+"",width:"1920",height:"1099"})]}),"\n",(0,s.jsx)(t.h2,{id:"backtesting-for-alpha-turning-strategy-into-performance",children:"Backtesting for Alpha: Turning Strategy Into Performance"}),"\n",(0,s.jsxs)(t.p,{children:["At the start of this tutorial, I promised we would build a backtesting engine for our trading strategy, and I always deliver. In this final section, we\u2019ll put everything together by creating a simple yet powerful backtester, powered by KDB-X\u2019s built-in timer functionality: ",(0,s.jsx)(t.a,{href:"https://code.kx.com/q/ref/dotz/#zts-timer",children:(0,s.jsx)(t.code,{children:".z.ts"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Normally, ",(0,s.jsx)(t.code,{children:".z.ts"})," is undefined, but once you assign a function to it, that function is executed automatically every ",(0,s.jsx)(t.code,{children:"n"})," milliseconds. You control this interval via a system command ",(0,s.jsx)(t.code,{children:"\\t"}),", either when starting your process with ",(0,s.jsx)(t.code,{children:"-t n"})," or dyhnamically at runtime with ",(0,s.jsx)(t.code,{children:"\\t n"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Let\u2019s look at a small example to understand how it works. We define ",(0,s.jsx)(t.code,{children:".z.ts:{show x}"}),", which prints the argument ",(0,s.jsx)(t.code,{children:"x"})," every time the timer fires. By default, ",(0,s.jsx)(t.code,{children:"x"})," is the current timestamp. So, when we set the timer to fire every ",(0,s.jsx)(t.code,{children:"1000 milliseconds"})," using ",(0,s.jsx)(t.code,{children:"\\t 1000"}),", we get the current time printed once per second. Simple, elegant, and exactly what we\u2019ll use to \u201ctime-lapse\u201d our historical data for backtesting. You can reseet the timer by setting it to zero ",(0,s.jsx)(t.code,{children:"\\t 0"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"q).z.ts:{show x}\nq)\\t 1000\nq)2025.12.07D15:23:23.316105000\n2025.12.07D15:23:24.316105000\n2025.12.07D15:23:25.316105000\n2025.12.07D15:23:26.316105000\n2025.12.07D15:23:27.316105000\n2025.12.07D15:23:28.316105000\n2025.12.07D15:23:29.316105000\n2025.12.07D15:23:30.316105000\n\\t 0\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Remember, our original feed handler holds the ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"entire"})})," price history for our stocks, about 75,000 records spanning from 1980 all the way to 2025. For the backtesting engine, we want to replay this history as a time-lapse, streaming one day\u2019s worth of data every 100 milliseconds."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"q)count data\n75863\nq)exec `startDate`EndDate!(min;max)@\\:time by sym from data\n       | startDate                     EndDate\n------ | -----------------------------------------------------------\n7203.T | 1999.05.06D00:00:00.000000000 2025.05.26D00:00:00.000000000\n9988.HK| 2019.11.26D00:00:00.000000000 2025.05.26D00:00:00.000000000\nAAPL   | 1980.12.12D00:00:00.000000000 2025.05.23D00:00:00.000000000\nAMZN   | 1997.05.15D00:00:00.000000000 2025.05.23D00:00:00.000000000\nGOOG   | 2004.08.19D00:00:00.000000000 2025.05.23D00:00:00.000000000\nMETA   | 2012.05.18D00:00:00.000000000 2025.05.23D00:00:00.000000000\nMSFT   | 1986.03.13D00:00:00.000000000 2025.05.23D00:00:00.000000000\nQQQ    | 1999.03.10D00:00:00.000000000 2025.05.23D00:00:00.000000000\nSPY    | 1993.01.29D00:00:00.000000000 2025.05.23D00:00:00.000000000\nTSLA   | 2010.06.29D00:00:00.000000000 2025.05.23D00:00:00.000000000\nVOW3.DE| 1998.07.22D00:00:00.000000000 2025.05.26D00:00:00.000000000\nVTI    | 2001.06.15D00:00:00.000000000 2025.05.23D00:00:00.000000000\n"})}),"\n",(0,s.jsx)(t.p,{children:"The logic is straightforward:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Extract the list of all distinct trading dates from our dataset."}),"\n",(0,s.jsx)(t.li,{children:"Initialize a counter to track our current position within that date list."}),"\n",(0,s.jsx)(t.li,{children:"On each timer tick (every 100 ms), publish the data for the next date to the Tickerplant."}),"\n",(0,s.jsx)(t.li,{children:"Increment the counter so the following tick streams the next day in sequence."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Alright, time to bring it all together!"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'q)dateList:exec distinct `date$time from data\nq)dateList\n1999.05.06 1999.05.07 1999.05.10 1999.05.11 1999.05.12 1999.05.13 1999.05.14 1999.05.17 1999.05.18 1999.05.19 1999.05.20 1999.05.21 1999.05.24 1999.05.25 1999.05.26 1999.05.27 1999.05.28 1999.05.31 1999.06.01 1999.06.02 1999.06.03 1999.06...\nq)(min;max)@\\:dateList\n1980.12.12 2025.05.26\nq)cntr:0\nq)select from data where $[`date;time]=dateList 0\ntime                          sym     feedHandlerTime               open      high      low       close     volume\n---------------------------------------------------------------------------------------------------------------------\n1999.05.06D00:00:00.000000000 7203.T  1999.05.06D00:00:00.000000000 396.8346  410.4793  392.2863  410.4793  15575000\n1999.05.06D00:00:00.000000000 AAPL    1999.05.06D00:00:00.000000000 0.3498498 0.3521977 0.3305959 0.3343524 433148800\n1999.05.06D00:00:00.000000000 AMZN    1999.05.06D00:00:00.000000000 3.7       3.775     3.39375   3.434375  365688000\n1999.05.06D00:00:00.000000000 MSFT    1999.05.06D00:00:00.000000000 24.73093  24.86503  23.75395  23.88805  74021000\n1999.05.06D00:00:00.000000000 QQQ     1999.05.06D00:00:00.000000000 45.50791  45.90524  43.83911  44.26293  15173400\n1999.05.06D00:00:00.000000000 SPY     1999.05.06D00:00:00.000000000 84.72099  85.15424  83.42122  84.43543  13507200\n1999.05.06D00:00:00.000000000 VOW3.DE 1999.05.06D00:00:00.000000000 12.69323  12.72496  12.17915  12.50283  107812\nq)stream:{-1"Streaming data for date:",string dateList cntr;select from data where $[`date;time]=dateList cntr;cntr::cntr+1}\nq)stream[]\nStreaming data for date:1999.05.10\nq)stream[]\nStreaming data for date:1999.05.11\nq)stream[]\n// Add the actual publishing\nstream:{-1"Streaming data for date:",string dateList cntr;h(`.u.upd;`stocks;select from data where $[`date;time]=dateList cntr);cntr::cntr+1}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Before we begin streaming, let\u2019s reset the CEP by clearing out any previously stored data and create a copy of our Pulse dashboard to preserve the historical version. In the new ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"Backtesting Dashboard"})}),", we\u2019ll remove the date-range drop-down and adjust our functions accordingly. With these two changes in place, we\u2019re ready to fire up the backtesting engine. It's showtime!!!"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Margin Settings for Charts",src:n(65777).A+"",width:"1920",height:"1102"}),"\n",(0,s.jsx)(t.img,{alt:"DefconQ Trading Hub Dashboard - Pulse Margin Settings for Charts",src:n(3392).A+"",width:"1917",height:"1070"}),"\n",(0,s.jsx)(t.img,{alt:"DefconQ Pulse Backtesting Dashboard",src:n(54467).A+""})]}),"\n",(0,s.jsx)(t.h2,{id:"video-tutorial",children:"Video Tutorial"}),"\n",(0,s.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/Cya2BD1hJOY?si=pcRrxFBD4YkSSxLn",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,s.jsxs)(t.p,{children:["Code repo: ",(0,s.jsx)(t.a,{href:"https://github.com/DefconQ/defconQ/tree/master/projects/tradingStrategy",children:"Pulse Powered Alpha: Building your First Trading Strategy with KDB-X and Pulse"})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},54467:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/DefconQPulseBacktestingDashboard-578104de644d24fb037e90ff6bf87145.mov"},41774:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseAddConnection-d52b33d33e5937124b7d8f892d72da57.png"},12464:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseAddDashboard-49f3260346d28080a6fb20d932e350f6.png"},16789:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseAddTimeSeries1-e4b998f46265e5ab73a229483a75eb7f.png"},3392:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseBacktestingAfter-647019672ae8c5a59b7d1e747cf5dc7d.png"},65777:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseBacktestingBefore-1d118e10fcd86f1a1d13a35a5d1f0c61.png"},43614:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseDashboardProfessional-ce4a72ffdb4168617e65296af92958ea.png"},65134:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseDashboardWithStockDropdown-c6ffd7f1329be8117ccad068b86e9f79.png"},60071:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseLandingPage-690acff77edc98a79b58c26c14a2be4d.png"},22781:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseMargin-0c8c05b2dec28795d7b56bb371144c2d.png"},85643:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulsePeriodDropdown-e2734f15e66665de56673575cf72e868.png"},51296:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulsePeriodList-e21254aad151c0c65cbcad09242d2926.png"},10210:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulsePeriodQuery-102348e70ed8e8c6f849c214d1a42099.png"},90343:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulsePriceChartSignals-0a62881af79d53e064e500c447f0f28c.png"},50212:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseSMAChart-101329c05963a2a6d0cf3b73d31b864a.png"},73854:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseSaveDashboard-ab3c81a513d86b125fa893c77916124a.png"},54010:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseStockDropdown-895fd13ac549ccdfd977208cafbc3b6d.png"},22171:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseSummaryTableAnalytics-3738681bf0f3b5355bca501aeb24b747.png"},89855:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseTimeSeriesDummy-dc20ee9dd5051a80ac46a369b8c90ffd.png"},66629:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseTimeSeriesVolume-5ce6b58f502a51b671e5b24ae6296315.png"},39194:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseUserFormStockQuery-ac9b7937c43d4bea6c6663d82a61aa04.png"},86168:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseVolumeChartRefactored-4753ce09c1a9dd8f8b519cc66664192e.png"},28692:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/PulseuserForm-e78f58ec459d287b62a8a6b3c058c6c2.png"},37573:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/TradingEngine-05ded0733a907d6e68c32041a76a3598.png"},28103:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/tradingDashboard-d1d0b201c5177b8955fbea5dfbb1264c.png"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);