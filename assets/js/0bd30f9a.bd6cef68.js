"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2134],{8351:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var i=t(4848),s=t(8453);const r={sidebar_position:7},o="Mastering the Art of Filtering: An In-Depth Look at fby in KDB/Q",c={id:"concepts/fby",title:"Mastering the Art of Filtering: An In-Depth Look at fby in KDB/Q",description:"Graffiti Filter Byfby",source:"@site/docs/concepts/fby.mdx",sourceDirName:"concepts",slug:"/concepts/fby",permalink:"/docs/concepts/fby",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"QSQL - Querying Your Data",permalink:"/docs/concepts/qsql"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},a={},d=[{value:"Syntax",id:"syntax",level:2},{value:"<code>fby</code> in the <code>where clause</code>: Powerful filtering",id:"fby-in-the-where-clause-powerful-filtering",level:2},{value:"The Magic of <code>fby</code> exposed",id:"the-magic-of-fby-exposed",level:2},{value:"<code>fby</code> beyond the <code>where clause</code>",id:"fby-beyond-the-where-clause",level:2},{value:"<code>fby</code> beyond Q-SQL",id:"fby-beyond-q-sql",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"mastering-the-art-of-filtering-an-in-depth-look-at-fby-in-kdbq",children:["Mastering the Art of Filtering: An In-Depth Look at ",(0,i.jsx)(n.code,{children:"fby"})," in KDB/Q"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Graffiti Filter Byfby",src:t(1497).A+"",width:"1024",height:"1024"})}),"\n",(0,i.jsxs)(n.p,{children:["In my previous blog post, I gave you an in-depth exploration of ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/qsql",children:"Q-SQL"})," and how to effectively query your data. However, I deliberately left out one crucial function: ",(0,i.jsx)(n.code,{children:"fby"}),", or Filter-by. There are two reasons for this. Firstly, the post turned out to be much longer than anticipated, and I didn\u2019t want to overload you with too much technical detail. Secondly, I believei ",(0,i.jsx)(n.code,{children:"fby"})," deserves its own dedicated post. It's a powerful operator that highlights what makes KDB/Q so exceptional when working with big data and time series. After this walkthrough, I hope you'll agree. So, without further ado, let's dive in!"]}),"\n",(0,i.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Filter By fby Syntax",src:t(877).A+"",width:"600",height:"370"})}),"\n",(0,i.jsxs)(n.p,{children:["The syntax of ",(0,i.jsx)(n.code,{children:"fby"}),", like (almost)  all KDB/Q, is terse and efficient. ",(0,i.jsx)(n.code,{children:"fby"})," is a binary operator with a parse tree on the left side. Inside parentheses, you specify an aggregation function and the column to which it's applied. Following that is the ",(0,i.jsx)(n.code,{children:"fby"})," keyword, and finally, the column to group by as the right argument to ",(0,i.jsx)(n.code,{children:"fby"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(faggr;col) fby g\n"})}),"\n",(0,i.jsx)(n.p,{children:"where"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"faggr"}),": is an aggregate function"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"col"}),": is the column the aggregation function will be applied to"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"fby"})}),": is the keyword of the Filter-by operator"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"g"}),": is the column to be grouped by"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["So, what does ",(0,i.jsx)(n.code,{children:"fby"})," actually do? It applies an aggregation function to a list (or a column in the case of a table) based on groups that are formed from another list (or column)."]}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s approach this from a practical standpoint\u2014after all, a single line of KDB/Q code speaks louder than a thousand words."}),"\n",(0,i.jsxs)(n.h2,{id:"fby-in-the-where-clause-powerful-filtering",children:[(0,i.jsx)(n.code,{children:"fby"})," in the ",(0,i.jsx)(n.code,{children:"where clause"}),": Powerful filtering"]}),"\n",(0,i.jsxs)(n.p,{children:["The most frequent application of the ",(0,i.jsx)(n.code,{children:"fby"})," operator is within the where clause of a Q-SQL statement. However, as we\u2019ll discover, ",(0,i.jsx)(n.code,{children:"fby"})," isn\u2019t restricted to the where clause or even solely to Q-SQL queries\u2014it has broader applications. To ease into the topic and gradually build our understanding, let's first explore the application of ",(0,i.jsx)(n.code,{children:"fby"})," within a where clause."]}),"\n",(0,i.jsxs)(n.p,{children:["For demonstration purposes, we'll use our ",(0,i.jsx)(n.code,{children:"trade"})," table again, so let's quickly set it up."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)show trade:([] sym:20?`AAPL`GOOG`IBM`MSFT;price:20?100.; quantity:20?1000;exchange:20?`LSE`NASDAQ`CBOE`NYSE)\nsym  price    quantity exchange\n-------------------------------\nAAPL 88.31223 111      NASDAQ\nAAPL 18.9679  859      LSE\nAAPL 28.81915 496      LSE\nAAPL 74.06357 181      LSE\nMSFT 55.38304 79       NASDAQ\nMSFT 50.61626 256      NYSE\nGOOG 14.55868 986      NYSE\nMSFT 38.43624 593      LSE\nGOOG 25.1761  520      NASDAQ\nIBM  33.85685 67       NASDAQ\nIBM  44.10267 181      LSE\nIBM  43.60838 682      CBOE\nIBM  72.47827 763      LSE\nMSFT 53.51104 105      LSE\nGOOG 34.38456 951      NYSE\n..\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now, suppose you want to identify all trade records where the price at which a certain stock was traded is greater than or equal to its average price. A basic KDB/Q approach would involve first using an update statement to calculate the average price for each stock and then updating our table accordingly. Following that, we would execute a second query to select all records where the price meets or exceeds the corresponding average price of that stock. The KDB/Q code below demonstrates this inefficient method."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from (update avgPrice:avg price by sym from trade) where price>=avgPrice\nsym  price    quantity exchange avgPrice\n----------------------------------------\nAAPL 88.31223 111      NASDAQ   52.54071\nAAPL 74.06357 181      LSE      52.54071\nMSFT 55.38304 79       NASDAQ   54.16467\nIBM  44.10267 181      LSE      40.50052\nIBM  43.60838 682      CBOE     40.50052\nIBM  72.47827 763      LSE      40.50052\nMSFT 78.02194 628      LSE      54.16467\nGOOG 86.62585 715      LSE      47.0074\nGOOG 74.29183 833      NASDAQ   47.0074\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As shown in the output above, the ",(0,i.jsx)(n.code,{children:"avgPrice"})," column has been updated with the average stock price for each corresponding stock, which is why you see the same price repeated multiple times. However, with the incredible capabilities of the ",(0,i.jsx)(n.code,{children:"fby"})," operator, we can accomplish all of this in a single query."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where price>=(avg;price) fby sym\nsym  price    quantity exchange\n-------------------------------\nAAPL 88.31223 111      NASDAQ\nAAPL 74.06357 181      LSE\nMSFT 55.38304 79       NASDAQ\nIBM  44.10267 181      LSE\nIBM  43.60838 682      CBOE\nIBM  72.47827 763      LSE\nMSFT 78.02194 628      LSE\nGOOG 86.62585 715      LSE\nGOOG 74.29183 833      NASDAQ\n"})}),"\n",(0,i.jsx)(n.p,{children:"Can we be certain that both queries yield the same result? Let's check. Since our first, more verbose approach adds a new column to the table, we'll need to remove it before comparing it to the output of our second query."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(select from trade where price>=(avg;price) fby sym)~delete avgPrice from select from (update avgPrice:avg price by sym from trade) where price>=avgPrice\n1b\n"})}),"\n",(0,i.jsx)(n.p,{children:"As expected, the results match perfectly."}),"\n",(0,i.jsxs)(n.p,{children:["You can also group by multiple columns using the ",(0,i.jsx)(n.code,{children:"fby"})," operator, although the syntax is a bit different from what we\u2019re used to. All you need to do is create an anonymous table with the columns you want to group by. The example below illustrates this concept for better understanding."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)select from trade where price>(avg;price) fby ([] sym;exchange)\nsym  price    quantity exchange\n-------------------------------\nAAPL 74.06357 181      LSE\nMSFT 55.38304 79       NASDAQ\nIBM  33.85685 67       NASDAQ\nIBM  72.47827 763      LSE\nGOOG 34.38456 951      NYSE\nMSFT 78.02194 628      LSE\nGOOG 74.29183 833      NASDAQ\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"the-magic-of-fby-exposed",children:["The Magic of ",(0,i.jsx)(n.code,{children:"fby"})," exposed"]}),"\n",(0,i.jsxs)(n.p,{children:["As we've seen, the ",(0,i.jsx)(n.code,{children:"fby"})," operator is quite powerful. In this section, we'll dive deeper into how ",(0,i.jsx)(n.code,{children:"fby"})," operates under the hood by examining some ",(0,i.jsx)(n.code,{children:"k"})," code. That's right; we\u2019ll be looking at the underlying language of ",(0,i.jsx)(n.code,{children:"q"}),", which is ",(0,i.jsx)(n.code,{children:"k"}),", the ",(0,i.jsx)(n.code,{children:"K"})," in KDB/Q. This exploration is purely for illustrative purposes to help you understand the the mechanics behind the scenes. I do not recommend writing ",(0,i.jsx)(n.code,{children:"k"})," code for your projects, and I strongly advise against using it in a production environment, as ",(0,i.jsx)(n.code,{children:"k"})," code is not supported by KX, as noted ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/exposed-infrastructure/",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Now, before we start, we need to quickly review two things: First, how can we obtain the underlying ",(0,i.jsx)(n.code,{children:"k"})," code for ",(0,i.jsx)(n.code,{children:"fby"}),"? It's quite simple. For any operator that reveals its underlying ",(0,i.jsx)(n.code,{children:"k"})," code, ou just need to type the operator into your ",(0,i.jsx)(n.code,{children:"q"})," console and hit enter, and the ",(0,i.jsx)(n.code,{children:"k"})," code will be displayed. Let's give it a try."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"k){$[(#x 1)=#y;@[(#y)#x[0]0#x 1;g;:;x[0]'x[1]g:.=y];'`length]}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["The preceding ",(0,i.jsx)(n.code,{children:"k)"})," indicates that what is being displayed is K code."]})}),"\n",(0,i.jsxs)(n.p,{children:["Next, we need to clarify an important point: Like ",(0,i.jsx)(n.code,{children:"q"}),", ",(0,i.jsx)(n.code,{children:"k"})," has a wide range of overloaded functions\u2014actually, even more than ",(0,i.jsx)(n.code,{children:"q"}),". Most unary functions in ",(0,i.jsx)(n.code,{children:"k"})," have a corresponding overloaded binary version. To distinguish the unary version from the binary version, ",(0,i.jsx)(n.code,{children:"q"})," displays ",(0,i.jsx)(n.code,{children:"k"})," code with a ",(0,i.jsx)(n.code,{children:":"}),". Let\u2019s take a look at an example: the ",(0,i.jsx)(n.code,{children:"k"})," code for the ",(0,i.jsx)(n.code,{children:"q"})," keyword ",(0,i.jsx)(n.code,{children:"flip"}),", which is a unary function, is ",(0,i.jsx)(n.code,{children:"+:"}),", as shown below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)flip\n+:\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Great! Let's demystify ",(0,i.jsx)(n.code,{children:"fby"}),". To do so, we only need to convery four ",(0,i.jsx)(n.code,{children:"q"})," functions into ",(0,i.jsx)(n.code,{children:"k"})," code: ",(0,i.jsx)(n.code,{children:"count"}),", ",(0,i.jsx)(n.code,{children:"group"}),", ",(0,i.jsx)(n.code,{children:"value"}),", and the iterator ",(0,i.jsx)(n.code,{children:"each"}),". The cooresponding ",(0,i.jsx)(n.code,{children:"k"})," code is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)count\n#:\nq)group\n=:\nq)value\n.:\nq)each\nk){x'y}\n\nq)fby\nk){$[(#x 1)=#y;@[(#y)#x[0]0#x 1;g;:;x[0]'x[1]g:.=y];'`length]}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, let\u2019s begin. The first part of ",(0,i.jsx)(n.code,{children:"fby"})," is a plain, simple ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/cond/",children:(0,i.jsx)(n.code,{children:"$"})})," conditional statement. The syntax of this conditional is simple: we evaluate a condition, and if it\u2019s true, we proceed with the true branch of the statement; if it\u2019s false, we continue with the false branch."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)$[0b;`true;`false]\n`false\nq)$[1b;`true;`false]\n`true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The condition we evaluate is a basic comparison: we check whether the length of the ",(0,i.jsx)(n.code,{children:"x"})," parameter of ",(0,i.jsx)(n.code,{children:"fby"})," matches the length of the ",(0,i.jsx)(n.code,{children:"y"})," parameter of ",(0,i.jsx)(n.code,{children:"fby"}),". Let\u2019s take a moment to examine the ",(0,i.jsx)(n.code,{children:"fby"})," statement on its own, outside of the Q-SQL ",(0,i.jsx)(n.code,{children:"where clause"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(avg;trade`price) fby trade`sym\n52.54071 52.54071 52.54071 52.54071 54.16467 54.16467 47.0074 54.16467 47.0074 40.50052 40.50052 40.50052 40.50052 54.16467 47.0074 54.16467 47.0074 40.50052 47.0074 54.16467\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can generalise the above code using the parameters ",(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"}),", resulting in the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"x fby y\n"})}),"\n",(0,i.jsxs)(n.p,{children:["where ",(0,i.jsx)(n.code,{children:"x"})," is a list with the first element being an aggregation function and the second element being a list (when used in a ",(0,i.jsx)(n.code,{children:"where clause"}),", this would typically refer to a column by its name). Meanwhile, ",(0,i.jsx)(n.code,{children:"y"})," is a list of values to group by (similarly, in a ",(0,i.jsx)(n.code,{children:"where clause"}),", this would refer to a column)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)show x:(avg;trade`price)\navg\n88.31223 18.9679 28.81915 74.06357 55.38304 50.61626 14.55868 38.43624 25.1761 33.85685 44.10267 43.60838 72.47827 53.51104 34.38456 78.02194 86.62585 8.456454 74.29183 49.01948\nq)show y:trade`sym\n`AAPL`AAPL`AAPL`AAPL`MSFT`MSFT`GOOG`MSFT`GOOG`IBM`IBM`IBM`IBM`MSFT`GOOG`MSFT`GOOG`IBM`GOOG`MSFT\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Therefore, we basically compare the length of our price list with the length of our symbol list. If they match, we proceed with the execution of the ",(0,i.jsx)(n.code,{children:"fby"})," function. If they don't, a ",(0,i.jsx)(n.code,{children:"length"})," error is thrown."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)k)(#x 1)=#y\n1b\n// above k code translated to q code\nq)count[x 1]=count y\n1b\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["There are two ways to test ",(0,i.jsx)(n.code,{children:"k"})," code in a ",(0,i.jsx)(n.code,{children:"q"})," console. You can either enter a single backslash ",(0,i.jsx)(n.code,{children:"\\"})," to switch to the ",(0,i.jsx)(n.code,{children:"k"})," interpreter or prepend your code with ",(0,i.jsx)(n.code,{children:"k)"})," to run it directly as ",(0,i.jsx)(n.code,{children:"k"})," code."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// For reference\nq)fby\nk){$[(#x 1)=#y;@[(#y)#x[0]0#x 1;g;:;x[0]'x[1]g:.=y];'`length]}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Next, we encounter the ",(0,i.jsxs)(n.a,{href:"https://www.defconq.tech/docs/concepts/amend",children:["Amend At ",(0,i.jsx)(n.code,{children:"@"})]})," operator, one of the most powerful tools in KDB/Q. If you're not fully familiar with it, I highly recommend revisiting its functionality in my previous ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/amend",children:"blog post"}),". ",(0,i.jsx)(n.code,{children:"Amend At @"})," is heavily overloaded, and in this case, we're looking at the version that takes four parameters and uses the binary function ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/assign/",children:(0,i.jsx)(n.code,{children:"assign :"})})," to modify values in place. One key detail to remember is that KDB/Q's ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/blog/The%20Magnificent%20Seven%20-%20Mastering%20KDB/Q%20Concepts%20for%20Data%20Excellence#left-of-right-and-no-operator-precedence",children:"left-to-right"})," evaluation applies even within the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator, meaning the expressions inside the square brackets are evaluated from right to left. So, let's follow this flow step by step."]}),"\n",(0,i.jsxs)(n.p,{children:["First, we have ",(0,i.jsx)(n.code,{children:".=y"})," which perfectly illustrates the power of KDB/Q\u2014just three simple characters accomplish so much. Translating the ",(0,i.jsx)(n.code,{children:"k"})," code into ",(0,i.jsx)(n.code,{children:"q"}),", this becomes ",(0,i.jsx)(n.code,{children:"value group y"}),", which is a bit more verbose than its ",(0,i.jsx)(n.code,{children:"k"})," counterpart. Let's break it down further, starting from the right. We first ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/group/",children:(0,i.jsx)(n.code,{children:"group"})})," the values of ",(0,i.jsx)(n.code,{children:"y"})," (our list of symbols) into a dictionary, mapping each unique symbol to its corresponding indices. Since we only care about the indices, we use the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/value/",children:(0,i.jsx)(n.code,{children:"value"})})," operator to extract the dictionary's values and assign them to the variable ",(0,i.jsx)(n.code,{children:"g"}),". These indices will then be used in the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)k)=y\nAAPL| 0 1 2 3\nMSFT| 4 5 7 13 15 19\nGOOG| 6 8 14 16 18\nIBM | 9 10 11 12 17\nq)k).=y\n0 1 2 3\n4 5 7 13 15 19\n6 8 14 16 18\n9 10 11 12 17\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, above ",(0,i.jsx)(n.code,{children:"k"})," code can easily be translated into ",(0,i.jsx)(n.code,{children:"q"})," code."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)group y\nAAPL| 0 1 2 3\nMSFT| 4 5 7 13 15 19\nGOOG| 6 8 14 16 18\nIBM | 9 10 11 12 17\nq)value group y\n0 1 2 3\n4 5 7 13 15 19\n6 8 14 16 18\n9 10 11 12 17\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We then use the indices stored in ",(0,i.jsx)(n.code,{children:"g"})," to access the corresponding elements in our list of prices. Remember, the parameter ",(0,i.jsx)(n.code,{children:"x"})," is a tuble ",(0,i.jsx)(n.code,{children:"x:(avg;trade"}),"price)`, where the first element is an aggregation function and the second element is the list (in this case, the list of prices)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)k)x[1]g:.=y\n88.31223 18.9679 28.81915 74.06357\n55.38304 50.61626 38.43624 53.51104 78.02194 49.01948\n14.55868 25.1761 34.38456 86.62585 74.29183\n33.85685 44.10267 43.60838 72.47827 8.456454\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this case, there is no difference between the ",(0,i.jsx)(n.code,{children:"k"})," code and the corresponding ",(0,i.jsx)(n.code,{children:"q"})," code - indexing follows the exact same syntax in both languages."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)x[1]g:value group y\n88.31223 18.9679 28.81915 74.06357\n55.38304 50.61626 38.43624 53.51104 78.02194 49.01948\n14.55868 25.1761 34.38456 86.62585 74.29183\n33.85685 44.10267 43.60838 72.47827 8.456454\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The code snippet above demonstrates another important lesson in KDB/Q: when indexing with a nested list, such as the indexes stored in ",(0,i.jsx)(n.code,{children:"g"}),", the resulting list will conform to the structure of the index list. In other words, the shape of the result matches the shape of the index list. This concept is also emphasized in ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/3_Lists/",children:(0,i.jsx)(n.em,{children:"Q for Mortals, Chapter 3 - Lists"})})," under section ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/3_Lists/#393-indexing-with-nested-lists",children:"3.9.3 Indexing with Nested Lists"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)g\n0 1 2 3\n4 5 7 13 15 19\n6 8 14 16 18\n9 10 11 12 17\nq)x[1]g\n88.31223 18.9679 28.81915 74.06357\n55.38304 50.61626 38.43624 53.51104 78.02194 49.01948\n14.55868 25.1761 34.38456 86.62585 74.29183\n33.85685 44.10267 43.60838 72.47827 8.456454\nq)count each g\n4 6 5 5\nq)count each x[1]g\n4 6 5 5\nq)type g\n0h\nq)type x[1]g\n0h\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We then apply the aggregation function stored in ",(0,i.jsx)(n.code,{children:"x[0]"}),", which is the first element of our tuple, to the elements retrieved by indexing into the list. Since our indexes form a nested list, we need to use an iterator to apply the function to each sublist within our list of prices, as it\u2019s structured as a list of lists. In this case, we are leveraging the ",(0,i.jsxs)(n.a,{href:"https://code.kx.com/q/ref/maps/#each",children:[(0,i.jsx)(n.strong,{children:"each"})," ",(0,i.jsx)(n.code,{children:"'"})]}),"  operator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)k)x[0]'x[1]g\n52.54071 54.16467 47.0074 40.50052\n// converting to q code\nq)x[0] each x[1]g\n52.54071 54.16467 47.0074 40.50052\nq)x[0]@'x[1]g\n52.54071 54.16467 47.0074 40.50052\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see from the code above, ",(0,i.jsx)(n.code,{children:"k"})," and ",(0,i.jsx)(n.code,{children:"q"})," are nearly identical. The only small difference is the fact that you need to use the keyword ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/maps/#each",children:(0,i.jsx)(n.code,{children:"each"})}),", since our aggregate function is a unary operator. If you prefer using the ",(0,i.jsx)(n.code,{children:"each"})," glyph, you can apply some syntactic sugar by combining the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/overloads/#at",children:(0,i.jsx)(n.code,{children:"@"})})," operator with the ",(0,i.jsx)(n.code,{children:"'"})," symbol."]}),"\n",(0,i.jsxs)(n.p,{children:["Since our aggregation function is ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/avg/#avg",children:(0,i.jsx)(n.code,{children:"avg"})}),", we are computing the average for each sublist, and return the result as a list. Below code illustrates this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)avg each x[1] g\n52.54071 54.16467 47.0074 40.50052\n// for reference\nq)x[1] g\n88.31223 18.9679 28.81915 74.06357\n55.38304 50.61626 38.43624 53.51104 78.02194 49.01948\n14.55868 25.1761 34.38456 86.62585 74.29183\n33.85685 44.10267 43.60838 72.47827 8.456454\n// You could manually compute each average\nq)avg (x[1] g) 0\n52.54071\nq)avg (x[1] g) 1\n54.16467\nq)avg (x[1] g) 2\n47.0074\nq)avg (x[1] g) 3\n40.50052\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Alright, so far so good. Now that we understand the final expression in the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator (the fourth parameter), the remaining task is simply to use these values as the right operand in the function defined by the third parameter, which is ",(0,i.jsx)(n.code,{children:"assign :"})," in our case. As the left operand for ",(0,i.jsx)(n.code,{children:"assign :"}),", we use the elements at index ",(0,i.jsx)(n.code,{children:"g"}),", specified in the second parameter of the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator. Does it sound complicated? Let's break it down. If you'd like a refresher on the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator, you can check out my blog post ",(0,i.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/amend",children:"here"}),". As a quick reminder, here's the syntax for using Amend At with a binary function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"@[d; i; v; vy]\n"})}),"\n",(0,i.jsx)(n.p,{children:"where"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"d"})," is an atom, list, or a dictionary (value); or a handle to a list, dictionary or datafile"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"i"})," indexes where d is to be amended"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"v"})," is a binary function"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"vy"})," is the right domain of ",(0,i.jsx)(n.code,{children:"v"}),", the right parameter"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It feels quite theoretical, doesn't it? Let's bring it to life with a practical example applied to our use case. To simplify things a bit, we know that our list of prices contains 20 elements, so we can simulate this using a list of natural numbers from 0 to 19."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Our prices ...\nq)x 1\n88.31223 18.9679 28.81915 74.06357 55.38304 50.61626 14.55868 38.43624 25.1761 33.85685 44.10267 43.60838 72.47827 53.51104 34.38456 78.02194 86.62585 8.456454 74.29183 49.01948\n// ... contain 20 elements\nq)count x 1\n20\n// the indexes we calculated in the last part of the Amend At @ operator\nq)g\n0 1 2 3\n4 5 7 13 15 19\n6 8 14 16 18\n9 10 11 12 17\n// we raze them\nq)raze g\n0 1 2 3 4 5 7 13 15 19 6 8 14 16 18 9 10 11 12 17\n// and sort them in ascending order\nq)asc raze g\n`s#0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n// Which corresponds to the natural numbers from 0 to 19\nq)til 20\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\nq)til[20]~asc raze g\n1b\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can index into the list of natural numbers using the indexes stored in the variable ",(0,i.jsx)(n.code,{children:"g"}),". Since ",(0,i.jsx)(n.code,{children:"g"})," is a nested list containing four sublists, we need four values as the right argument to the assign function when using ",(0,i.jsx)(n.code,{children:"Amend At @"})," with those indexes. The elements at the indexes of the first sublist will take the first value, those in the second sublist will take the second value, and so on. Let's walk through this step by step."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Index into our list of natural numbers from 0 to 19 using the indexes stored in variable g\nq)til[20] g\n0 1 2 3\n4 5 7 13 15 19\n6 8 14 16 18\n9 10 11 12 17\n// this can be rewritten using Applt At @\nq)@[til 20;g]\n0 1 2 3\n4 5 7 13 15 19\n6 8 14 16 18\n9 10 11 12 17\n// Verify that above code is actually the same\nq)@[til 20;g]~til[20] g\n1b\n// Now, let's use Apply At to assign the values 1,2,3,4 to the elemtns at index g\nq)@[til 20;g;:;1 2 3 4]\n1 1 1 1 2 2 3 2 3 4 4 4 4 2 3 2 3 4 3 2\n// We index into the list using g to highlight what happened\nq)@[til 20;g;:;1 2 3 4] g\n1 1 1 1\n2 2 2 2 2 2\n3 3 3 3 3\n4 4 4 4 4\n"})}),"\n",(0,i.jsx)(n.p,{children:"As shown in the previous example, we replaced all values at the indexes of the first sublist with the value 1, all elements of the second sublist with the value 2, and so on, using the assignment operator. Breaking it down step by step, the process would look like this:"}),"\n",(0,i.jsxs)(n.p,{children:["First, we replace all elements at the indexes of the first sublist with the value 1. To better illustrate the behavior, we use the variable ",(0,i.jsx)(n.code,{children:"g"})," to group the elements by sublists again."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)@[til 20;g[0];:;1] g\n1 1 1 1\n4 5 7 13 15 19\n6 8 14 16 18\n9 10 11 12 17\n"})}),"\n",(0,i.jsx)(n.p,{children:"Next, we replace all elements at the indexes of the second sublist with the value 2."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)@[til 20;g[1];:;2] g\n0 1 2 3\n2 2 2 2 2 2\n6 8 14 16 18\n9 10 11 12 17\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then we replace all elements at the indexes of the third sublist with the value 3."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)@[til 20;g[2];:;3] g\n0 1 2 3\n4 5 7 13 15 19\n3 3 3 3 3\n9 10 11 12 17\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finally, we replace all elements at the indexes of the fourth sublist with the value 4."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)@[til 20;g[3];:;4] g\n0 1 2 3\n4 5 7 13 15 19\n6 8 14 16 18\n4 4 4 4 4\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Excellent! Now, the final step is to understand what's happening in the first expression of the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator. Let's take a closer look at its role and what it accomplishes."]}),"\n",(0,i.jsxs)(n.p,{children:["Remember, ",(0,i.jsx)(n.code,{children:"x[0]"})," was our aggregation function, ",(0,i.jsx)(n.code,{children:"x[1]"})," the list of prices and ",(0,i.jsx)(n.code,{children:"y"})," the list of symbols, as well as the function ",(0,i.jsx)(n.code,{children:"count"})," being defined as ",(0,i.jsx)(n.code,{children:"#"})," in ",(0,i.jsx)(n.code,{children:"k"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)k)x 1\n88.31223 18.9679 28.81915 74.06357 55.38304 50.61626 14.55868 38.43624 25.1761 33.85685 44.10267 43.60838 72.47827 53.51104 34.38456 78.02194 86.62585 8.456454 74.29183 49.01948\nq)x 0\navg\nq)y\n`AAPL`AAPL`AAPL`AAPL`MSFT`MSFT`GOOG`MSFT`GOOG`IBM`IBM`IBM`IBM`MSFT`GOOG`MSFT`GOOG`IBM`GOOG`MSFT\nq)count \n#:\n"})}),"\n",(0,i.jsxs)(n.p,{children:["What this expression does is first take 0 elements from our list of prices, resulting in an empty list. Then, it applies the aggregation function, which is average ",(0,i.jsx)(n.code,{children:"avg"})," in our case, to this empty list, returning the corresponding null value for the data type of the list. Next, it retrieves the length of our second parameter, ",(0,i.jsx)(n.code,{children:"y"})," (the list of symbols in this case), and produces a list with the same number of null elements as there are elements in ",(0,i.jsx)(n.code,{children:"y"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)k)(#y)#x[0]0#x 1\n0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Translating above into ",(0,i.jsx)(n.code,{children:"q"})," results in the following code"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(count y)#x[0]0#x 1\n0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n 0n\n"})}),"\n",(0,i.jsx)(n.p,{children:"To be completely honest, I'm not entirely sure why this step is necessary. Amending the initial price list with the new values should achieve the same result. However, I'm certain there must be a valid reason for it that I'm not seeing yet. Believe it or not, there are still plenty of KDB/Q concepts I haven't fully grasped either. Just like you, I'm constantly learning and discovering new things every day."}),"\n",(0,i.jsxs)(n.p,{children:["This concludes our little exploration of the magic behind ",(0,i.jsx)(n.code,{children:"fby"})," and the world of ",(0,i.jsx)(n.code,{children:"k"})," code. As I mentioned earlier, I strongly advise against using ",(0,i.jsx)(n.code,{children:"k"})," n a production environment. However, gaining insight into what's happening behind the scenes can enhance your understanding of KDB/Q and make you a better developer."]}),"\n",(0,i.jsxs)(n.h2,{id:"fby-beyond-the-where-clause",children:[(0,i.jsx)(n.code,{children:"fby"})," beyond the ",(0,i.jsx)(n.code,{children:"where clause"})]}),"\n",(0,i.jsxs)(n.p,{children:["Now that we\u2019ve uncovered the magic behind ",(0,i.jsx)(n.code,{children:"fby"}),", et\u2019s take it a step further. If you thought that fby could only be used in the ",(0,i.jsx)(n.code,{children:"where clause"})," of a Q-SQL query, think again. Its power extends far beyond that! In fact, ",(0,i.jsx)(n.code,{children:"fby"})," can also be used within the ",(0,i.jsx)(n.code,{children:"column phrase"})," of a Q-SQL query. Drawing inspiration from a solution provided by ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/in/attila-vrabecz-b948a52/",children:"Attila Vrabecz"}),"  to one of the ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/pulse/weekly-quest-14-smoothing-curve-habla-computing-xanxf/?trackingId=r1iQTrlaPQcJR6VUAwc37Q%3D%3D",children:"coding challenges"})," set by my friends at ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/company/habla-computing/posts/?feedView=all",children:"Habla Computing"})," in Madrid, we\u2019re going to explore how to leverage the ",(0,i.jsx)(n.code,{children:"fby"})," operator in the ",(0,i.jsx)(n.code,{children:"column phrase"}),". Let's first have a look at the challenge and its setup:"]}),"\n",(0,i.jsxs)(n.p,{children:["The challenge is as follows (full details can be found ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/pulse/weekly-quest-14-smoothing-curve-habla-computing-xanxf/?trackingId=r1iQTrlaPQcJR6VUAwc37Q%3D%3D",children:"here"}),"):\n",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"To face this task we will receive a table with price observations for multiple assets over time, the goal is to compute the midpoint between the previous and current Price for each asset."})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Prices Table: with columns for asset, time and prices."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Table: with the column prices updated with the midpoint values, except for the first row of each asset."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Input\nt:([] asset: `AMZN`GOOG`AMZN`AAPL`AMZN; time: 10:43 12:02 12:38 12:54 15:55; price: 108.244 103.9113 103.8967 102.5633 101.1562)\n// Output\nasset time  price\n--------------------\nAMZN  10:43 108.244\nGOOG  12:02 103.9113\nAMZN  12:38 106.0703\nAAPL  12:54 102.5633\nAMZN  15:55 102.5265\n"})}),"\n",(0,i.jsx)(n.p,{children:"When I first reviewed the challenge, it was clear that the solution involved calculating a simple rolling window average with a range of 2. Here's the solution I came up with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)update 2 mavg price by asset from t\nasset time  price\n--------------------\nAMZN  10:43 108.244\nGOOG  12:02 103.9113\nAMZN  12:38 106.0703\nAAPL  12:54 102.5633\nAMZN  15:55 102.5264\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, Attila's solution was not only more elegant but also twice as fast as my initial approach or any of the other solutions submitted by others. Let's take a look at Attila's approach."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// for length\nf:{@[x;`price;fby[;x`asset](2 mavg;)@]}\n// for speed\nf:{@[x;`price;fby[;x`asset]({.5*first[x]+':x};)@]}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["While Attila leverages the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator in conjunction with the ",(0,i.jsx)(n.code,{children:"fby"})," operator, we can alternatively rewrite this as a pure Q-SQL statement:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// first function rewritten to a Q-SQL statement \nq)update price:(2 mavg;price) fby asset from t\nasset time  price\n--------------------\nAMZN  10:43 108.244\nGOOG  12:02 103.9113\nAMZN  12:38 106.0703\nAAPL  12:54 102.5633\nAMZN  15:55 102.5264\n// first function rewritten to a Q-SQL statement\nq)update price:({0.5*first[x]+':x};price) fby asset from t\nasset time  price\n--------------------\nAMZN  10:43 108.244\nGOOG  12:02 103.9113\nAMZN  12:38 106.0703\nAAPL  12:54 102.5633\nAMZN  15:55 102.5264\nq)(update 2 mavg price by asset from t)~update price:(2 mavg;price) fby asset from t\n1b\nq)(update 2 mavg price by asset from t)~update price:({0.5*first[x]+':x};price) fby asset from t\n1b\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"fby-beyond-q-sql",children:[(0,i.jsx)(n.code,{children:"fby"})," beyond Q-SQL"]}),"\n",(0,i.jsxs)(n.p,{children:["As shown in the code above, you can use ",(0,i.jsx)(n.code,{children:"fby"})," outside of a ",(0,i.jsx)(n.code,{children:"where clause"}),". But what is even more impressive, as demonstrated by Attila's code, is the fact that you can use ",(0,i.jsx)(n.code,{children:"fby"})," without a Q-SQL statement altogether. Let\u2019s break down the code in more detail."]}),"\n",(0,i.jsx)(n.p,{children:"We start with the first function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)f:{@[x;`price;fby[;x`asset](2 mavg;)@]}\nq)f t\nasset time  price\n--------------------\nAMZN  10:43 108.244\nGOOG  12:02 103.9113\nAMZN  12:38 106.0703\nAAPL  12:54 102.5633\nAMZN  15:55 102.5264\nq)(update 2 mavg price by asset from t)~f t\n1b\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Attila utilized the ternary version of the ",(0,i.jsx)(n.code,{children:"Amend At @"})," operator to update the prices in the table by using the ",(0,i.jsx)(n.code,{children:"fby"})," operator as the function within ",(0,i.jsx)(n.code,{children:"Amend At @"}),". Since ",(0,i.jsx)(n.code,{children:"fby"})," is a binary operator, and the ternary version of ",(0,i.jsx)(n.code,{children:"Amend At @"})," requires a unary function, he addressed this by transforming the binary ",(0,i.jsx)(n.code,{children:"fby"})," into a unary function through the composition of two projections. First, he created a projection on a list of ",(0,i.jsx)(n.code,{children:"(2 mavg;)@"}),", and then another on ",(0,i.jsx)(n.code,{children:"fby[; x`asset]"}),". By composing these projections, he formed a unary function. In KDB/Q, composition follows the mathematical principle: given two functions, ",(0,i.jsx)(n.code,{children:"f"})," and ",(0,i.jsx)(n.code,{children:"g"}),", composition operator creates a new function ",(0,i.jsx)(n.code,{children:"h(x) = (g \u2218 f)(x) = g(f(x))"}),", meaning that ",(0,i.jsx)(n.code,{children:"g"})," is applied after ",(0,i.jsx)(n.code,{children:"f"})," has been applied to ",(0,i.jsx)(n.code,{children:"x"}),". You can learn more about composition ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/apply/#composition",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The second function is quite similar to the first, but with a slight variation. Although it uses more characters, it\u2019s faster. This is due to the optimization where multiplication is used instead of division\u2014multiplying by ",(0,i.jsx)(n.code,{children:"0.5"})," is quicker than using the ",(0,i.jsx)(n.code,{children:"avg"})," operator to calculate the average of two numbers. Additionally, we see the use of the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/maps/#each-prior",children:(0,i.jsx)(n.code,{children:"each prior ':"})})," iterator. This iterator applies a binary function between each item in a list and its preceding item. A good example of its application can be seen in the ",(0,i.jsx)(n.code,{children:"deltas"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)deltas\n-':\n"})}),"\n",(0,i.jsxs)(n.p,{children:['The first item in a list, by definition, has no preceding item. When the derived function is applied as a binary function, the left argument serves as the "seed"\u2014the value that precedes the first item. If the derived function is applied as a unary function (as with ',(0,i.jsx)(n.code,{children:"deltas"})," or ",(0,i.jsx)(n.code,{children:"+':"}),"), and the operator has an identity element recognized by q, that element will be used as the seed. In this case, we need to provide the initial left argument, which is ",(0,i.jsx)(n.code,{children:"first[x]"}),". Beyond that, everything else operates just as it does in the first function."]}),"\n",(0,i.jsxs)(n.p,{children:["I hope this blog post has helped you gain a deeper understanding of ",(0,i.jsx)(n.code,{children:"fby"})," and the mechanics behind it. If you enjoy my content, consider subscribing to my newsletter\u2014it's completely free! Subscribe ",(0,i.jsx)(n.a,{href:"https://defconq.substack.com/",children:"here"})]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},877:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/fby-6965ec8d87dce82ead07cc4e8b70d981.png"},1497:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/fbyGraffiti-4daae07c1fa8f6a53b6d24d1813de170.png"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);