"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7389],{5829:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=i(4848),t=i(8453);const s={slug:"The Magnificent Seven - Mastering KDB/Q Concepts for Data Excellence",title:"The Magnificent Seven - Mastering KDB/Q Concepts for Data Excellence",authors:["alexander"],hide_table_of_contents:!0,tags:["kdb/q","kdb/q concepts"]},o=void 0,r={permalink:"/blog/The Magnificent Seven - Mastering KDB/Q Concepts for Data Excellence",source:"@site/blog/2024-07-10-concepts/index.mdx",title:"The Magnificent Seven - Mastering KDB/Q Concepts for Data Excellence",description:'When developers first encounter KDB/Q, they are often intimidated by its "strange" syntax, which differs significantly from most other programming languages they\'ve seen. However, understanding and familiarizing oneself with the syntax is merely the beginning. To truly master any programming language, one needs a deep understanding of its core concepts and paradigms. For instance, when learning object-oriented languages like Java or C++, you should focus on concepts such as inheritance, encapsulation, polymorphism, and data abstraction. Additionally, understanding pointers and memory allocation is crucial for mastering C++. The same principle applies to KDB/Q, a high-performance, in-memory database and programming language. In this blog post, I will share the seven most important concepts that will set you apart and enhance your skills as a KDB/Q developer. Understanding these concepts will provide insight into why KDB/Q is so powerful and favored among quants and data enthusiasts.',date:"2024-07-10T00:00:00.000Z",tags:[{label:"kdb/q",permalink:"/blog/tags/kdb-q"},{label:"kdb/q concepts",permalink:"/blog/tags/kdb-q-concepts"}],readingTime:9.695,hasTruncateMarker:!0,authors:[{name:"Alexander Unterrainer",title:"DefconQ, KDB/Q Developer, Consultant",url:"https://github.com/AUnterrainer",imageURL:"/img/alex.jpeg",key:"alexander"}],frontMatter:{slug:"The Magnificent Seven - Mastering KDB/Q Concepts for Data Excellence",title:"The Magnificent Seven - Mastering KDB/Q Concepts for Data Excellence",authors:["alexander"],hide_table_of_contents:!0,tags:["kdb/q","kdb/q concepts"]},unlisted:!1,prevItem:{title:"DefconQ meets KX - Mastering KDB+ Architecture - A Panel Discussion",permalink:"/blog/DefconQ meets KX - Mastering KDB+ Architecture - A Panel Discussion"},nextItem:{title:"DefconQ meets Fancy Quant - Alexander Unterrainer and Dimitri Bianco discuss KDB/Q",permalink:"/blog/DefconQ meets Fancy Quant - Alexander Unterrainer and Dimitri Bianco discuss KDB/Q"}},l={authorsImageUrls:[void 0]},c=[{value:"Left of Right and no Operator Precedence",id:"left-of-right-and-no-operator-precedence",level:2},{value:"Concept",id:"concept",level:3},{value:"Details",id:"details",level:3},{value:"Example",id:"example",level:3},{value:"KDB/Q is Atomic",id:"kdbq-is-atomic",level:2},{value:"Concept",id:"concept-1",level:3},{value:"Details",id:"details-1",level:3},{value:"Example",id:"example-1",level:3},{value:"Vector Operations and Column Oriented",id:"vector-operations-and-column-oriented",level:2},{value:"Concept",id:"concept-2",level:3},{value:"Details",id:"details-2",level:3},{value:"Example",id:"example-2",level:3},{value:"Interpreted and dynamic",id:"interpreted-and-dynamic",level:2},{value:"Concept",id:"concept-3",level:3},{value:"Details",id:"details-3",level:3},{value:"Example",id:"example-3",level:3},{value:"Functional",id:"functional",level:2},{value:"Concept",id:"concept-4",level:3},{value:"Details",id:"details-4",level:3},{value:"Example",id:"example-4",level:3},{value:"Dictionaries, Tables and Keyed Tables",id:"dictionaries-tables-and-keyed-tables",level:2},{value:"Concept",id:"concept-5",level:3},{value:"Details",id:"details-5",level:3},{value:"Example",id:"example-5",level:3},{value:"Synchronous and Asynchronous IPC for Real-Time Data",id:"synchronous-and-asynchronous-ipc-for-real-time-data",level:2},{value:"Concept",id:"concept-6",level:3},{value:"Details",id:"details-6",level:3},{value:"Example",id:"example-6",level:3},{value:"Bonus: Single Threaded",id:"bonus-single-threaded",level:2},{value:"Concept",id:"concept-7",level:3},{value:"Details",id:"details-7",level:3},{value:"Example",id:"example-7",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:'When developers first encounter KDB/Q, they are often intimidated by its "strange" syntax, which differs significantly from most other programming languages they\'ve seen. However, understanding and familiarizing oneself with the syntax is merely the beginning. To truly master any programming language, one needs a deep understanding of its core concepts and paradigms. For instance, when learning object-oriented languages like Java or C++, you should focus on concepts such as inheritance, encapsulation, polymorphism, and data abstraction. Additionally, understanding pointers and memory allocation is crucial for mastering C++. The same principle applies to KDB/Q, a high-performance, in-memory database and programming language. In this blog post, I will share the seven most important concepts that will set you apart and enhance your skills as a KDB/Q developer. Understanding these concepts will provide insight into why KDB/Q is so powerful and favored among quants and data enthusiasts.'}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"Please note, this blog post is primarily aimed at readers who are new to the KDB/Q programming language or just starting their learning journey. If you already have some experience with KDB/Q or are a seasoned developer, you might already be familiar with some or all of these concepts."})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"The Magnificient Seven",src:i(8997).A+"",width:"1156",height:"1158"})}),"\n",(0,a.jsx)(n.h2,{id:"left-of-right-and-no-operator-precedence",children:"Left of Right and no Operator Precedence"}),"\n",(0,a.jsx)(n.h3,{id:"concept",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"One of the most common mistakes made by qbies (newcomers to KDB/Q) is forgetting that KDB/Q is left-of-right, meaning it's read from right to left and has no operator precedence."}),"\n",(0,a.jsx)(n.h3,{id:"details",children:"Details"}),"\n",(0,a.jsx)(n.p,{children:"Unlike traditional programming languages like Java, C++, or Python, KDB/Q reads expressions from right to left. This makes expression evaluation simple and uniform, without unnecessary parentheses cluttering the code. Left-to-right evaluation eliminates any ambiguity in expressions, at least from the compiler's perspective if not yours. While parentheses can still be used to group terms and override the default evaluation order, you will find them much less necessary once you break old habits."}),"\n",(0,a.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["When evaluating the expression ",(0,a.jsx)(n.code,{children:"3*2+3"})," in KDB/Q, the result is ",(0,a.jsx)(n.code,{children:"15"}),", rather than ",(0,a.jsx)(n.code,{children:"9"})," as you might expect from traditional programming languages. This happens because KDB/Q adds ",(0,a.jsx)(n.code,{children:"3"})," to ",(0,a.jsx)(n.code,{children:"2"})," first, resulting in ",(0,a.jsx)(n.code,{children:"5"}),", which is then multiplied by ",(0,a.jsx)(n.code,{children:"3"})," to get the final result of ",(0,a.jsx)(n.code,{children:"15"}),". To evaluate the multiplication first, you need to use parentheses around the expression."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)3*2+3\n15\nq)(3*2)+3\n9\n"})}),"\n",(0,a.jsx)(n.h2,{id:"kdbq-is-atomic",children:"KDB/Q is Atomic"}),"\n",(0,a.jsx)(n.h3,{id:"concept-1",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"Another important concept of KDB/Q is that most built-in operators are atomic. This means that functions iterate recursively through data structures such as lists or dictionaries until they reach individual atoms and then apply the function to it."}),"\n",(0,a.jsx)(n.h3,{id:"details-1",children:"Details"}),"\n",(0,a.jsx)(n.p,{children:"Atomic functions apply recursively to every element of a list or dictionary. For unary atomic functions (those that take one parameter), the function applies to both atoms and lists, and for lists, it applies independently to each atom within the list. Binary atomic functions (those that take two parameters) can be atomic in both operands, resulting in four different applications:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Both operands are atoms."}),"\n",(0,a.jsx)(n.li,{children:"The first operand is a list, and the second is an atom."}),"\n",(0,a.jsx)(n.li,{children:"The first operand is an atom, and the second is a list."}),"\n",(0,a.jsx)(n.li,{children:"Both operands are lists."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// unary atomic function\nq)neg 10\n-10\nq)neg 10 20 30\n-10 -20 -30\nq)neg (10 20 30; 40 50)\n-10 -20 -30\n-40 -50\nq)neg `a`b`c!10 20 30\na| -10\nb| -20\nc| -30\nq)neg `a`b`c!(10 20; 30 40 50; 60)\na| -10 -20\nb| -30 -40 -50\nc| -60\n// binary atmoic function\nq)1+10\n11\nq)1+10 20 30\n11 21 31\nq)1 2 3+10\n11 12 13\nq)1 2 3+10 20 30\n11 22 33\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This atomic behavior makes KDB/Q a very powerful and efficient programming language. Imagine you have a nested list of numbers, some of which are null. Your task is to replace all null values with ",(0,a.jsx)(n.code,{children:"0"}),". In a traditional programming language like Java, you would need to loop through every element of the list and then through each sublist, as a nested list can contain multiple lists. In KDB/Q, however, this task is as simple as using the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/greater/",children:(0,a.jsx)(n.code,{children:"greator OR |"})})," operator"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)((0N 1 2 0N);((1 3;0N 1 2);(1 2 3;0N 0N 1 2));4 5 0N)\n0N 1 2 0N\n((1 3;0N 1 2);(1 2 3;0N 0N 1 2))\n4 5 0N\nq)0|((0N 1 2 0N);((1 3;0N 1 2);(1 2 3;0N 0N 1 2));4 5 0N)\n0 1 2 0\n((1 3;0 1 2);(1 2 3;0 0 1 2))\n4 5 0\n"})}),"\n",(0,a.jsx)(n.h2,{id:"vector-operations-and-column-oriented",children:"Vector Operations and Column Oriented"}),"\n",(0,a.jsx)(n.h3,{id:"concept-2",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"The previous concept of KDB/Q being atomic makes it inherently a vector-oriented language, meaning it operates on entire arrays (vectors) of data in a single operation."}),"\n",(0,a.jsx)(n.h3,{id:"details-2",children:"Details"}),"\n",(0,a.jsx)(n.p,{children:"Instead of processing individual elements in loops, KDB/Q applies functions and operations to whole vectors at once. This not only simplifies code but also significantly boosts performance by leveraging CPU vectorization capabilities."}),"\n",(0,a.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["To add two vectors ",(0,a.jsx)(n.code,{children:"a"})," and ",(0,a.jsx)(n.code,{children:"b"}),", you simply write ",(0,a.jsx)(n.code,{children:"c:a+b"}),". This operation is applied element-wise across the entire vectors."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)a:1 2 3\nq)b:4 5 6\nq)show c:a+b\n5 7 9\n"})}),"\n",(0,a.jsx)(n.p,{children:"This behaviour also extends to tables. KDB/Q is column-oriented and stores tables as flipped column dictionaries, with each column stored in contiguous memory as a vector. This setup allows for vectorized mathematical operations, making table manipulation incredibly fast."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t:([] a:1 2 3;b:4 5 6)\na b\n---\n1 4\n2 5\n3 6\nq)update c:a+b,d:a*b,e:neg a,f:10+b from t\na b c d  e  f\n--------------\n1 4 5 4  -1 14\n2 5 7 10 -2 15\n3 6 9 18 -3 16\n"})}),"\n",(0,a.jsx)(n.h2,{id:"interpreted-and-dynamic",children:"Interpreted and dynamic"}),"\n",(0,a.jsx)(n.h3,{id:"concept-3",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"KDB/Q code is interpreted at runtime, and both variables and functions are dynamic. This means they can hold data of any type, and the type can change during execution."}),"\n",(0,a.jsx)(n.h3,{id:"details-3",children:"Details"}),"\n",(0,a.jsx)(n.p,{children:"KDB/Q is both interpreted and dynamic, meaning that code doesn't need to be compiled and all functions are compiled into bytecode at runtime. Additionally, as a dynamic language, function definitions and variable types can be changed at runtime, with no type checking performed before execution. While these features make KDB/Q highly flexible, they also require careful design, thorough testing, and robust error handling to prevent production outages."}),"\n",(0,a.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["Below, we illustrate the dynamic behavior of KDB/Q by first assigning a string to a variable ",(0,a.jsx)(n.code,{children:"a"}),", then changing it to a numerical value, and finally to a function that we can execute."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'q)show a:"Hello"\n"Hello"\nq)show a:2\n2\nq)show a:{x+y}\n{x+y}\nq)a[2;3]\n5\n'})}),"\n",(0,a.jsx)(n.h2,{id:"functional",children:"Functional"}),"\n",(0,a.jsx)(n.h3,{id:"concept-4",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"KDB/Q heavily incorporates functional programming paradigms, emphasizing the use of functions as first-class citizens."}),"\n",(0,a.jsx)(n.h3,{id:"details-4",children:"Details"}),"\n",(0,a.jsx)(n.p,{children:"Functions can be passed as arguments, returned from other functions, and composed to build more complex functionality. KDB/Q's syntax and functions make it easy to perform operations like map, reduce, and filter directly on data sets. However, it's worth mentioning that KDB/Q is not purely functional as functions can have side effects."}),"\n",(0,a.jsx)(n.h3,{id:"example-4",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["Applying a function to each element of a list can be done with ",(0,a.jsx)(n.code,{children:"f each list"}),", where ",(0,a.jsx)(n.code,{children:"f"})," is a user-defined function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'q)f:count\nq)count each ("Hello";1 2 3;(2 3;4 5))\n5 3 2\n'})}),"\n",(0,a.jsx)(n.h2,{id:"dictionaries-tables-and-keyed-tables",children:"Dictionaries, Tables and Keyed Tables"}),"\n",(0,a.jsx)(n.h3,{id:"concept-5",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"KDB/Q provides powerful data structures for efficient data storage and manipulation natively and supports both row-oriented and column-oriented data access. These data structures include dictionaries, tables and keyed tables."}),"\n",(0,a.jsx)(n.h3,{id:"details-5",children:"Details"}),"\n",(0,a.jsx)(n.p,{children:"Dictionaries, Tables and Keyed Tables are data structures designed for high performance, efficient data storage and access and ideal for analytical tasks. All three data structures are supported by KDB/Q out of the box and are optimised to achieve optimal performance. In KDB/Q, Tables are similar to SQL tables with the difference that KDB/Q is column oriented, meaning each column is stored as a vector in contiguous memory, allowing for vectorised operations and making mathematical computations lightning fast."}),"\n",(0,a.jsx)(n.h3,{id:"example-5",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:"Demonstrating the power and performance of tables in analytics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// First we create a dummy table with random data\nq)show t:([] sym:10?`AAPL`C`C`MSFT`AAPL; price:10?100.0; qty:10?1000)\nsym  price    qty\n-----------------\nC    49.31835 908\nC    57.85203 360\nAAPL 8.388858 522\nC    19.59907 257\nC    37.5638  858\nC    61.37452 585\nC    52.94808 90\nAAPL 69.16099 683\nAAPL 22.96615 90\nC    69.19531 869\n// Calculating the volume-weighted average price (VWAP) per symbol for the data\nq)select wvap:price wavg qty by sym from t\nsym | wvap\n----| --------\nAAPL| 534.0731\nC   | 585.5224\n// Updating the table with the VWAP\nq)update wvap:price wavg qty by sym from t\nsym  price    qty wvap\n--------------------------\nC    49.31835 908 585.5224\nC    57.85203 360 585.5224\nAAPL 8.388858 522 534.0731\nC    19.59907 257 585.5224\nC    37.5638  858 585.5224\nC    61.37452 585 585.5224\nC    52.94808 90  585.5224\nAAPL 69.16099 683 534.0731\nAAPL 22.96615 90  534.0731\nC    69.19531 869 585.5224\n// Retrieving the well-known metrics: open, high, low, and close for each symbol\nq)exec `o`h`l`c!(first;max;min;last)@\\:price by sym from t\n    | o        h        l        c\n----| -----------------------------------\nAAPL| 8.388858 69.16099 8.388858 22.96615\nC   | 49.31835 69.19531 19.59907 69.19531\n"})}),"\n",(0,a.jsx)(n.h2,{id:"synchronous-and-asynchronous-ipc-for-real-time-data",children:"Synchronous and Asynchronous IPC for Real-Time Data"}),"\n",(0,a.jsx)(n.h3,{id:"concept-6",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"No other programming language makes interprocess communication (IPC) as easy and straightforward as KDB/Q. Designed for real-time data processing and streaming, KDB/Q supports both synchronous and asynchronous messaging right out of the box."}),"\n",(0,a.jsx)(n.h3,{id:"details-6",children:"Details"}),"\n",(0,a.jsx)(n.p,{children:"Designing event driven applications is critical for financial applications where real-time data feeds and low-latency processing are essential. KDB/Q processes and updates data in real-time, handling high-throughput data streams efficiently. Opening connections between two KDB/Q processes, whether on the same server or different servers, requires minimal effort and can be accomplished with a single command. Data is serialized before being sent and deserialized upon receipt, minimizing the amount of data transferred over the network. Asynchronous communication and advanced IPC patterns can be leveraged to design efficient and scalable applications."}),"\n",(0,a.jsx)(n.h3,{id:"example-6",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'// Server: start a q process and assign port 5001 to it\nq)\\p 5001\nq)\n// Client: Open a connection to the server using hopen and send a synchronous query to it\nq)h:hopen `::5001\nq)h"2+2"\n4\n'})}),"\n",(0,a.jsx)(n.h2,{id:"bonus-single-threaded",children:"Bonus: Single Threaded"}),"\n",(0,a.jsx)(n.h3,{id:"concept-7",children:"Concept"}),"\n",(0,a.jsx)(n.p,{children:"KDB/Q operates in a single-threaded mode by default, ensuring data consistency and avoiding race conditions, as all operations are executed in the order they are received."}),"\n",(0,a.jsx)(n.h3,{id:"details-7",children:"Details"}),"\n",(0,a.jsxs)(n.p,{children:["Even though KDB/Q is single-threaded, simplifying program design and avoiding the complexities of multi-threaded applications, you can still leverage parallel processing by starting your KDB/Q process with secondary threads using ",(0,a.jsx)(n.code,{children:"-s n"}),", where ",(0,a.jsx)(n.code,{children:"n"})," is the number of secondary threads. Moreover, since KDB/Q version 4.0, all primitive operators are implicitly multi-threaded. Starting your KDB/Q process with a negative secondary threads flag ",(0,a.jsx)(n.code,{children:"-s -n"})," will utilize parallel processes instead of secondary threads for parallel processing."]}),"\n",(0,a.jsx)(n.h3,{id:"example-7",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)f:{sum exp x?1.0}\nq)\\ts f each 2#1000000\n25 16777728\nq)\\ts f peach 2#1000000 ~\n0 1120\n"})}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Understanding these key concepts is crucial for mastering KDB/Q and elevating your development skills. Each concept, from the left-of-right evaluation and atomic functions to dynamic typing and interprocess communication, contributes to the power and efficiency of KDB/Q, making it a preferred choice for real-time data processing and high-performance analytics. By familiarizing yourself with these principles, you'll be better equipped to leverage the full potential of KDB/Q, enabling you to write more efficient, robust, and maintainable code."}),"\n",(0,a.jsx)(n.p,{children:"If you like to deepen your knowledge further, check out the following references and links"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.defconq.tech/blog/How%20to%20Read,%20Understand%20and%20Learn%20KDB/Q%20code",children:"How To Read, Understand and Learn KDB/Q Code"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.defconq.tech/docs/concepts/dictionariesTables",children:"Dictionaries and Tables"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.defconq.tech/docs/architecture/plain",children:"The Plain Vanilla Tick Setup"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.defconq.tech/docs/tutorials/tick",children:"KDB Tick Explained - A Walkthrough"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.defconq.tech/docs/language/why_KDB",children:"Unleashing the Power of Time-Series Analysis and Big Data: Why KDB/Q Reigns Supreme"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8997:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/seven-81f22d1664bf577e101aa8b34d66cce4.png"},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var a=i(6540);const t={},s=a.createContext(t);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);