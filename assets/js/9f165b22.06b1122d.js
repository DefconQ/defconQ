"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[98],{9655:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var t=i(4848),a=i(8453);const o={sidebar_position:5},s="Dictionaries and Tables",r={id:"concepts/dictionariesTables",title:"Dictionaries and Tables",description:"In this blog post, we explore two key data types native to KDB/Q: Dictionaries and Tables. Unlike mainstream programming languages like Java, which lack native support for these data types and require alternative structures (e.g., Java HashMap for dictionaries or Java ArrayList for lists of rows to represent tables), KDB/Q inherently supports both Dictionaries and Tables. Understanding these data structures is crucial for leveraging the speed and performance of KDB/Q to build efficient big data applications. In the following sections, we will examine the most important concepts of both data types, a in detail explanation of dictionaries and tables is beyond the scope of this blog post and can be found in Chapter 5 - Dictionaries and Chapter 8 - Tables of Q for Mortals.",source:"@site/docs/concepts/dictionariesTables.mdx",sourceDirName:"concepts",slug:"/concepts/dictionariesTables",permalink:"/docs/concepts/dictionariesTables",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Amend, Amend At: The Swiss Army knife among KDB/Q operators",permalink:"/docs/concepts/amend"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},c={},d=[{value:"Dictionaries",id:"dictionaries",level:2},{value:"Creating Dictionaries",id:"creating-dictionaries",level:3},{value:"Indexing into a dictionary",id:"indexing-into-a-dictionary",level:3},{value:"Reverse Lookup: Finding values",id:"reverse-lookup-finding-values",level:3},{value:"Operations on a single Dictionary",id:"operations-on-a-single-dictionary",level:3},{value:"Operations involving multiple Dictionaries",id:"operations-involving-multiple-dictionaries",level:3},{value:"Joining Dictionaries",id:"joining-dictionaries",level:3},{value:"Column Dictionaries",id:"column-dictionaries",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"dictionaries-and-tables",children:"Dictionaries and Tables"}),"\n",(0,t.jsxs)(n.p,{children:["In this blog post, we explore two key data types native to KDB/Q: ",(0,t.jsx)(n.strong,{children:"Dictionaries and Tables"}),". Unlike mainstream programming languages like Java, which lack native support for these data types and require alternative structures (e.g., Java HashMap for dictionaries or Java ArrayList for lists of rows to represent tables), KDB/Q inherently supports both Dictionaries and Tables. Understanding these data structures is crucial for leveraging the speed and performance of KDB/Q to build efficient big data applications. In the following sections, we will examine the most important concepts of both data types, a in detail explanation of dictionaries and tables is beyond the scope of this blog post and can be found in ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q4m3/5_Dictionaries/#50-overview",children:"Chapter 5 - Dictionaries"})," and ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q4m3/8_Tables/",children:"Chapter 8 - Tables"})," of ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q4m3/",children:"Q for Mortals"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["As noted on the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/#datatypes",children:"reference page"})," at ",(0,t.jsx)(n.a,{href:"https://code.kx.com/home/",children:"code.kx.com"}),", dictionaries are of type 99h, while tables are of type 98h."]})}),"\n",(0,t.jsx)(n.h2,{id:"dictionaries",children:"Dictionaries"}),"\n",(0,t.jsxs)(n.p,{children:["In its simplest form, a dictionary is simply a mapping of a list of keys to a list of values, and it can be created using the ",(0,t.jsxs)(n.a,{href:"https://code.kx.com/q/ref/dict/",children:["bang operator ",(0,t.jsx)(n.code,{children:"!"})]}),". Let's look at an example:"]}),"\n",(0,t.jsx)(n.h3,{id:"creating-dictionaries",children:"Creating Dictionaries"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Create a list of keys\nq)k:`a`b`c\n// Create a list of values\nq)v:1 2 3\n// Create the mapping between keys and values\nq)k!v\na| 1\nb| 2\nc| 3\n// Create a dictionary directly\nq)`a`b`c!1 2 3\na| 1\nb| 2\nc| 3\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["The keywords ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/key/",children:(0,t.jsx)(n.code,{children:"key"})}),"  and ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/value/",children:(0,t.jsx)(n.code,{children:"value"})})," can be used to extract the keys and values from a dictionary, respectively."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\nq)key d\n`a`b`c\nq)value d\n1 2 3\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["Dictionaries are highly flexible data structures. The main constraint when creating a dictionary is that the length of the keys list must match the length of the values list. If they don't match, a ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/basics/errors/",children:(0,t.jsx)(n.code,{children:"length error"})})," will occur."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)`a`b`c!1 2 3 4\n'length\n  [0]  `a`b`c!1 2 3 4\n             ^\n"})}),"\n",(0,t.jsx)(n.p,{children:"To demonstrate the flexibility of dictionaries, note that the type of the list of keys or values doesn\u2019t have to be homogeneous. However, once you create a homogeneous list of keys or values, any new key or value added must match the existing types. This might sound complex, but it's easier to understand with some examples. Let's take a look."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// Create a dictionary with a list of non-homogenous keys\nq)show d:(`a;10;"C")!1 2 3\n`a | 1\n10 | 2\n"C"| 3\n// Add a new key of type integer\nq)d[2]:4\nq)d\n`a | 1\n10 | 2\n"C"| 3\n2  | 4\n// Add another key of type symbol\nq)d[`b]:9\nq)d\n`a | 1\n10 | 2\n"C"| 3\n2  | 4\n`b | 9\n'})}),"\n",(0,t.jsxs)(n.p,{children:["As shown in the example above, the keys of our dictionary can be of different types, allowing us to add new keys of any type. However, the values of the dictionary are all ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/#datatypes",children:(0,t.jsx)(n.code,{children:"long 7h"})}),". Attempting to add a record where the value type doesn't match the current value types will result in a type error."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// Verify the data type of the keys of our dictionary\nq)type value d\n7h\n// Trying to add a new record with a symbol as value\nq)d["z"]:`hello\n\'type\n  [0]  d["z"]:`hello\n             ^\n'})}),"\n",(0,t.jsxs)(n.p,{children:["With the release of KDB/Q ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q//releases/ChangesIn4.1/",children:"version 4.1"}),", ",(0,t.jsx)(n.a,{href:"https://kx.com",children:"KX"})," introduced a new dictionary syntax that enhances both the readability and flexibility of the language. In KDB/Q 4.1, you can now define dictionaries as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)([a:1;b:2;c:3])\na| 1\nb| 2\nc| 3\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is especially useful for creating empty or singleton dictionaries, which was quite verbose and cumbersome before version 4.1. See for yourself:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Creating an empty, untyped dictionary\nq)d:()!()\nq)0N!d\n()!()\n// Creating an empty dictionary with keys of type integer and values of type symbol\nq)d:(`int$())!`symbol$()\nq)0N!d\n(`int$())!`symbol$()\n// Creating a singleton dictionary\nq)enlist[`a]!enlist 3\na| 3\n"})}),"\n",(0,t.jsx)(n.p,{children:"In contrast, with KDB/Q version 4.1 above dictionary definitions became much easier and more readable"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Creating an empty dictionary\nq)d:([])\nq)0N!d\n(`symbol$())!()\n// Creating a singleton dictionary\nq)d:([a:3])\nq)d\na| 3\n"})}),"\n",(0,t.jsx)(n.h3,{id:"indexing-into-a-dictionary",children:"Indexing into a dictionary"}),"\n",(0,t.jsxs)(n.p,{children:["When you index into a dictionary, you are essentially performing a dictionary lookup, accessing a dictionary ",(0,t.jsx)(n.code,{children:"d"})," to retrieve the value ",(0,t.jsx)(n.code,{children:"v"})," at the specified key ",(0,t.jsx)(n.code,{children:"k"}),". You can index into a dictionary using both, brackets and postfix notation"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\n// Indexing into a dictionary using bracket notation\nq)d[`a]\n1\n// Indexing into a dictionary using postfix notation\nq)d`a\n1\n// Ensuring both notations return the same result\nq)d[`a]~d`a\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can also retrieve multiple elements using a list of keys as index"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\nq)d[`a`b]\n1 2\nq)d`a`b\n1 2\n"})}),"\n",(0,t.jsx)(n.p,{children:"However, due to the flexibility of dictionaries, their keys don't have to be unique, allowing the same key to be used multiple times. This can lead to unexpected results when retrieving elements stored at a key that's used more than once."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d:`a`b`c`a`b`c`d!til 7\nq)d\na| 0\nb| 1\nc| 2\na| 3\nb| 4\nc| 5\nd| 6\nq)d`a\n0\nq)d`b\n1\nq)d?3\n`a\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reverse-lookup-finding-values",children:"Reverse Lookup: Finding values"}),"\n",(0,t.jsxs)(n.p,{children:["Indexing into a dictionary is straightforward and a common operation. However, there are times when we need to perform the reverse operation: finding the key associated with a specific value. This is called a reverse lookup and we can accomplish this using the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/find/",children:(0,t.jsx)(n.code,{children:"find ?"})})," operator as follows"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\nq)d\na| 1\nb| 2\nc| 3\nq)d?3\n`c\n"})}),"\n",(0,t.jsxs)(n.p,{children:["One drawback of the ",(0,t.jsx)(n.code,{children:"find ?"})," operator is that, for a list with non-unique elements, it will only return the index of the first occurrence of an element that appears multiple times. When applied to a dictionary, if the value being searched for occurs multiple times, only the first key associated with that value will be returned."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d:`a`b`c`d`e`f!1 2 3 1 2 3\nq)d\na| 1\nb| 2\nc| 3\nd| 1\ne| 2\nf| 3\nq)d?1\n`a\n"})}),"\n",(0,t.jsxs)(n.p,{children:["But don't worry. Fortunately, we can use the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/basics/comparison/#six-comparison-operators",children:(0,t.jsx)(n.code,{children:"equals ="})})," operator along with the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q/ref/where/",children:(0,t.jsx)(n.code,{children:"where"})})," keyword to find all keys for the value we're searching for. The following method will return exactly what you need."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d:`a`b`c`d`e`f!1 2 3 1 2 3\n// When comparing a dictionary to a value, the comparison is applied to every value of the dictionary\n// resulting in a boolean mask, indicating 1 where the comparison is true, and 0 where it is false\nq)d=1\na| 1\nb| 0\nc| 0\nd| 1\ne| 0\nf| 0\n// We can now leverage where to obtain the keys where the boolean mask is 1b\nq)where d=1\n`a`d\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"The code snippet above highlights a crucial concept about dictionaries. Fully understanding this will enhance your skills as a KDB/Q developer: the key-value mapping of a dictionary is analogous to the index-value mapping of a list. To clarify, if you have a list of numbers from 0 to 10, each number is implicitly mapped to its index\u20140 is mapped to index 0 (since KDB/Q uses zero-based indexing), 1 to index 1, 2 to index 2, and so forth. In a dictionary, this same index-value mapping occurs, but with keys serving as the index instead of numerical values. Moreover, there's nothing stopping you from creating a dictionary with numerical keys mapped to numerical values. Remembering that operations on dictionaries affect their values while leaving keys unchanged provides a powerful tool for your development. Let me illustrate what I just explained"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Creating a dictionary mapping the numbers 0 to 5 to the corresponding value\nq)0 1 2 3 4!0 1 2 3 4\n0| 0\n1| 1\n2| 2\n3| 3\n4| 4\n// same operation but in q-style\nq)x!x:til 5\n0| 0\n1| 1\n2| 2\n3| 3\n4| 4\nq)d:x!x:til 5\n// indexing into the dictionary at index 0\nq)d 0\n0\n// Creating a list of values from 0 to 5\nq)l:til 5\n// indexing into the list at index 0\nq)l 0\n0\n// Showing that both operations return the same result\nq)d[0]~l 0\n1b\n"})}),"\n",(0,t.jsx)(n.h3,{id:"operations-on-a-single-dictionary",children:"Operations on a single Dictionary"}),"\n",(0,t.jsx)(n.p,{children:"One of the great features of KDB/Q dictionaries is that applying a function to a dictionary effectively applies it to the dictionary's value list. Let me show you some examples:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// First we create a dictionary\nq)d:`a`b`c!1 2 3\n// We can convert all values to their corresponding negative value by using the keyword neg \nq)neg d\na| -1\nb| -2\nc| -3\n// Find the minimum value in the dictinary\nq)min d\n1\n// Multiply all values by 2\nq)2*d\na| 2\nb| 4\nc| 6\n// Compare the values of the dictionary to the value 2\nq)d=2\na| 0\nb| 1\nc| 0\n// count returns the length of the dictionary\nq)count d\n3\n// Return the first value of the dictionary d\nq)first d\n1\n// Return the last value of the dictionary d\nq)last d\n3\n"})}),"\n",(0,t.jsxs)(n.p,{children:["There are many other useful operations you can perform on dictionaries. For a detailed explanation, please refer to ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q4m3/5_Dictionaries/",children:"Chapter 5: Dictionaries"})," in Q for Mortals."]}),"\n",(0,t.jsx)(n.h3,{id:"operations-involving-multiple-dictionaries",children:"Operations involving multiple Dictionaries"}),"\n",(0,t.jsx)(n.p,{children:"We've already seen how to apply functions to a single dictionary. In this section, we'll explore how to use two or more dictionaries together with the KDB/Q operators we've covered so far. When applying functions such as addition, subtraction, multiplication or division to two dictionaries, the operation will match all common keys and apply the function to the value(s) of the matching key(s). Let's illustrate this with an example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d1:`a`b`c!1 2 3\nq)d2:`a`b`c!4 5 6\nq)d1+d2\na| 5\nb| 7\nc| 9\nq)d1-d2\na| -3\nb| -3\nc| -3\nq)d1*d2\na| 4\nb| 10\nc| 18\nq)d1%d2\na| 0.25\nb| 0.4\nc| 0.5\n"})}),"\n",(0,t.jsx)(n.p,{children:"But what happens if any of the two dictionaries contains non matching keys?"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d1+`a`b`d!6 7 8\na| 7\nb| 9\nc| 3\nd| 8\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As demonstrated above, the result is the union of the records in both dictionaries. The function is applied to all records where the keys match, and records without matching keys are amended using the ",(0,t.jsx)(n.a,{href:"https://code.kx.com/q4m3/5_Dictionaries/#527-arithmetic-and-relational-operations",children:"identity element"})," (0 for addition and subtraction and 1 for multiplication and division) of the operation as the second parameter."]}),"\n",(0,t.jsx)(n.h3,{id:"joining-dictionaries",children:"Joining Dictionaries"}),"\n",(0,t.jsx)(n.p,{children:"One of the great features of dictionaries is their behavior when joined. Since a dictionary is just a key-value mapping, joining two dictionaries will update the values of all matching keys in the first dictionary with the corresponding values from the second dictionary. Let's demonstrate this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)d1:`a`b`c!1 2 3\nq)d1\na| 1\nb| 2\nc| 3\nq)d2:`a`b`c!10 20 30\nq)d2\na| 10\nb| 20\nc| 30\nq)d1,d2\na| 10\nb| 20\nc| 30\n"})}),"\n",(0,t.jsx)(n.p,{children:"This feature is especially useful when designing your Application Programming Interfaces (APIs). You can pass a dictionary containing all the parameters for your API and within your function, you can then define a dictionary with the default parameters needed for your API's functionality. By joining the user-provided dictionary with the default parameters dictionary, you obtain all the necessary parameters. Let's look at some code to illustrate this concept."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"function:{[param]\n\tdefault:`a`b`c!1 2 3;\n\tres:defalut,param;\n\t:res\n\t};\n\nq)function[`a`b!10 20]\na| 10\nb| 20\nc| 3\n"})}),"\n",(0,t.jsx)(n.h3,{id:"column-dictionaries",children:"Column Dictionaries"}),"\n",(0,t.jsx)(n.p,{children:"Now that we've covered the basics of dictionaries, we can move on to a crucial concept for understanding our next topic: tables. This concept is column dictionaries, which form the foundation of tables. A column dictionary is a dictionary where each key is of type symbol, and each value is a list of values with the same length as all the other values. The formal definition is"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"`c1...`cN!(v1;...;vN)\nwhere \n - each c1 is a column name as symbol\n and\n - each v1 is a list of values\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's look at a more practical example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)team:`name`age!(`Bob`Joe`Frank;25 35 40)\nq)team\nname| Bob Joe Frank\nage | 25  35  40\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, this dictionary contains two keys, ",(0,t.jsx)(n.code,{children:"name"})," and ",(0,t.jsx)(n.code,{children:"age"}),", which map to the corresponding names and ages of our team members. To retrieve all the names, you can index into the dictionary using the key ",(0,t.jsx)(n.code,{children:"name"})," like this ",(0,t.jsx)(n.code,{children:"team[`name]"}),".  Similarly, to get the ages of our team, you would use ",(0,t.jsx)(n.code,{children:"team[`age]"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Retrieve the names of the team\nq)team[`name]\n`Bob`Joe`Frank\n// Retrieve the age of the team\nq)team[`age]\n25 35 40\n"})}),"\n",(0,t.jsx)(n.p,{children:"Since each value in a column dictionary is actually a list, we can index into these lists as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Indexing into a list of values for the name key\nq)team[`name] 1\n`Joe\n// Using nested indexing to achieve the same\nq)team[`name;1]\n`Joe\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, if you recall, creating a singleton dictionary was somewhat cumbersome, and the same applies to a singleton column dictionary. Since a dictionary is a list of keys mapped to a list of values (or, in the case of a column dictionary, a list of lists), we need to use ",(0,t.jsx)(n.code,{children:"enlist"})," to create a singleton column dictionary."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)enlist[`name]!enlist `Bob`Joe`Frank\nname| Bob Joe Frank\n"})}),"\n",(0,t.jsx)(n.p,{children:"Luckily for us, this is much simpler with KDB/Q version 4.1"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"q)([name:`Bob`Joe`Frank])\nname| Bob Joe Frank\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We\u2019ve covered a lot about dictionaries so far, and now it's time to discuss the most important concept regarding column dictionaries. A ",(0,t.jsx)(n.em,{children:"flipped column dictionary"})," is simply a ",(0,t.jsx)(n.em,{children:"table"}),". Yes, that's right. If you flip a column dictionary, you get a table. Let's see this in practice."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Column Dictionary team, mapping name and age keys to a list of names and their corresponding ages\nq)team\nname| Bob Joe Frank\nage | 25  35  40\n// Creating a table by flipping a column dictionary\nq)show t:flip team\nname  age\n---------\nBob   25\nJoe   35\nFrank 40\n"})}),"\n",(0,t.jsx)(n.p,{children:"Additionally, it's worth noting that a table can be seen as a list of dictionaries that all conform, meaning the dictionaries share the same keys. In fact, KDB/Q will always aggregate a list of conforming dictionaries into a table."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Create a list of dictionaries that are all conform\nq)((`name`age!(`Bob;25));(`name`age!(`Joe;35));(`name`age!(`Frank;40)))\nname  age\n---------\nBob   25\nJoe   35\nFrank 40\n"})}),"\n",(0,t.jsx)(n.p,{children:"This understanding clarifies that we can access records in a table in the same way we index into a list, using position indexes. For instance, to retrieve the second record of our table, we simply use the index 1."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Indexing into a table\nq)t 1\nname| `Joe\nage | 35\n// Indexing into a list of conform dictionaries\nq)((`name`age!(`Bob;25));(`name`age!(`Joe;35));(`name`age!(`Frank;40))) 1\nname| `Joe\nage | 35\n// Verify that above results are in fact the same\nq)t[1]~((`name`age!(`Bob;25));(`name`age!(`Joe;35));(`name`age!(`Frank;40))) 1\n1b\n"})}),"\n",(0,t.jsx)(n.p,{children:"Last but not least, I'll explain why table operations are so performant and fast in KDB/Q. Tables are essentially column dictionaries, where each value is a list. Since KDB/Q is a vector/array programming language, operations on lists or vectors are highly efficient. Therefore, tables are represented as flipped column dictionaries in the background, rather than as a list of rows (simple dictionaries). This structure enables super-fast operations on columns, making KDB/Q much faster than conventional programming languages."}),"\n",(0,t.jsx)(n.p,{children:"We'll pause here for now, giving you time to absorb all the information covered in this blog. I'll update the blog later with a more detailed explanation of tables. If you have any questions, feel free to reach out."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Happy Coding!"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var t=i(6540);const a={},o=t.createContext(a);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);