"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7633],{48072:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(74848),a=t(28453);const o={sidebar_position:2},s="Code Organistation - Your own KDB/Q Library",r={id:"codingPractice/codeOrganisation",title:"Code Organistation - Your own KDB/Q Library",description:"When I first started working as a software developer in an investment bank, I was initially placed in a C# team. After completing all the onboarding, installing Microsoft Visual Studio and gaining access to my team's codebase, I was finally able to have a look at the project I was going to work on. Little did I know, what nightmare I was about to face. Upon opening the project, I discovered that the average length of each class exceeded 15 thousand lines. Yes, you read that correctly; it's not a typo, but the shocking reality I was faced with. Navigating the code base was hard enough, but making a change without breaking anything seemed to be impossible. Luckily, I eventually transitioned to a team that embraced the concept of code organization.",source:"@site/docs/codingPractice/codeOrganisation.mdx",sourceDirName:"codingPractice",slug:"/codingPractice/codeOrganisation",permalink:"/docs/codingPractice/codeOrganisation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"If the Mountain Won\u2019t Come to You...",permalink:"/docs/codingPractice/prophet"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},l={},c=[{value:"KDB/Q Code organisation: an example",id:"kdbq-code-organisation-an-example",level:2},{value:"Power Packed Libraries: Bundled Functionality",id:"power-packed-libraries-bundled-functionality",level:3},{value:"Seamless Integration: The Execute File Solution",id:"seamless-integration-the-execute-file-solution",level:3},{value:"Leveraging Namespaces",id:"leveraging-namespaces",level:2},{value:"Same Yet Different",id:"same-yet-different",level:3},{value:"Namespaces Revealed: Your Handy Dictionary",id:"namespaces-revealed-your-handy-dictionary",level:3},{value:"Gotchas",id:"gotchas",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"code-organistation---your-own-kdbq-library",children:"Code Organistation - Your own KDB/Q Library"}),"\n",(0,i.jsx)(n.p,{children:"When I first started working as a software developer in an investment bank, I was initially placed in a C# team. After completing all the onboarding, installing Microsoft Visual Studio and gaining access to my team's codebase, I was finally able to have a look at the project I was going to work on. Little did I know, what nightmare I was about to face. Upon opening the project, I discovered that the average length of each class exceeded 15 thousand lines. Yes, you read that correctly; it's not a typo, but the shocking reality I was faced with. Navigating the code base was hard enough, but making a change without breaking anything seemed to be impossible. Luckily, I eventually transitioned to a team that embraced the concept of code organization."}),"\n",(0,i.jsx)(n.p,{children:"As your codebase expands and evolves, incorporating increasingly sophisticated functionality, it naturally becomes more complex and therefore more challenging to navigate, comprehend, and maintain. Hence, it's crucial to adopt a systematic approach to code organization. Doing so not only ensures extensibility and scalability but also simplifies development in the long run. Modularizing your code, as well as other various strategies exist for organizing code. In traditional object-oriented programming languages like Java or C#, organization typically revolves around classes, packages, or, on a broader scale, projects. However, there's no reason why a similar concept can't be applied in KDB/Q. In this blog post, I'll introduce a simple yet effective method of organizing your code. Additionally, I'll share some valuable tips and tricks gleaned from years of experience."}),"\n",(0,i.jsx)(n.h2,{id:"kdbq-code-organisation-an-example",children:"KDB/Q Code organisation: an example"}),"\n",(0,i.jsxs)(n.p,{children:["One easy way to organise your code involves splitting the code into a ",(0,i.jsx)(n.strong,{children:"library file"})," containing all Application Programming Interfaces (APIs) and an ",(0,i.jsx)(n.strong,{children:"execute file"})," containing initialization logic along with global variable definitions, loaded by a KDB/Q process upon start-up. You can then package your code into various modules or packages based on dataset, asset class, or any other classification of your preference, applying the library and execute file pattern consistently across them."]}),"\n",(0,i.jsx)(n.h3,{id:"power-packed-libraries-bundled-functionality",children:"Power Packed Libraries: Bundled Functionality"}),"\n",(0,i.jsx)(n.p,{children:"To enhance the extensibility and scalability of your application, it's recommended to make your code as modular as possible. This can be accomplished by exposing the business logic of your code through an API and consolidating functions related to specific functionalities or features into individual packages. Let's consider the scenario where we aim to construct a library containing fundamental mathematical functions. The following code snippet demonstrates the contents of our library file:"}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Below code is a very basic, simplified example for illustrative purposes"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// math.library.q\n// This is a library to compute basic mathematical operations\n\n// add: \tFunction to perform addition\n// @param: \tx - first parameter\n// @param: \ty - second parameter\n// @return: \tsum of x and y\nadd:{[x;y]\n        :x+y;\n        };\n\n// sub: \tFunction to perform subtraction\n// @param:\tx - first parameter\n// @param:\ty - second parameter\n// @return:\tsubtracts y from x\nsub:{[x;y]\n        :x-y;\n        };\n\n// mult:\tFunction to perform multiplication\n// @param:\tx - first parameter\n// @param:\ty - second parameter\n// @result:\tproduct of x and y\nmult:{[x;y]\n        :x*y;\n        };\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now, we've developed our very own, simple math library featuring essential functions that can be reused as required. We can effortlessly load this library into any process to leverage its functionality without having to duplicate any code. In the following section, we'll demonstrate how to utilize this library."}),"\n",(0,i.jsx)(n.h3,{id:"seamless-integration-the-execute-file-solution",children:"Seamless Integration: The Execute File Solution"}),"\n",(0,i.jsx)(n.p,{children:"While you can load your library into nearly any KDB/Q process allows for reusing the exposed APIs, another approach involves creating a file to be passed to a KDB/Q process during startup. Within this file, you can initialize global variables utilized within the process and establish an initialization function to be called upon the process's start. But examples speak louder than words, so let's check one out."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// math.exe.q\n// This is our execution file, the file we load when we start our KDB/Q process\n// Loading the math library we created, exposing all the functions in it\nsystem "l math.library.q";\n\n// Setting global variables\nnum1:4;\nnum3:8;\n\n// init:\tInitialisation function\ninit:{[]\n\t// Within our initialisation function we define another number\n\tnum2:5;\n\t// We can now use the APIs defined in our libray\n\t-1 "Adding number ",string[num1], " to number ", string[num2], " --\x3e result: ",string add[num1;num2];\n        -1 "Subtracting number ",string[a], " from number ", string[b], " --\x3e result: ",string add[b:9;a:3];\n        -1 "Multiplying number ",string[num2], " with number ", string[num3], " --\x3e result: ",string add[num2;num3];\n\t};\n\n// At then end of our execute file we call the init function\ninit[];\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now, we can initiate a KDB/Q process and load our execute file upon startup. This action handles the loading of our library, initializes any global variables, and then executes the init function to complete the remaining initialization tasks."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Alexander@Alexanders-MacBook-Pro:~/repos/testCode|\n\u21d2  qq math.exe.q\nKDB+ 4.0 2023.01.20 Copyright (C) 1993-2023 Kx Systems\nm64/ 4(24)core 8192MB Alexander alexanders-macbook-pro.local 127.0.0.1 EXPIRE 2025.02.21 XXXX@gmail.com KDB PLUS TRIAL #5018719\n\nAdding number 4 to number 5 --\x3e result: 9\nSubtracting number 3 from number 9 --\x3e result: 12\nMultiplying number 5 with number 8 --\x3e result: 13\nq)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Above pattern is a powerful yet simple  technique for structuring your code and enhancing its modularity. By grouping similar functionalities into a library, you can conveniently reuse them as required, thereby eliminating redundant code duplication. Additionally, the execution file provides an easy method to configure your KDB/Q process and import all necessary libraries."}),"\n",(0,i.jsx)(n.h2,{id:"leveraging-namespaces",children:"Leveraging Namespaces"}),"\n",(0,i.jsx)(n.p,{children:"In the upcoming section, I'll share two additional tips and tricks that I've found to be especially useful when organizing your code. These strategies not only contribute to cleaner code but also enhance its comprehensibility and ease of navigation."}),"\n",(0,i.jsx)(n.h3,{id:"same-yet-different",children:"Same Yet Different"}),"\n",(0,i.jsx)(n.p,{children:"At times, we find ourselves repeatedly implementing similar or identical functionalities, with only minor variations, such as asset class, instrument, or data source. This practice not only complicates the code and reduces readability but it can also be very confusing for users. They may wonder which function to use, what parameters to pass, and how the result appears. In the following section, I'll demonstrate how namespaces can simplify everyone's workflow."}),"\n",(0,i.jsxs)(n.p,{children:["Let's have a look at some code. First, we create a helper function, to verify whether a certain function exists or not. We can do so by using the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/key/",children:(0,i.jsx)(n.code,{children:"key"})})," operator. While the ",(0,i.jsx)(n.code,{children:"key"})," operator is commonly used for retrieving the keys of a dictionary or table, it can also be used to verify whether a folder or file exists, or in our case, if a name is defined or not."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)exists:{not ()~key x}\nq)exists `a\n0b\nq)a:1\nq)exists `a\n1b\n"})}),"\n",(0,i.jsx)(n.p,{children:"Next, we'll develop a set of functions that exhibit similar behavior but with slight variations. Specifically, in our scenario, he behaviour of the function differ based on the data source we want to retrieve. Additionally, we include a default function for cases where the user specifies a data source for which we haven't implemented a function yet. In such instances, we'll return the result using a default data source."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q).equities.bloomberg.getData:{: ([] sym:`AAPL`MSFT`GOOG; source:3#`BBG;price:3?10)}\nq).equities.refinitive.getData:{: ([] sym:`AAPL`MSFT`GOOG; source:3#`REF;price:3?10)}\nq).equities.default.getData:{: ([] sym:`AAPL`MSFT`GOOG; source:3#`INHOUSE;price:3?10)}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finally, all we have to do, is to create a function that we are going to expose to our users. The user will specify the data source they desire, and the function will handle the appropriate call to the corresponding function. Should the specified data source be unavailable, we'll return data obtained from a default source."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:".equities.getData:{[datasource] \n\t// Create the namespace for the datasource and verify if it exists\n\t// If it exists, invoke the function and return result\n\t// If it doesn't, invoke default function and return result\n\tif[exists f:` sv (`.equities;datasource;`getData);:f[]]; :.equities.default.getData[] \n\t};\n"})}),"\n",(0,i.jsx)(n.p,{children:"Below code should illustrate this behaviour"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Verify if function exists. Note: typo\nq)exists `.equities.bloomber.getData\n0b\n// Existing function\nq)exists `.equities.bloomberg.getData\n1b\n// Creating the namespace\nq)` sv `.equities`bloomberg`getData\n`.equities.bloomberg.getData\n// Combining above\nq)exists ` sv `.equities`bloomberg`getData\n1b\n// individual functions\nq).equities.refinitive.getData[]\nsym  source price\n-----------------\nAAPL REF    8\nMSFT REF    1\nGOOG REF    9\nq).equities.bloomberg.getData[]\nsym  source price\n-----------------\nAAPL BBG    5\nMSFT BBG    4\nGOOG BBG    6\n// the .equities namespace\nq).equities\n          | ::\nbloomberg | ``getData!(::;{: ([] sym:`AAPL`MSFT`GOOG; source:3#`BBG;price:3?1..\nrefinitive| ``getData!(::;{: ([] sym:`AAPL`MSFT`GOOG; source:3#`REF;price:3?1..\ndefault   | ``getData!(::;{: ([] sym:`AAPL`MSFT`GOOG; source:3#`INHOUSE;price..\ngetData   | {[datasource] if[exists f:` sv (`.equities;datasource;`getData);:..\n// Function exposed to and used by clients\nq).equities.getData[`bloomberg]\nsym  source price\n-----------------\nAAPL BBG    5\nMSFT BBG    4\nGOOG BBG    9\nq).equities.getData[`refinitive]\nsym  source price\n-----------------\nAAPL REF    2\nMSFT REF    7\nGOOG REF    0\n// Function call with data source that doesn't exists\n// Defaults to INHOUSE data\nq).equities.getData[`ICE]\nsym  source  price\n------------------\nAAPL INHOUSE 1\nMSFT INHOUSE 9\nGOOG INHOUSE 2\n"})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, we've developed a feature that exposes just one simple API to our clients, ensuring ease and simplicity in their usage. Furthermore, we're now capable of effortlessly expanding our function's behavior and incorporating more functionalities for new data sources, requiring minimal code refactoring."}),"\n",(0,i.jsx)(n.h3,{id:"namespaces-revealed-your-handy-dictionary",children:"Namespaces Revealed: Your Handy Dictionary"}),"\n",(0,i.jsxs)(n.p,{children:["In KDB/Q, namespaces essentially function as dictionaries. This feature allows us to create diverse behaviors without resorting to complex and confusing ",(0,i.jsx)(n.code,{children:"if-else"})," statements. You can read more about namespaces ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/12_Workspace_Organization/#121-namespaces",children:"here"}),". Let's have a look at a simple example:"]}),"\n",(0,i.jsxs)(n.p,{children:["First we create the ",(0,i.jsx)(n.code,{children:".upd"})," namespace and define functions for (a table) trade and order"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q).upd.trade:{[x] `trade set x}\nq).upd.order:{[x] `order set x}\n// We can inspect the .upd namespace\nq).upd\n     | ::\ntrade| {[x] `trade set x}\norder| {[x] `order set x}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Since a namespace operates like a dictionary, we can leverage indexing to access the appropriate function for various tables. By providing the table name as the first parameter, we effectively index into our namespace, triggering the function and utilizing the second parameter as its input."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q).upd[`trade;([] time:enlist .z.p; sym:`AAP; side:`buy; price:10; qty: 100)]\n`trade\nq)trade\ntime                          sym side price qty\n------------------------------------------------\n2024.05.15D07:40:13.902355000 AAP buy  10    100\nq).upd[`order;([] time:enlist .z.p; sym:`AAP; side:`buy; qty: 100)]\n`order\nq)order\ntime                          sym side qty\n------------------------------------------\n2024.05.15D07:40:31.927281000 AAP buy  100\n"})}),"\n",(0,i.jsx)(n.h2,{id:"gotchas",children:"Gotchas"}),"\n",(0,i.jsx)(n.p,{children:"While an in-depth discussion of API design best practices exceeds the scope of this blog post, I'd like to offer two crucial suggestions for creating your APIs. Firstly, simplicity is key. An API should focus on accomplishing one single task, and one single task only. You should avoid the temptation to create a \"solve every problem in the world API\". Secondly, if your API extends beyond 10 lines of code (and indeed, in KDB/Q, 10 lines is quite substantial), consider refactoring and breaking it into smaller, more manageable functions. Additionally, it's advisable to avoid reliance on global variables within your functions. From my experience, this often leads to bugs or, worse, production outages. Instead, if a function requires a variable, pass it as a parameter. Depending on a globally defined variable not only introduces the risk of it being undefined but also renders your API less versatile, as it cannot be reused without redefining the global variable in another process."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"That's all folks. Happy Coding"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(96540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);