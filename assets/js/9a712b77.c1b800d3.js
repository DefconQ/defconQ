"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7963],{76538:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=t(74848),r=t(28453);const s={sidebar_position:10},a="Iterators: Navigating Vectors Without the Need for Loops",o={id:"concepts/iterators",title:"Iterators: Navigating Vectors Without the Need for Loops",description:'In this blog post, we cover one of the most advanced and challenging concepts in the KDB/Q programming language: Iterators (formerly known as Adverbs). In grammar, an adverb is described as "a word that modifies or describes a verb, an adjective, another adverb, or even a whole sentence" [1]. Similarly, in KDB/Q, adverbs - or as they\u2019re now called, iterators - or as they\u2019re now called, iterators - are higher-order functions that modify how other functions are applied to lists. As someone passionate about finance, I like to think of them as derivatives, as they derive new functionality from the underlying function.',source:"@site/docs/concepts/iterators.mdx",sourceDirName:"concepts",slug:"/concepts/iterators",permalink:"/docs/concepts/iterators",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Joins: Connecting the Dots for Data Clarity",permalink:"/docs/concepts/joins"},next:{title:"Fundamentals of Interprocess Communication (IPC)",permalink:"/docs/concepts/ipc"}},l={},c=[{value:"Why we use Iterators",id:"why-we-use-iterators",level:2},{value:"Implicit Iteration",id:"implicit-iteration",level:2},{value:"Maps",id:"maps",level:2},{value:"Each",id:"each",level:3},{value:"Syntax",id:"syntax",level:4},{value:"Unary application of <code>each</code>",id:"unary-application-of-each",level:4},{value:"Binary opplication of <code>each</code>",id:"binary-opplication-of-each",level:4},{value:"Varadic application of <code>each</code>",id:"varadic-application-of-each",level:4},{value:"Each-left <code>\\:</code>",id:"each-left-",level:3},{value:"Syntax",id:"syntax-1",level:4},{value:"Each-Right <code>/:</code>",id:"each-right-",level:3},{value:"Syntax",id:"syntax-2",level:4},{value:"Each Parallel",id:"each-parallel",level:3},{value:"Syntax",id:"syntax-3",level:4},{value:"Each Prior",id:"each-prior",level:3},{value:"Syntax",id:"syntax-4",level:4},{value:"Case",id:"case",level:3},{value:"Syntax",id:"syntax-5",level:4},{value:"Accumulators",id:"accumulators",level:2},{value:"Scan <code>\\</code> and Over <code>/</code>",id:"scan--and-over-",level:3},{value:"Unary functions",id:"unary-functions",level:4},{value:"Converge",id:"converge",level:5},{value:"Do",id:"do",level:5},{value:"While",id:"while",level:5},{value:"Binary functions",id:"binary-functions",level:4},{value:"Binary application",id:"binary-application",level:5},{value:"Unary application",id:"unary-application",level:5},{value:"The keywords <code>scan</code> and <code>over</code>",id:"the-keywords-scan-and-over",level:5},{value:"Ternary functions",id:"ternary-functions",level:4},{value:"Combining Iterators",id:"combining-iterators",level:2},{value:"Tips and Tricks",id:"tips-and-tricks",level:2},{value:"How to know which iterator is used",id:"how-to-know-which-iterator-is-used",level:3},{value:"How to understand what&#39;s happening",id:"how-to-understand-whats-happening",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"iterators-navigating-vectors-without-the-need-for-loops",children:"Iterators: Navigating Vectors Without the Need for Loops"}),"\n",(0,i.jsxs)(n.p,{children:["In this blog post, we cover one of the most advanced and challenging concepts in the KDB/Q programming language: ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Iterators"})})," (formerly known as ",(0,i.jsx)(n.strong,{children:"Adverbs"}),"). In grammar, an adverb is described as ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:'"a word that modifies or describes a verb, an adjective, another adverb, or even a whole sentence"'})})," [1]. Similarly, in KDB/Q, adverbs - or as they\u2019re now called, iterators - or as they\u2019re now called, iterators - are higher-order functions that modify how other functions are applied to lists. As someone passionate about finance, I like to think of them as derivatives, as they derive new functionality from the underlying function."]}),"\n",(0,i.jsxs)(n.p,{children:['In 2018, the terminology in KDB/Q evolved, and from January 2019, the term "Iterators" officially replaced "Adverbs." If you\u2019re looking to master Iterators in KDB/Q, there\u2019s no better resource than the white paper on the topic by ',(0,i.jsx)(n.a,{href:"https://www.linkedin.com/in/conor-slattery-37b32b32/",children:"Conor Slattery"})," and ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/in/stephen-taylor-b5ba78/",children:"Stephen Taylor"}),", which you can find ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/wp/iterators/",children:"here"}),". I highly recommend reading it thoroughly. That said, I will also share my own thought processes and insights to help you understand the power of Iterators in KDB/Q more effectively."]}),"\n",(0,i.jsx)(n.p,{children:"Iterators can be broadly categorized into two main categories: Maps and Accumulators. In the following sections, we will explore each category and its corresponding iterators in detail, explaining their functionality and providing illustrative examples."}),"\n",(0,i.jsx)(n.h2,{id:"why-we-use-iterators",children:"Why we use Iterators"}),"\n",(0,i.jsxs)(n.p,{children:["Before diving into the powerful concept of Iterators and their applications, let\u2019s take a moment to understand why they are such a game-changing tool and why we should use them. If you\u2019ve worked with traditional object-oriented programming languages, you\u2019re probably familiar with one of the most common beginner mistakes: the infamous ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html",children:"IndexOutOfBoundsException"})})}),". This error happens when you try to access an element in a list or array using an index that doesn\u2019t exist - often caused by an error in loop logic."]}),"\n",(0,i.jsx)(n.p,{children:"In KDB/Q, this issue simply doesn\u2019t happen. Iterators not only eliminate the need to manually track indexes, but they\u2019re also significantly faster than traditional loops. Imagine how tedious and time-consuming it would be to write loops - or worse, nested loops - every time you needed to iterate over a list or a list of lists. With Iterators, these challenges disappear, allowing you to focus on the logic rather than wrestling with boilerplate code. It\u2019s efficient, clean, and a joy to work with."}),"\n",(0,i.jsx)(n.p,{children:"Don\u2019t believe me? Let\u2019s take a look at a simple example. Let\u2019s say we have a list of strings representing fruits we eat, and we want to prepend each fruit\u2019s name with a sentence. It\u2019s a simple, beginner-level exercise. In Python, achieving this requires several lines of code - even though there might be shorter or more efficient methods (I\u2019ll admit, I\u2019m not a Python developer)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Python code:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'fruits = ["apple", "banana", "cherry"]\nfor i in range(len(fruits)):\n  print("The fruit I ate was a",fruits[i])\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Output:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"The fruit I ate was a apple\nThe fruit I ate was a banana\nThe fruit I ate was a cherry\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, in KDB/Q, this task is effortlessly handled with Iterators. It\u2019s built into the language, allowing you to accomplish it with unmatched simplicity. This demonstrates the paradigm shift that KDB/Q brings to the table - a change in the way you think and approach programming problems. To borrow a quote from ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Alan_Perlis",children:"Alan Perlis"}),":"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:'"A language that doesn\'t affect the way you think about programming is not worth knowing."'})})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Above example in KDB/Q [using the each-right iterator]"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)"The fruit I ate was a ",/:("apple";"banana";"cherry")\n"The fruit I ate was a apple"\n"The fruit I ate was a banana"\n"The fruit I ate was a cherry"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implicit-iteration",children:"Implicit Iteration"}),"\n",(0,i.jsxs)(n.p,{children:["If you thought that was impressive, hold on tight - there\u2019s even more. As a vector-oriented programming language, KDB/Q introduces the concept of implicit iteration. While a full explanation of this concept goes beyond the scope of this blog post, I highly recommend checking out Stephen Taylor's excellent ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/implicit-iteration/",children:"write-up"})," for an in-depth understanding. For now, let\u2019s take a brief look at what implicit iteration entails:"]}),"\n",(0,i.jsx)(n.p,{children:"The simplest form of implicit iteration occurs when working with two lists of the same length and applying an operation to them - such as adding them together. In most traditional programming languages, you would need to write a loop to iterate through the elements of both lists and add the numbers pairwise. In KDB/Q, however, this implicit map iteration is built in and works seamlessly right out of the box."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)10 20 30+1 2 3\n11 22 33\n"})}),"\n",(0,i.jsx)(n.p,{children:"But that's not all - implicit iteration in KDB/Q also extends to lists of lists. While most traditional programming languages would require you to write nested loops to handle such cases, KDB/Q eliminates that need entirely. As long as each element (or sublist) matches the shape of the corresponding element in the second list, KDB/Q can seamlessly perform implicit iteration and apply the operator appropriately."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(1 2 3;4 5;6 7 8 9)+(10 11 12;50 60;20 30 40 50)\n11 13 15\n54 65\n26 37 48 59\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, if even a single sublist from either list does not match the shape of the corresponding sublist in the second list, the operation will fail, resulting in a length error."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Note: We removed the atom 50 from the third sublist of our second list\nq)(1 2 3;4 5;6 7 8 9)+(10 11 12;50 60;20 30 40)\n'length\n  [0]  (1 2 3;4 5;6 7 8 9)+(10 11 12;50 60;20 30 40)\n"})}),"\n",(0,i.jsx)(n.p,{children:"The only exception occurs when one of the elements is an atom. In this case, scalar extension is applied, and the atom is automatically extended to match the shape of the corresponding element in the second list."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Scalar extension applies \nq)(1 2 3;4 5;6 7 8 9)+(10 11 12;50 60;50)\n11 13 15\n54 65\n56 57 58 59\n"})}),"\n",(0,i.jsxs)(n.p,{children:["All of this is achieved without writing a single loop - amazing, ins't it? Implicit iteration is a powerful concept that not only makes KDB/Q incredibly fast but also remarkably elegant. For a deeper dive into implicit iteration, be sure to explore Stephen Taylor's detailed post ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/implicit-iteration/",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"maps",children:(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/maps/",children:"Maps"})}),"\n",(0,i.jsxs)(n.p,{children:["To ease into the topic, we\u2019ll begin with the simpler of the two categories: ",(0,i.jsx)(n.strong,{children:"Maps"}),". There are six different Map iterators, summarized in the following table"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Keyword"}),(0,i.jsx)(n.th,{children:"Operator"}),(0,i.jsx)(n.th,{children:"Usage"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Each"}),(0,i.jsx)(n.td,{children:"each"}),(0,i.jsx)(n.td,{children:"'"}),(0,i.jsx)(n.td,{children:"v'"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Each Left"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\\:"}),(0,i.jsx)(n.td,{children:"v2\\:"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Each Right"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"/:"}),(0,i.jsx)(n.td,{children:"v2/:"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Each Parallel"}),(0,i.jsx)(n.td,{children:"peach"}),(0,i.jsx)(n.td,{children:"':"}),(0,i.jsx)(n.td,{children:"v1':"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Each Prior"}),(0,i.jsx)(n.td,{children:"prior"}),(0,i.jsx)(n.td,{children:"':"}),(0,i.jsx)(n.td,{children:"v2':"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Case"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"'"}),(0,i.jsx)(n.td,{children:"i'"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"where"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" v1: value (rank 1)\n v2: value (rank 2)\n v : value (rank 1-8)\n i : vector of ints\u22650\n"})}),"\n",(0,i.jsx)(n.h3,{id:"each",children:"Each"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"each"})," iterator, as the name suggests, allows you to apply a function to each element of a list. This is particularly useful when you want to iterate over a list and perform operations on its individual elements. However, it's important to note that KDB/Q's built-in operators already support implicit scalar iteration, so this functionality is provided natively. As a result, ",(0,i.jsx)(n.code,{children:"each"})," is most commonly used with custom-defined functions."]}),"\n",(0,i.jsx)(n.h4,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(v1') x\t\tv1'[x]\t\tv1 each x\nv1@'x\nx v2 y\t\tv2'[x;y]\n\t\tv3'[x;y;z]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The each iterator applies a function item-wise to a dictionary, list, or corresponding items of conforming lists and dictionaries. For example, when ",(0,i.jsx)(n.code,{children:"v"})," is a function, ",(0,i.jsx)(n.code,{children:"v'"})," applies ",(0,i.jsx)(n.code,{children:"v"})," to each item of a list or dictionary, or to matching items from conforming lists. The resulting derived function retains the same rank as ",(0,i.jsx)(n.code,{children:"v"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This sounds more complicated than it actually is, so let's explorer some practical examples. Let\u2019s start by defining a function ",(0,i.jsx)(n.code,{children:"f"})," that takes a single argument and returns its square. We can then use the ",(0,i.jsx)(n.code,{children:"each"})," iterator to apply this function to every element of a list, returning the square of each element."]}),"\n",(0,i.jsxs)(n.h4,{id:"unary-application-of-each",children:["Unary application of ",(0,i.jsx)(n.code,{children:"each"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)f:{x*x}\nq)show list:1+til 10\n1 2 3 4 5 6 7 8 9 10\nq)f each list\n1 4 9 16 25 36 49 64 81 100\n// alternative syntax using apply @\nq)f@'list\n1 4 9 16 25 36 49 64 81 100\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Keep in mind that due to implicit scalar iteration, we don\u2019t actually need to use the ",(0,i.jsx)(n.code,{children:"each"})," iterator to achieve this. Instead, we can simply multiply the two lists directly."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)1 2 3 4 5 6 7 8 9 10 * 1 2 3 4 5 6 7 8 9 10\n1 4 9 16 25 36 49 64 81 100\nq)list*list\n1 4 9 16 25 36 49 64 81 100\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, let\u2019s explore a scenario where the we truly need the ",(0,i.jsx)(n.code,{children:"each"})," iterator. Imagine we have a list of lists, and we want to determine the length of each sublist. Simply applying the ",(0,i.jsx)(n.code,{children:"count"})," function to the entire list won\u2019t work, as it will only return the count of elements at the top level (depth 1). However, by combining the ",(0,i.jsx)(n.code,{children:"count"})," operator with the ",(0,i.jsx)(n.code,{children:"each"})," iterator, we can efficiently calculate the length of each individual sublist at depth 2."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)count (1 2 3;"Hello World";2025.01.01 2025.01.02; (`AAPL`GOOG;`MSFT))\n4\nq)count each (1 2 3;"Hello World";2025.01.01 2025.01.02; (`AAPL`GOOG;`MSFT))\n3 11 2 2\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If you\u2019ve read some of my previous blog posts or aren\u2019t entirely new to KDB/Q, you\u2019ll know that many operators in KDB/Q have multiple overloads or different syntax depending on the function\u2019s arity. The same applies to iterators. Let\u2019s explore the various ways ",(0,i.jsx)(n.code,{children:"each"})," can be used."]}),"\n",(0,i.jsxs)(n.p,{children:["As we've already seen, the task above can be accomplished using the code snippet ",(0,i.jsx)(n.code,{children:"f each list"}),". Additionally, you can use the following syntax to apply a unary function - a function that takes only one argument - to each element of a list:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Original solution\nq)f each list\n1 4 9 16 25 36 49 64 81 100\n// More concise and terse solutions\nq)f@'list\n1 4 9 16 25 36 49 64 81 100\nq)(f')list\n1 4 9 16 25 36 49 64 81 100\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Although there is no significant performance difference between the syntaxes, I strongly recommend using the first syntax, ",(0,i.jsx)(n.code,{children:"f each list"}),", for better readability. While this example is quite simple and easy to understand, in a larger codebase with more complex logic, the first approach is much clearer and more readable."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)\\ts:1000000 f each list\n726 768\nq)\\ts:1000000 f@'list\n781 720\nq)\\ts:1000000 (f')list\n726 688\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"binary-opplication-of-each",children:["Binary opplication of ",(0,i.jsx)(n.code,{children:"each"})]}),"\n",(0,i.jsxs)(n.p,{children:["The binary application of ",(0,i.jsx)(n.code,{children:"each"})," (often called each-both) is used with binary functions, which take two arguments. This usage requires careful attention, as the lengths of the two arguments are crucial. Both lists must have the same length; otherwise, a length error will occur. The only exception is when one of the arguments is an atom instead of a list. In this case, scalar extension will automatically convert the atom into a list of the same length as the other list, as we\u2019ve previously learned. Let\u2019s see how this works in practice."]}),"\n",(0,i.jsxs)(n.p,{children:["Imagine we have two lists of strings (recall that a string in KDB/Q is essentially a list of characters), and we want to concatenate their individual elements pairwise. If we use the concatenate operator ",(0,i.jsx)(n.code,{children:","})," alone, it will simply merge the two strings into one. However, by combining the concatenate operator with the each iterator ",(0,i.jsx)(n.code,{children:",'"})," , we can achieve the desired pairwise concatenation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)"ABCDE" ,\' "12345"\n"A1"\n"B2"\n"C3"\n"D4"\n"E5"\nq),\'["ABCDE";"12345"]\n"A1"\n"B2"\n"C3"\n"D4"\n"E5"\nq)(,\')["ABCDE";"12345"]\n"A1"\n"B2"\n"C3"\n"D4"\n"E5"\n'})}),"\n",(0,i.jsx)(n.p,{children:"As noted earlier, if the two lists have differing lengths, a length error will be thrown."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)"ABCDE" ,\' "1234"\n\'length\n  [0]  "ABCDE" ,\' "1234"\n                ^\n'})}),"\n",(0,i.jsx)(n.p,{children:"Unless one of the lists is a single atom."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)"ABCDE" ,\' "1"\n"A1"\n"B1"\n"C1"\n"D1"\n"E1"\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"varadic-application-of-each",children:["Varadic application of ",(0,i.jsx)(n.code,{children:"each"})]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, let\u2019s explore the variadic application of the ",(0,i.jsx)(n.code,{children:"each"})," iterator. As with previous cases, the lengths of the arguments you provide will determine whether the operation succeeds or results in a length error."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// Remember: A string is a char vector\nq){x,y,z}\'["ABC";"XYZ";"123"]\n"AX1"\n"BY2"\n"CZ3"\nq)f:{x+y*z}\nq)f\'[1 2 3;4 5 6;11 12 13]\n45 62 81\n// If any of the lists isn\'t the same length as the others, a length error is thrown\nq){x,y,z}\'["ABC";"XYZ";"12"]\n\'length\n  [0]  {x,y,z}\'["ABC";"XYZ";"12"]\n              ^\n// However, if any list is a single atom, scalar extension kicks in\n// Two lists and an atom\nq){x,y,z}\'["ABC";"XYZ";"1"]\n"AX1"\n"BY1"\n"CZ1"\n// One list and two atoms\nq){x,y,z}\'["ABC";"X";"1"]\n"AX1"\n"BX1"\n"CX1"\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"each-left-",children:["Each-left ",(0,i.jsx)(n.code,{children:"\\:"})]}),"\n",(0,i.jsxs)(n.p,{children:["The each-left ",(0,i.jsx)(n.code,{children:"\\:"})," iterator takes a binary function and derives a new binary function that applies the entire ",(0,i.jsx)(n.strong,{children:"right"})," argument to each ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"individual"})})," element of the ",(0,i.jsx)(n.strong,{children:"left"})," argument - hence the name ",(0,i.jsx)(n.strong,{children:'"each-left."'})," Qbies often find it challenging to remember whether they\u2019re dealing with each-left or each-right. Here's a simple trick to ensure you'll never forget: pay attention to the direction of the slash. If it\u2019s a backslash ",(0,i.jsx)(n.code,{children:"\\"}),", leaning to the left, you\u2019re using the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"each-left"})})," iterator, meaning the entire list on the right is applied to each element on the left. Conversely, if it\u2019s a forward slash ",(0,i.jsx)(n.code,{children:"/"}),", leaning to the right, you\u2019re using the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"each-rigth"})})," iterator, which applies the entire left argument to each individual element on the right."]}),"\n",(0,i.jsx)(n.h4,{id:"syntax-1",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Each Left     x v2\\: y    v2\\:[x;y]   equivalent to --\x3e   v2[;y] each x\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's have a look at a simple example to demonstrate how each-left works."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)("Alexander";"Christoph";"Stephan"),\\:" lives in London"\n"Alexander lives in London"\n"Christoph lives in London"\n"Stephan lives in London"\nq)"ABC",\\:"XY"\n"AXY"\n"BXY"\n"CXY"\n// Alternative syntax\nq),\\:["ABC";"XY"]\n"AXY"\n"BXY"\n"CXY"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Using the ",(0,i.jsx)(n.strong,{children:"each-left"})," iterator with a binary function is functionally equivalent to applying a binary function where the ",(0,i.jsx)(n.strong,{children:"second"})," argument ",(0,i.jsx)(n.code,{children:"y"})," is fixed, and the function iterates over each element of the first argument ",(0,i.jsx)(n.code,{children:"x"}),", as demonstrated below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q),\\:["ABC";"XY"]\n"AXY"\n"BXY"\n"CXY"\n// Fixing the y parameter and using each obtains the same result as using each-left\nq),[;"XY"] each "ABC"\n"AXY"\n"BXY"\n"CXY"\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"each-right-",children:["Each-Right ",(0,i.jsx)(n.code,{children:"/:"})]}),"\n",(0,i.jsxs)(n.p,{children:["The each-righht ",(0,i.jsx)(n.code,{children:"/:"})," iterator is kind of the counter part to the each-left iterator. The each-right iterator takes a binary function and derives a new binary function that applies the entire ",(0,i.jsx)(n.strong,{children:"left"})," argument to each ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"individual"})})," element of the ",(0,i.jsx)(n.strong,{children:"right"})," argument - hence the name ",(0,i.jsx)(n.strong,{children:"each-right"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"syntax-2",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Each Right    x v2/: y    v2/:[x;y]   equivalent to --\x3e   v2[x;] each y\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you've understood the concept of each-left, understanding the workings of each-right should be relatively straightforward. However, for the sake of completeness, let's explore a few illustrative examples."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)"My name is ",/:("Alexander";"Christoph";"Stephan")\n"My name is Alexander"\n"My name is Christoph"\n"My name is Stephan"\nq)"ABC",/:"XY"\n"ABCX"\n"ABCY"\n// Alternative syntax\nq),/:["ABC";"XY"]\n"ABCX"\n"ABCY"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Using the ",(0,i.jsx)(n.strong,{children:"each-right"})," iterator with a binary function is functionally equivalent to applying a binary function where the ",(0,i.jsx)(n.strong,{children:"first"})," argument ",(0,i.jsx)(n.code,{children:"x"})," is fixed, and the function iterates over each element of the second argument ",(0,i.jsx)(n.code,{children:"y"}),", as demonstrated below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q),/:["ABC";"XY"]\n"ABCX"\n"ABCY"\nq),["ABC";] each "XY"\n"ABCX"\n"ABCY"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"each-parallel",children:"Each Parallel"}),"\n",(0,i.jsxs)(n.p,{children:["The iterator ",(0,i.jsx)(n.strong,{children:"each-parallel"})," ",(0,i.jsx)(n.code,{children:"':"})," - or its corresponding keyword ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"peach"})})," - enables parallel execution by delegating processing to secondary tasks. This is particularly useful for computationally intensive functions or scenarios requiring simultaneous access to multiple drives from a single CPU."]}),"\n",(0,i.jsxs)(n.p,{children:["To enable parallel execution, start KDB/Q with multiple secondary processes using the ",(0,i.jsx)(n.code,{children:"-s"})," option in the command line. The ",(0,i.jsx)(n.strong,{children:"each-parallel"})," iterator gains a performance improvement by dividing the argument list of the derived function among the available secondary processes for evaluation. The result of applying ",(0,i.jsx)(n.strong,{children:"each-parallel"})," to a unary function will always match the result of applying ",(0,i.jsx)(n.strong,{children:"each"})," to the same function, meaning ",(0,i.jsx)(n.code,{children:"m':[x]"})," will always be identical to ",(0,i.jsx)(n.code,{children:"m'[x]"}),". However, ",(0,i.jsx)(n.strong,{children:"each-parallel"})," offers a performance advantage over ",(0,i.jsx)(n.strong,{children:"each"})," when secondary tasks are available. If no secondary tasks are available, the performance will remain the same as that of ",(0,i.jsx)(n.strong,{children:"each"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"syntax-3",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(v1':)x   v1':[x]   v1 peach x\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's illustrate the performance advantage of peach:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// First, we start KDB/Q with secondary threads, in this case 4\nKDB+ 4.0 2023.01.20 Copyright (C) 1993-2023 Kx Systems\nm64/ 8(24)core 24576MB alexanderunterrainer mac EXPIRE 2025.02.21 KDB PLUS TRIAL #5018719\n// You can verify the number of available threads using the \\s command\nq)\\s\n4i\n// Generate a vector with one million numbers and square each element using the peach iterator\nq)r_peach:{x*x} peach til 1000000\n// Generate a vector with one million numbers and square each element using the each iterator\nq)r_each:{x*x} each til 1000000\n// Verify that the result matches\nq)r_peach~r_each\n1b\n// time the same operation using 100 million numbers\nq)\\ts {x*x} peach til 100000000\n5692 4294967888\nq)\\ts {x*x} each til 100000000\n7188 4821226064\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["To start a KDB/Q process with secondary threads, use the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/cmdline/#-s-secondary-threads",children:(0,i.jsx)(n.code,{children:"-s n"})})," command line option. You can check the number of available secondary threads within a KDB/Q process by running the ",(0,i.jsx)(n.code,{children:"\\s"})," command."]})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see from the above results, using ",(0,i.jsx)(n.code,{children:"peach"})," to compute the square of one hundred million numbers results in approximately 30% faster execution time compared to using the ",(0,i.jsx)(n.code,{children:"each"})," iterator. Moreover, ",(0,i.jsx)(n.code,{children:"peach"})," consumes around 13% less memory than ",(0,i.jsx)(n.code,{children:"each"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["While incorporating ",(0,i.jsx)(n.code,{children:"peach"})," into your code can offer clear performance benefits over the standard ",(0,i.jsx)(n.code,{children:"each"})," iterator, it does come with certain limitations. For example, only the main thread can update global variables. As a result, you need to carefully assess whether ",(0,i.jsx)(n.code,{children:"peach"})," and parallel processing are the right fit for your application."]}),"\n",(0,i.jsx)(n.h3,{id:"each-prior",children:"Each Prior"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"each-prior"})," ",(0,i.jsx)(n.code,{children:"':"})," iterator - or its coresponding keyword ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"prior"})})," - applies a binary function between each element of a list and its preceding element. More precisely, ",(0,i.jsx)(n.strong,{children:"each-prior"})," takes a binary function and derives a variadic function that evaluates the function between each item in a list or dictionary and the item that precedes it."]}),"\n",(0,i.jsx)(n.h4,{id:"syntax-4",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(v2':)x    v2':[x]      (v2)prior x\nx v2':y    v2':[x;y]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This might sound more complex than it actually is, so let\u2019s explore an example to help clarify how ",(0,i.jsx)(n.strong,{children:"each-prior"})," works:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(-':)100 99 101 105 100 120\n100 -1 2 4 -5 20\n"})}),"\n",(0,i.jsx)(n.p,{children:"Looking at the result of the above computation, you'll notice that the first element of the result vector stands out. This is because the initial item in the list has no predecessor, so KDB/Q implicitly selects the identity value for the binary function (if one exists)."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The identity value for addition ",(0,i.jsx)(n.code,{children:"+"})," and subtraction ",(0,i.jsx)(n.code,{children:"-"})," is 0, whereas for multiplication ",(0,i.jsx)(n.code,{children:"*"})," and division ",(0,i.jsx)(n.code,{children:"%"})," it is 1."]})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively, we can specify the initial value to be used as the predecessor by applying it as the left operand of the modified operator. A common choice is to use the first item of the source list. For instance, this approach can be used to calculate the deltas of a list of prices."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)100 -': 100 99 101 105 100 120\n0 -1 2 4 -5 20\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you're curious about practical applications of the ",(0,i.jsx)(n.strong,{children:"each-prior"})," iterator, you might be surprised to learn that it is more commonly used than you might expect. In fact, ",(0,i.jsx)(n.strong,{children:"each-prior"})," serves as the foundation for the underlying implementation of keywords like ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"deltas, ratios and differ"})})}),". Let me take you behind the scenes to show how it works."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)deltas\n-':\nq)ratios\n%':\nq)differ\n$[\"b\"]~~':\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using ",(0,i.jsx)(n.code,{children:"deltas"})," without explicitly providing an initial value as the predecessor for the first element of the list, we observe the same behavior we encountered earlier - he first element of the result may not align with our expectations. However, by understanding how to explicitly supply an initial value and slightly modifying the underlying definition of the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"deltas"})})," keyword, we can create our own customized delta function. Let\u2019s do that!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q){first[x]-':x} 100 99 101 105 100 120\n0 -1 2 4 -5 20\nq)mydeltas:{first[x]-':x}\nq)mydeltas 100 99 101 105 100 120\n0 -1 2 4 -5 20\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use the ",(0,i.jsx)(n.code,{children:"prior"})," keyword to improve readability."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)prior\nk){x':y}\nq)(-) prior 100 99 101 105 100 120\n100 -1 2 4 -5 20\n"})}),"\n",(0,i.jsx)(n.h3,{id:"case",children:"Case"}),"\n",(0,i.jsxs)(n.p,{children:["The final map iterator we\u2019ll explore is the ",(0,i.jsx)(n.strong,{children:"case"})," iterator. To be completely honest, I\u2019ve never actually used it in practice - o if you ever come across a real-world use case (pun intended), feel free to share it with me!\nNow, back to iterators: The ",(0,i.jsx)(n.strong,{children:"case"})," iterator selects successive items from multiple list arguments, with the left argument of the iterator determining which argument each item is picked from."]}),"\n",(0,i.jsx)(n.h4,{id:"syntax-5",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"int'[a;b;c;\u2026]\n"})}),"\n",(0,i.jsx)(n.p,{children:"where"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"int"})," is an integer vector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[a;b;c;\u2026]"})," are the arguments to the derived function"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Case Syntax",src:t(94407).A+"",width:"630",height:"440"})}),"\n",(0,i.jsxs)(n.p,{children:["The best way to understand the ",(0,i.jsx)(n.strong,{children:"case"})," iterator is through an example. Imagine you have a list of different languages - German, Italian, French, and English - and you want to print the numbers one to six, switching languages in a specific order: German, German, Italian, French, Italian, and English. The ",(0,i.jsx)(n.strong,{children:"case"})," iterator makes this task effortless. Let\u2019s see it in action."]}),"\n",(0,i.jsx)(n.p,{children:"We first define a list of avaialble languages, and store them in a variable"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)language:`Italian`German`French`English\n"})}),"\n",(0,i.jsx)(n.p,{children:"Next, we have to define the numbers from one to six in each language:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)e:`one`two`three`four`five`six\nq)g:`eins`zwei`drei`vier`funf`sechs\nq)f:`un`deux`trois`quatre`cinq`sees\nq)i:`uno`due`tre`quattro`cinque`sei\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can use the ",(0,i.jsx)(n.strong,{children:"find"})," operator ",(0,i.jsx)(n.code,{children:"?"})," to generate a vector of indices that map to the desired sequence of languages for displaying the numbers. This approach is similar to creating an enumeration (which we will explore in a separate blog post). Let me illustrate the concept."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)language?`German`German`Italian`French`Italian`English\n1 1 0 2 0 3\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finally, we can use this index vector in combination with the case iterator to cycle through the different languages and select the correct word for each number. Since we aim to display six numbers, our index vector has a length of six. Starting with the first index (0), the value at this position is 1, meaning we will take the word at index 0 from the language list located at index 1. Mind-bending, right? As always, the best way to understand this concept is through an example. After all, a single line of KDB/Q code speaks louder than a million words!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(language?`German`German`Italian`French`Italian`English)'[i;g;f;e]\n`eins`zwei`tre`quatre`cinque`six\nq)1 1 0 2 0 3'[i;g;f;e]\n`eins`zwei`tre`quatre`cinque`six\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's break it down even further and walk through it step by step:"}),"\n",(0,i.jsxs)(n.p,{children:["First, note that our argument list is ",(0,i.jsx)(n.code,{children:"[i;g;f;e]"}),", representing the list of numbers in different languages: Italian, German, French, and English. The key detail here is the index positions: Italian is at index ",(0,i.jsx)(n.code,{children:"0"}),", German at index ",(0,i.jsx)(n.code,{children:"1"}),", French at index ",(0,i.jsx)(n.code,{children:"2"}),", and English at index ",(0,i.jsx)(n.code,{children:"3"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Now, we map the index of each language to the desired order in which we want the words to appear\u2014German, German, Italian, French, Italian, and English\u2014resulting in the following vector:",(0,i.jsx)(n.code,{children:"1 1 0 2 0 3"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The final output, ",(0,i.jsx)(n.code,{children:"eins, zwei, tre, quatre, cinque, six"})," is derived as follows:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"eins"}),": We first index into our language list at position ",(0,i.jsx)(n.code,{children:"1"})," (German vector), then index into it at position ",(0,i.jsx)(n.code,{children:"0"}),", returning ",(0,i.jsx)(n.code,{children:"eins"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"zwei"}),": Again, we access index ",(0,i.jsx)(n.code,{children:"1"})," (German vector) and this time retrieve index ",(0,i.jsx)(n.code,{children:"1"}),", yielding ",(0,i.jsx)(n.code,{children:"zwei"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"tre"}),": Moving to index ",(0,i.jsx)(n.code,{children:"0"})," (Italian vector), we select index ",(0,i.jsx)(n.code,{children:"2"}),", which gives ",(0,i.jsx)(n.code,{children:"tre"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"quatre"}),": Next, at index ",(0,i.jsx)(n.code,{children:"2"})," (French vector), we fetch index ",(0,i.jsx)(n.code,{children:"3"}),", producing ",(0,i.jsx)(n.code,{children:"quatre"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"cinque"}),": Returning to index ",(0,i.jsx)(n.code,{children:"0"})," (Italian vector), we retrieve index ",(0,i.jsx)(n.code,{children:"4"}),", yielding ",(0,i.jsx)(n.code,{children:"cinque"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"six"}),": Finally, at index ",(0,i.jsx)(n.code,{children:"3"})," (English vector), we select index ",(0,i.jsx)(n.code,{children:"5"}),", resulting in ",(0,i.jsx)(n.code,{children:"six"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By following this pattern, we traverse the entire index vector and achieve the intended sequence of translated numbers."}),"\n",(0,i.jsxs)(n.p,{children:["With this, we wrap up the Map Iterators and can now move on to the Accumulator Iterators: ",(0,i.jsx)(n.strong,{children:"Scan"})," ",(0,i.jsx)(n.code,{children:"\\"})," and ",(0,i.jsx)(n.strong,{children:"Over"})," ",(0,i.jsx)(n.code,{children:"/"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"accumulators",children:"Accumulators"}),"\n",(0,i.jsx)(n.p,{children:"Every KDB/Q developer knows that mastering Iterator - especially Scan and Over - sets apart an experienced developer from a Qbie (beginner). While similar concepts exist in other programming languages, such as Map and Fold, the syntax of Scan and Over is quite unique and can take time to fully internalize. Moreover, the various overloads of these Iterators, depending on the arity of the function they are applied to, add another layer of complexity to understanding these powerful tools."}),"\n",(0,i.jsx)(n.p,{children:"In this section, my goal is to help you understand Scan and Over more intuitively. Let's begin with an overview of their syntax and various overloads."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Syntax 1"}),(0,i.jsx)(n.th,{children:"Syntax 2"}),(0,i.jsx)(n.th,{children:"Syntax 3"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Converge"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(v1\\)x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1\\[x]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1 scan x"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(v1/)x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1/[x]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1 over x"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Do"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"n v1\\x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1\\[n;x]"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"n v1/x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1/[n;x]"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"While"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"t v1\\x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1\\[t;x]"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"t v1/x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v1/[t;x]"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Scan"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(v2\\)x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v2\\[x]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(v2)scan x"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Over"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(v2/)x"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v2/[x]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(v2)over x"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Scan"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x v2\\y"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v2\\[x;y]"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Over"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x v2/y"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v2/[x;y]"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Scan"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v3\\[x;y;z]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x y\\z"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Over"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"v3/[x;y;z]"})}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"where"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"v1,v2,v3"})," \tare applicable values of rank 1 to 3, respectively"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"n"}),"\t\tis an interger greater or equal to 0 ",(0,i.jsx)(n.code,{children:"(\u22650)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"t"}),"\t\tis an unary truth map, basically a truth condition"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x,y"}),"\t\tare the arguments/indexes of ",(0,i.jsx)(n.code,{children:"v"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"An accumulator is an iterator that takes an applicable value as an argument and derives a function that evaluates this value - first on its entire (first) argument, then on the results of successive evaluations. The two iterators, Scan and Over, share the same syntax and perform identical computations. However, while Scan-derived functions return the result of each evaluation step, Over-derived functions return only the final result. The Scan and Over iterators are higher-order functions that serve as the primary mechanism for recursion in KDB/Q. In their simplest form, they modify a binary function to accumulate results over a list."}),"\n",(0,i.jsx)(n.p,{children:"In many ways, Over is similar to map-reduce in other programming languages."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"While Scan and Over perform the same computation, in general, Over requires less memory, because it does not store intermediate results."})}),"\n",(0,i.jsxs)(n.h3,{id:"scan--and-over-",children:["Scan ",(0,i.jsx)(n.code,{children:"\\"})," and Over ",(0,i.jsx)(n.code,{children:"/"})]}),"\n",(0,i.jsxs)(n.p,{children:["Since Scan ",(0,i.jsx)(n.code,{children:"\\"})," and Over ",(0,i.jsx)(n.code,{children:"/"})," share the same syntax and perform the same computation, with the only difference that Scan returns all intermediate accumulations while Over returns only the final result, we will explore both iterators together, providing examples for each."]}),"\n",(0,i.jsx)(n.h4,{id:"unary-functions",children:"Unary functions"}),"\n",(0,i.jsx)(n.p,{children:"The first application of Scan and Over we will explore is their combination with a unary function. Depending on the syntax and arguments used, this can result in three distinct behaviors: Converge, Do, or While. In the following sections, we will learn about each of these behaviors in detail."}),"\n",(0,i.jsx)(n.h5,{id:"converge",children:"Converge"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Scan (v1\\)x\nOver (v1/)x\t\truns until two successive evaluations match, or an evaluation matches x\n"})}),"\n",(0,i.jsx)(n.p,{children:"When applying Scan or Over to a unary function, a function that takes a single argument, the iterator recursively applies the function, starting from the base case, until the output converges or a loop is detected. Wondering how convergence is determined? At each step, the result is compared to the previous step. If the two values match within an equality tolerance (10\u207b\xb9\u2074 at the time of writing), the algorithm is considered to have converged, and recursion stops; otherwise, it continues. Let's illustrate this behavior."}),"\n",(0,i.jsx)(n.p,{children:"Assume we want to repeatedly multiply a given number by 0.1 until the result matches its predecessor within the specified equality tolerance. We can achieve this using the following code."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Convergence using Scan, printing all intermediate steps\nq){x*0.1}\\[1]\n1\n0.1\n0.01\n0.001\n0.0001\n1e-05\n1e-06\n1e-07\n1e-08\n1e-09\n1e-10\n1e-11\n1e-12\n1e-13\n1e-14\n1e-15\n1e-16\n1e-17\n1e-18\n1e-19\n1e-20\n1e-21\n..\nq)count {x*0.1}\\[1]\n309\n// Convergence using Over returns the last value before the recursion terminated\nq){x*0.1}/[1]\n0f\n// the last result of Scan matches the result of Over \nq){x*0.1}/[1]~last {x*0.1}\\[1]\n1b\n"})}),"\n",(0,i.jsx)(n.p,{children:"Since Over only returns the final result before convergence, we use Scan to visualize the intermediate steps. As seen in the example above, it took 309 iterations for the results to fall within the equality tolerance, at which point convergence was achieved, and the recursion terminated."}),"\n",(0,i.jsx)(n.p,{children:"The second condition for KDB/Q to terminate recursion is when it detects a loop, meaning the result of an evaluation matches the initial input. Without this safeguard, the process would run indefinitely. The following two examples demonstrate how loop detection works."}),"\n",(0,i.jsxs)(n.p,{children:["First, we use the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/neg/",children:(0,i.jsx)(n.code,{children:"neg"})})," operator to negate the input, producing its negative counterpart. On the second iteration, negating the result again returns the original value, detecting a loop and terminating the recursion."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(neg\\)1\n1 -1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the second example, we use the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/rotate/",children:(0,i.jsx)(n.code,{children:"rotate"})})," operator to shift a given string (a vector of characters) by one position at a time. Repeating this process eventually brings the string back to its original form, at which point the recursion halts."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)1 rotate "Hello"\n"elloH"\nq)rotate[1;"Hello"]\n"elloH"\nq)(rotate[1]\\)"Hello"\n"Hello"\n"elloH"\n"lloHe"\n"loHel"\n"oHell"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["However, despite all these built-in safeguards, it\u2019s still possible to create an infinite loop. One simple way to do so is by understanding how ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/not/",children:(0,i.jsx)(n.code,{children:"not"})})," behaves in KDB/Q. In standard Boolean logic, ",(0,i.jsx)(n.code,{children:"not"})," simply flips the input: ",(0,i.jsx)(n.code,{children:"0b"})," (false) becomes ",(0,i.jsx)(n.code,{children:"1b"})," (true) and vice versa. But in KDB/Q, ",(0,i.jsx)(n.code,{children:"not"})," returns ",(0,i.jsx)(n.code,{children:"0b"})," when the input is nonzero and ",(0,i.jsx)(n.code,{children:"1b"})," otherwise."]}),"\n",(0,i.jsxs)(n.p,{children:["This means that if we use ",(0,i.jsx)(n.code,{children:"not"})," with Scan ",(0,i.jsx)(n.code,{children:"\\"})," or Over ",(0,i.jsx)(n.code,{children:"/"}),", starting with any value other than ",(0,i.jsx)(n.code,{children:"0"})," or ",(0,i.jsx)(n.code,{children:"1"}),", we will enter an infinite loop. Applying ",(0,i.jsx)(n.code,{children:"not"})," to any nonzero number yields ",(0,i.jsx)(n.code,{children:"0b"}),", and applying ",(0,i.jsx)(n.code,{children:"not"})," to ",(0,i.jsx)(n.code,{children:"0b"})," returns ",(0,i.jsx)(n.code,{children:"1b"}),". Since ",(0,i.jsx)(n.code,{children:"0"})," will never match ",(0,i.jsx)(n.code,{children:"1"}),", convergence never occurs. Likewise, because our starting input wasn\u2019t ",(0,i.jsx)(n.code,{children:"1"}),", a loop is never detected, trapping us in an endless cycle."]}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsx)(n.p,{children:"DO NOT RUN BELOW!! You will have to kill your console session if you enter the following code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)not 0\n1b\nq)not 1b\n0b\nq)not 2\n0b\n// This will never retunr\nq)(not/) 42 \n"})}),"\n",(0,i.jsx)(n.h5,{id:"do",children:"Do"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"i v1\\x\ni v1/x\t\ti, a non-negative integer\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Using Scan ",(0,i.jsx)(n.code,{children:"\\"})," or Over ",(0,i.jsx)(n.code,{children:"/"})," with a unary function and a non-negative integer effectively mimics a ",(0,i.jsx)(n.strong,{children:"Do"})," loop, where the integer specifies the number of iterations, and the right operand serves as the initial value. Leveraging this, we can easily construct a loop that increments a starting value by 1, ten times."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Using Scan to add 1 to 10, 10 times\nq)10{x+1}\\10\n10 11 12 13 14 15 16 17 18 19 20\n// Over returns only the last result\nq)10{x+1}/10\n20\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can leverage this knowledge to create a pattern I was first introduced by Stephen Taylor. Suppose you want to write a function to identify palindromes, a word, phrase, or sequence that reads the same backwards as forwards. This can be efficiently achieved by combining the reverse operator with Scan, applying the function exactly once. Since Scan outputs the original input as the first result when used in combination with a unary function, you can then compare it with the reversed version and determine whether the two match, indicating a palindrome."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)1 reverse\\"anna"\n"anna"\n"anna"\nq)(~) . 1 reverse\\"anna"\n1b\nq)(~) . 1 reverse\\"annA"\n0b\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Only when used with a unary function, Scan returns the initial argument."})}),"\n",(0,i.jsx)(n.h5,{id:"while",children:"While"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"t v1\\x\nt v1/x\t\tuntil unary value t, evaluated on the result, returns 0 \n"})}),"\n",(0,i.jsxs)(n.p,{children:["The last unary overload of Scan ",(0,i.jsx)(n.code,{children:"\\"})," or Over ",(0,i.jsx)(n.code,{children:"/"}),' is equivalent to a "while" loop in imperative programming. It offers a declarative way to define a termination condition for the iteration. The process continues as long as the predicate evaluates to ',(0,i.jsx)(n.code,{children:"1b"})," and stops otherwise. For instance, we can repeatedly multiply a number by 2 while the result remains less than 100 or square a given input until the result exceeds 1000."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(100>){2*x}\\2\n2 4 8 16 32 64 128\nq)(<1000){x*x}\\2\n'<\n  [0]  (<1000){x*x}\\2\n        ^\nq){x<1000}{x*x}\\2\n2 4 16 256 65536\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice how the second attempt in the code above results in an error? You can prevent this by converting the test condition into a lambda and explicitly defining ",(0,i.jsx)(n.code,{children:"x"})," within it."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(10>)4\n1b\nq)(<10)4\n'<\n  [0]  (<10)4\n        ^\nq){10>x}4\n1b\nq){x<10}4\n1b\nq){x<1000}{x*x}\\2\n2 4 16 256 65536\nq){100>x}{2*x}\\2\n2 4 8 16 32 64 128\n"})}),"\n",(0,i.jsx)(n.h4,{id:"binary-functions",children:"Binary functions"}),"\n",(0,i.jsxs)(n.p,{children:["When applying the Scan ",(0,i.jsx)(n.code,{children:"\\"})," or Over ",(0,i.jsx)(n.code,{children:"/"})," iterator to a binary function, it derives a function that first evaluates the value on its entire (first) argument and then on the results of successive evaluations. The number of evaluations corresponds to the count of the right argument."]}),"\n",(0,i.jsx)(n.h5,{id:"binary-application",children:"Binary application"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Scan      x v2\\y    v2\\[x;y]\nOver      x v2/y    v2/[x;y]\n"})}),"\n",(0,i.jsx)(n.p,{children:"For example, suppose we want to sum the first 10 natural numbers starting from 1. In imperative programming, this would require control flow: initializing a result variable, setting up a loop counter, and iterating while adding to the result until the counter reaches the end of the list."}),"\n",(0,i.jsxs)(n.p,{children:["In KDB/Q, however, you can simply accumulate values, starting with an initial accumulator. There are no counters, no tests, and no explicit loops! Using the binary overload of Scan ",(0,i.jsx)(n.code,{children:"\\"})," or Over ",(0,i.jsx)(n.code,{children:"/"}),", the initial accumulator value is the left operand, and the list to accumulate over is the right operand. Internally, each item of the list is progressively added to the accumulator, moving through the list until completion. The final accumulated value is then returned."]}),"\n",(0,i.jsx)(n.p,{children:"For instance, with an initial accumulator value of 0:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1 is added to 0, resulting in 1"}),"\n",(0,i.jsx)(n.li,{children:"2 is then added to 1, yielding 3"}),"\n",(0,i.jsx)(n.li,{children:"This process continues until the end of the list"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This operates just like traditional imperative code, but without explicit control structures."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)0+\\1 2 3 4 5 6 7 8 9\n1 3 6 10 15 21 28 36 45\nq)0+/1 2 3 4 5 6 7 8 9\n45\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can use ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/internal/#0nx-show",children:(0,i.jsx)(n.code,{children:"0N!"})})," to examine what is happening behind the curtains"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)0 {0N!(x;y); x+y}/ 1 2 3 4 5\n0 1\n1 2\n3 3\n6 4\n10 5\n15\nq)0+/1 2 3 4 5\n15\n"})}),"\n",(0,i.jsx)(n.p,{children:"This pattern of combining Scan or Over with a binary function is so powerful that several keywords leverage it behind the scenes. Here are some of them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)sum 1 2 3 4\n10\nq)(+/)1 2 3 4\n10\nq)sums\n+\\\nq)sums 1 2 3 4\n1 3 6 10\nq)(+\\)1 2 3 4\n1 3 6 10\nq)prd 1 2 3 4\n24\nq)(*/)1 2 3 4\n24\nq)prds\n*\\\nq)(*\\)1 2 3 4\n1 2 6 24\nq)min 1 2 3 4\n1\nq)(&/)1 2 3 4\n1\nq)mins\n&\\\nq)(&\\)1 2 3 4\n1 1 1 1\nq)max 1 2 3 4\n4\nq)(|/)1 2 3 4\n4\nq)maxs\n|\\\nq)(|\\)1 2 3 4\n1 2 3 4\n"})}),"\n",(0,i.jsx)(n.h5,{id:"unary-application",children:"Unary application"}),"\n",(0,i.jsx)(n.p,{children:"Although applying a binary function in a unary context might seem counterintuitive, in many cases, explicitly specifying the initial accumulator value is unnecessary."}),"\n",(0,i.jsx)(n.p,{children:"For instance, in our summation example, instead of providing an initial accumulator, we can simply start with the first item in the list and accumulate the remaining values. This is achieved by enclosing the modified function in parentheses and omitting the initial accumulator:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(+\\) 1 2 3 4 5 6 7 8 9 10\n1 3 6 10 15 21 28 36 45 55\nq)(+/) 1 2 3 4 5 6 7 8 9 10\n55\n"})}),"\n",(0,i.jsx)(n.p,{children:"Conceptually, you can think of the list in its general form:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(1; 2; 3; 4; 5; 6; 7; 8; 9; 10)\n1 2 3 4 5 6 7 8 9 10\nq)1+til 10\n1 2 3 4 5 6 7 8 9 10\nq)(1; 2; 3; 4; 5; 6; 7; 8; 9; 10)~1+til 10\n1b\nq)(1 2 3 4 5 6 7 8 9 10)~(1; 2; 3; 4; 5; 6; 7; 8; 9; 10)\n1b\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"(+/)"})," effectively replaces the semicolons ",(0,i.jsx)(n.code,{children:";"})," with a plus ",(0,i.jsx)(n.code,{children:"+"}),", associating the operation from the left."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A few key points about this form"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The parentheses are necessary"}),"\n",(0,i.jsx)(n.li,{children:"The modified function is now unary."}),"\n",(0,i.jsxs)(n.li,{children:["This code is actually ",(0,i.jsx)(n.code,{children:"k"})," code rather than ",(0,i.jsx)(n.code,{children:"KDB/Q"})," - so you're technically writing ",(0,i.jsx)(n.code,{children:"k"})," code (Don't tell anyone!)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Moreover, both, the unary and binary from of Scan ",(0,i.jsx)(n.code,{children:"\\"})," and Over ",(0,i.jsx)(n.code,{children:"/"})," can also be written in prefix notation"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)+/[0; 1 2 3 4 5 6 7 8 9 10]\n55\nq)+\\[0; 1 2 3 4 5 6 7 8 9 10]\n1 3 6 10 15 21 28 36 45 55\nq)+/[1 2 3 4 5 6 7 8 9 10]\n55\nq)+\\[1 2 3 4 5 6 7 8 9 10]\n1 3 6 10 15 21 28 36 45 55\n"})}),"\n",(0,i.jsxs)(n.h5,{id:"the-keywords-scan-and-over",children:["The keywords ",(0,i.jsx)(n.code,{children:"scan"})," and ",(0,i.jsx)(n.code,{children:"over"})]}),"\n",(0,i.jsxs)(n.p,{children:["You can use the ",(0,i.jsx)(n.code,{children:"scan"})," and ",(0,i.jsx)(n.code,{children:"over"})," keywords to apply a binary function to a list or dictionary. However, if you are using an infix function as the left argument, make sure to enclose it in parentheses."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(+) scan 1 2 3 4\n1 3 6 10\nq)(+) over 1 2 3 4\n10\nq)show d:`a`b`c`d!`b`d`c`a\na| b\nb| d\nc| c\nd| a\nq)d scan `a\n`a`b`d\nq)d over `b\n`a\nq)d scan `b\n`b`d`a\n"})}),"\n",(0,i.jsx)(n.h4,{id:"ternary-functions",children:"Ternary functions"}),"\n",(0,i.jsxs)(n.p,{children:["Finally, let's examine the combination of iterators with ternary functions (functions that take three arguments) or functions of even higher arity (up to eight arguments). When an accumulator derives a function from an initial function with a rank greater than two, it retains the same rank as the original function. Functions derived using ",(0,i.jsx)(n.strong,{children:"Scan"})," ",(0,i.jsx)(n.code,{children:"\\"})," are uniform, while those derived using ",(0,i.jsx)(n.strong,{children:"Over"})," ",(0,i.jsx)(n.code,{children:"/"})," are aggregates. The number of evaluations corresponds to the maximum count of the right arguments."]}),"\n",(0,i.jsxs)(n.p,{children:["For ",(0,i.jsx)(n.code,{children:"v\\[x;y;z]"})," and ",(0,i.jsx)(n.code,{children:"v/[x;y;z]"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x"})," is the initial argurment, and belongs to the left domain of ",(0,i.jsx)(n.code,{children:"v"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"y"})," and ",(0,i.jsx)(n.code,{children:"z"})," are either atoms, conforming lists, or dictionaries within the right domains of ",(0,i.jsx)(n.code,{children:"v"})]}),"\n",(0,i.jsxs)(n.li,{children:["The first evaluation is ",(0,i.jsx)(n.code,{children:"v[x; first y; first z]"}),", and its result becomes the left argument for the next evaluation, continuing in this manner."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For example, for ",(0,i.jsx)(n.code,{children:"r:v\\[x;y;z]"}),", the iterative process applies the function across the provided arguments accordingly."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"r[0]: v[x  ; y 0; z 0]\nr[1]: v[r 0; y 1; z 1]\nr[2]: v[r 1; y 2; z 2]\n\u2026\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The result of ",(0,i.jsx)(n.code,{children:"v/[x;y;z]"})," is simply the last item of the above"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"v/[x;y;z]\nv[ v[\u2026 v[ v[x;y0;z0] ;y1;z1]; \u2026 yn-2;zn-2]; yn-1;zn-1]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here are some examples to help you get familiar with this syntax and concept."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q){x+y*z}\\[1000;5 10 15 20;2 3 4 5]\n1010 1040 1100 1200\nq){x+y*z}\\[1000 2000;5 10 15 20;3]\n1015 2015\n1045 2045\n1090 2090\n1150 2150\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But what about a more practical example? Imagine you're working at a large corporation with hundreds of processes running across multiple regions, each with several instances. Your team follows a naming convention: ",(0,i.jsx)(n.code,{children:'"ProcessName.Region_InstanceNumber"'}),", such as ",(0,i.jsx)(n.code,{children:'"ProcessName.Region_InstanceNumber"'}),". Your task is to extract the region from a given process name. While this might seem trivial, you'd be surprised how tricky it can be in many mainstream programming languages. However, in KDB/Q, it's just a one-liner! By combining the Over iterator ",(0,i.jsx)(n.code,{children:"/"})," with the ",(0,i.jsx)(n.code,{children:"vs"}),",",(0,i.jsx)(n.code,{children:"first"}),", and ",(0,i.jsx)(n.code,{children:"last"})," operators, we can easily achieve this. Let's try it!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q){z y vs x}/["TICKERPLANT.US_1";"._";(last;first)]\n"US"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Magic? Not quite\u2014but close! Here's what's happening:"}),"\n",(0,i.jsxs)(n.p,{children:["The input ",(0,i.jsx)(n.code,{children:'"TICKERPLANT.US_1"'})," is passed as ",(0,i.jsx)(n.code,{children:"x"})," to our lambda ",(0,i.jsx)(n.code,{children:"{z y vs x}"}),", along with the first item of ",(0,i.jsx)(n.code,{children:"y"}),", which is ",(0,i.jsx)(n.code,{children:'"."'}),", and the first item of ",(0,i.jsx)(n.code,{children:"z"}),", which is the ",(0,i.jsx)(n.code,{children:"last"})," operator. This results in the expression:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'last "." vs "TICKERPLANT.US_1"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["which evaluates to ",(0,i.jsx)(n.code,{children:'"US_1"'}),". This intermediate result is then passed as ",(0,i.jsx)(n.code,{children:"x"})," into the next iteration of our lambda, where ",(0,i.jsx)(n.code,{children:"y"})," is ",(0,i.jsx)(n.code,{children:'"_"'})," and ",(0,i.jsx)(n.code,{children:"z"})," is ",(0,i.jsx)(n.code,{children:"first"}),", forming:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'first "_" vs "US_1"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["which returns the final result: ",(0,i.jsx)(n.code,{children:'"US".'})," In theory, you could achieve the same result with:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'q)first "_" vs last "." vs "TICKERPLANT.US_1"\n"US"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["but it's nowhere near as elegant as our approach using ",(0,i.jsx)(n.strong,{children:"Over"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This concludes our section on ",(0,i.jsx)(n.strong,{children:"Scan"})," ",(0,i.jsx)(n.code,{children:"\\"})," and ",(0,i.jsx)(n.strong,{children:"Over"})," ",(0,i.jsx)(n.code,{children:"/"}),". Take a moment to review their various overloads, syntax, and the different behaviors they exhibit based on function arity and the number of parameters."]}),"\n",(0,i.jsx)(n.h2,{id:"combining-iterators",children:"Combining Iterators"}),"\n",(0,i.jsx)(n.p,{children:"The power of Iterators extends beyond their individual applications - you can also combine them to create even more efficient and powerful code. In the next section, we will explore two examples that demonstrate how iterators can be used in combination."}),"\n",(0,i.jsxs)(n.p,{children:["For our first example, let's say you have two lists of numbers and want to determine all possible ways to pair their elements. This is essentially finding the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Permutation",children:"permutations"})," of two sets, a common problem in mathematics. While it\u2019s easy to do manually with pen and paper, implementing it in code can be less straightforward."]}),"\n",(0,i.jsxs)(n.p,{children:["Consider the list ",(0,i.jsx)(n.code,{children:"1 2 3"}),", and suppose we want to generate all possible pairs of these numbers with themselves. Our two lists are ",(0,i.jsx)(n.code,{children:"1 2 3"})," and ",(0,i.jsx)(n.code,{children:"1 2 3"}),". The expected output would be:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"(1,1), (1,2), (1,3)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"(2,1), (2,2), (2,3)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"(3,1), (3,2), (3,3)"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Seems simple, right? But how would you implement this? Combining two iterators, the ",(0,i.jsx)(n.strong,{children:"each-right"})," ",(0,i.jsx)(n.code,{children:"/:"})," and the ",(0,i.jsx)(n.strong,{children:"each-left"})," ",(0,i.jsx)(n.code,{children:"\\:"})," iterators, this task becomes a simple, concise KDB/Q one-liner. Let's take a look at how this works:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)1 2 3 ,/:\\:1 2 3\n1 1 1 2 1 3\n2 1 2 2 2 3\n3 1 3 2 3 3\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the output doesn\u2019t look as expected because you anticipated a list of pairs, let\u2019s take a closer look at the actual structure. We can use the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/internal/#0nx-show",children:(0,i.jsx)(n.code,{children:"0N!"})})," operator to inspect the underlying data format. Doing so reveals that the output is, in fact, a list of lists, or more precisely, a list of pairs (tuples)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)0N!1 2 3 ,/:\\:1 2 3\n((1 1;1 2;1 3);(2 1;2 2;2 3);(3 1;3 2;3 3))\n1 1 1 2 1 3\n2 1 2 2 2 3\n3 1 3 2 3 3\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can now apply the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/raze/",children:(0,i.jsx)(n.code,{children:"raze"})})," operator to flatten one level of nesting in our result, giving us the exact output we expect."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)raze 1 2 3 ,/:\\:1 2 3\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\nq)0N!raze 1 2 3 ,/:\\:1 2 3\n(1 1;1 2;1 3;2 1;2 2;2 3;3 1;3 2;3 3)\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Our next example builds on the previous one as we take a deeper look at the ",(0,i.jsx)(n.a,{href:"https://code.kx.com/q/ref/raze/",children:(0,i.jsx)(n.code,{children:"raze"})})," operator. If we examine how ",(0,i.jsx)(n.code,{children:"raze"})," is defined under the hood, we see that it\u2019s simply a combination of the concatenate operator ",(0,i.jsx)(n.code,{children:","})," and the ",(0,i.jsx)(n.strong,{children:"Over"})," ",(0,i.jsx)(n.code,{children:"/"})," iterator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)raze\n,/\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This makes sense because flattening one level of nesting is essentially just joining or concatenating the nested lists at that level. But what if the nesting goes deeper, spanning multiple levels? This is where combining iterators comes in handy to achieve full flattening across all levels. By applying ",(0,i.jsx)(n.code,{children:"raze"})," with ",(0,i.jsx)(n.strong,{children:"Over"}),", essentially using ",(0,i.jsx)(n.strong,{children:"Over"})," twice, we can completely eliminate all layers of nesting."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Create a list with several layers of nesting\nq)(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))\n1\n(1 2;(1 2 3;4 5);(10 12;13 14))\n(((3 4;5 6);(10 20 30;40 50));(1 2;3 4))\n// Applying raze only eliminates one level of nesting \nq)raze (1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))\n1\n1 2\n(1 2 3;4 5)\n(10 12;13 14)\n((3 4;5 6);(10 20 30;40 50))\n(1 2;3 4)\n// However, combining raze with over will eliminate all layers of nesting\nq)raze/[(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))]\n1 1 2 1 2 3 4 5 10 12 13 14 3 4 5 6 10 20 30 40 50 1 2 3 4\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["If you want even more concise and elegant code, you can take advantage of ",(0,i.jsx)(n.code,{children:"raze"}),"'s underlying definition and combine it with ",(0,i.jsx)(n.strong,{children:"Over"})," to create the terse expression ",(0,i.jsx)(n.code,{children:"(,//)x"}),", which achieves the same result as ",(0,i.jsx)(n.code,{children:"raze/[x]"}),". However, keep in mind that this is ",(0,i.jsx)(n.code,{children:"k"})," code rather than ",(0,i.jsx)(n.code,{children:"q"}),"."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)(,//)(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))\n1 1 2 1 2 3 4 5 10 12 13 14 3 4 5 6 10 20 30 40 50 1 2 3 4\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["But why stop here? You can take it a step further and create a modified version of ",(0,i.jsx)(n.code,{children:"raze"})," hat allows you to control how many levels of nesting you want to flatten. Shortly after I published the initial version of this blog post, none other than ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/in/charlesskelton/",children:"Charles Skelton"}),", former CTO and now Chief Scientist at KX, suggested this addition. The elegant snippet ",(0,i.jsx)(n.code,{children:"n,//x"})," lets you flatten a nested list ",(0,i.jsx)(n.code,{children:"n"})," times. And that\u2019s exactly what I aim for with DefconQ, to foster a collaborative space where KDB/Q developers can learn and grow together!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q)3,//(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))\n1\n1\n2\n1\n2\n3\n4\n5\n10\n12\n13\n14\n3 4\n5 6\n10 20 30\n40 50\n1\n2\n3\n4\nq)2,//(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))\n1\n1\n2\n1 2 3\n4 5\n10 12\n13 14\n(3 4;5 6)\n(10 20 30;40 50)\n1 2\n3 4\nq)1,//(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))\n1\n1 2\n(1 2 3;4 5)\n(10 12;13 14)\n((3 4;5 6);(10 20 30;40 50))\n(1 2;3 4)\nq)4,//(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))\n1 1 2 1 2 3 4 5 10 12 13 14 3 4 5 6 10 20 30 40 50 1 2 3 4\nq),//[2;(1; (1 2;(1 2 3;4 5);(10 12;13 14));(((3 4;5 6);(10 20 30;40 50));(1 2;3 4)))]\n1\n1\n2\n1 2 3\n4 5\n10 12\n13 14\n(3 4;5 6)\n(10 20 30;40 50)\n1 2\n3 4\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tips-and-tricks",children:"Tips and Tricks"}),"\n",(0,i.jsxs)(n.p,{children:["We've now covered all the Iterators, their syntax, overloads, behaviors, and functionality. Most of the content in this blog post is not new and has been documented on ",(0,i.jsx)(n.a,{href:"https://code.kx.com/home/",children:"code.kx.com"}),". However, in this section, I'd like to share a few tips and tricks."]}),"\n",(0,i.jsx)(n.h3,{id:"how-to-know-which-iterator-is-used",children:"How to know which iterator is used"}),"\n",(0,i.jsxs)(n.p,{children:["The first question, identifying which Iterator is used in a given piece of code, is relatively straightforward: simply look at the operator. It should be easy to distinguish between ",(0,i.jsx)(n.strong,{children:"Each"})," ",(0,i.jsx)(n.code,{children:"'"})," (",(0,i.jsx)(n.code,{children:"each"}),"), ",(0,i.jsx)(n.strong,{children:"Each-Left"})," ",(0,i.jsx)(n.code,{children:"\\:"}),", and ",(0,i.jsx)(n.em,{children:"8Each-Right"}),"* ",(0,i.jsx)(n.code,{children:"/:"})," (remember, you can tell ",(0,i.jsx)(n.strong,{children:"Each-left"})," from ",(0,i.jsx)(n.strong,{children:"Each-right"})," based on which direction the slash leans), as well as ",(0,i.jsx)(n.strong,{children:"Scan"})," ",(0,i.jsx)(n.code,{children:"\\"})," and ",(0,i.jsx)(n.strong,{children:"Over"})," ",(0,i.jsx)(n.code,{children:"/"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Where things get trickier is distinguishing between ",(0,i.jsx)(n.strong,{children:"Each-both"})," ",(0,i.jsx)(n.code,{children:"'"}),", ",(0,i.jsx)(n.strong,{children:"Each-Prior"})," ",(0,i.jsx)(n.code,{children:"':"}),", ",(0,i.jsx)(n.strong,{children:"Each-Parallel"})," ",(0,i.jsx)(n.code,{children:"':"}),", or determining which overload of ",(0,i.jsx)(n.strong,{children:"Scan"})," and ",(0,i.jsx)(n.strong,{children:"Over"})," is being used. In these cases, your next step should be to examine the arity of the function the Iterator is applied to: how many arguments it takes and how many are being passed."]}),"\n",(0,i.jsxs)(n.p,{children:["If a unary function is used, ",(0,i.jsx)(n.strong,{children:"Scan"})," and ",(0,i.jsx)(n.strong,{children:"Over"})," can exhibit three different behaviors: ",(0,i.jsx)(n.strong,{children:"Converge"}),", ",(0,i.jsx)(n.strong,{children:"Do"}),", or ",(0,i.jsx)(n.strong,{children:"While"}),". This depends on the number and type of parameters passed:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Converge"}),": No parameter is passed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Do"}),": The ",(0,i.jsx)(n.code,{children:"x"})," argument is a positive integer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"While"}),": The first argument ",(0,i.jsx)(n.code,{children:"x"})," is a true condition."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Following this approach will help you understand what\u2019s really happening in the code. Additionally, it's always a good idea to have a KDB/Q console open so you can test snippets and observe their behavior firsthand."}),"\n",(0,i.jsx)(n.h3,{id:"how-to-understand-whats-happening",children:"How to understand what's happening"}),"\n",(0,i.jsx)(n.p,{children:"If you're still struggling to understand what's happening, don\u2019t panic. Take a deep breath and take a step back."}),"\n",(0,i.jsxs)(n.p,{children:["If you're using the ",(0,i.jsx)(n.strong,{children:"Over"})," ",(0,i.jsx)(n.code,{children:"/"})," iterator and can't quite understand how the final result was achieved, try replacing ",(0,i.jsx)(n.strong,{children:"Over"})," ",(0,i.jsx)(n.code,{children:"/"})," with ",(0,i.jsx)(n.strong,{children:"Scan"})," ",(0,i.jsx)(n.code,{children:"\\"}),". This will display all the intermediate steps, which might help you spot a pattern and better understand the process. Seeing the full sequence of calculations can often make things clearer."]}),"\n",(0,i.jsxs)(n.p,{children:["For any other Iterator, or really any piece of code, use ",(0,i.jsx)(n.code,{children:"0N!"})," to print to the console. It's one of the fundamental debugging techniques: print out values to see what\u2019s going on under the hood."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"q){0N!(x;y);x,y}/:\\:[1 2 3;4 5 6]\n1 4\n1 5\n1 6\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6\n1 4 1 5 1 6\n2 4 2 5 2 6\n3 4 3 5 3 6\nq)1 2 3,/:\\:4 5 6\n1 4 1 5 1 6\n2 4 2 5 2 6\n3 4 3 5 3 6\n"})}),"\n",(0,i.jsxs)(n.p,{children:["That wraps up our session on Iterators. I hope you found it helpful and enjoyable! If you did, feel free to follow ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/in/alexanderunterrainer/",children:"me"})," and ",(0,i.jsx)(n.a,{href:"https://www.linkedin.com/company/defconq/",children:(0,i.jsx)(n.strong,{children:"DefconQ"})})," on LinkedIn and subscribe to my free ",(0,i.jsx)(n.a,{href:"https://defconq.substack.com",children:"newsletter"})," to stay updated with my latest blog posts and get updates straight to your inbox."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Until next time - happy coding!"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Resources:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.grammarly.com/blog/parts-of-speech/adverb/#:~:text=An%20adverb%20is%20a%20word,brought%20an%20umbrella.%E2%80%9D",children:"Grammarly: What Is an Adverb? Definition and Examples"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://code.kx.com/q/about/terminology/",children:"KDB/Q Terminology"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://code.kx.com/q4m3/6_Functions/#67-iterators",children:"Q for Mortals: 6.7 Iterators"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://code.kx.com/q/wp/iterators/",children:"Guide to iterators: A white paper"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/iteration/",children:"KX Documentation: Iteration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://code.kx.com/q/basics/implicit-iteration/",children:"Implicit Iteration"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},94407:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/caseSyntax-c672f863d107ebe85106145607a65a98.png"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);