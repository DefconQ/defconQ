"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[98],{6847:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=t(4848),i=t(8453);const o={sidebar_position:5},s="Dictionaries and Tables",r={id:"concepts/dictionariesTables",title:"Dictionaries and Tables",description:"In this blog post, we explore two key data types native to KDB/Q: Dictionaries and Tables. Unlike mainstream programming languages like Java, which lack native support for these data types and require alternative structures (e.g., Java HashMap for dictionaries or Java ArrayList for lists of rows to represent tables), KDB/Q inherently supports both Dictionaries and Tables. Understanding these data structures is crucial for leveraging the speed and performance of KDB/Q to build efficient big data applications. In the following sections, we will examine the most important concepts of both data types, a in detail explanation of dictionaries and tables is beyond the scope of this blog post and can be found in Chapter 5 - Dictionaries and Chapter 8 - Tables of Q for Mortals.",source:"@site/docs/concepts/dictionariesTables.mdx",sourceDirName:"concepts",slug:"/concepts/dictionariesTables",permalink:"/docs/concepts/dictionariesTables",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Amend, Amend At: The Swiss Army knife among KDB/Q operators",permalink:"/docs/concepts/amend"},next:{title:"QSQL - Querying Your Data",permalink:"/docs/concepts/qsql"}},l={},d=[{value:"Dictionaries",id:"dictionaries",level:2},{value:"Creating Dictionaries",id:"creating-dictionaries",level:3},{value:"Indexing into a dictionary",id:"indexing-into-a-dictionary",level:3},{value:"Reverse Lookup: Finding values",id:"reverse-lookup-finding-values",level:3},{value:"Operations on a single Dictionary",id:"operations-on-a-single-dictionary",level:3},{value:"Operations involving multiple Dictionaries",id:"operations-involving-multiple-dictionaries",level:3},{value:"Appending and Amending dictionaries",id:"appending-and-amending-dictionaries",level:3},{value:"Joining Dictionaries",id:"joining-dictionaries",level:3},{value:"Column Dictionaries",id:"column-dictionaries",level:3},{value:"Tables",id:"tables",level:2},{value:"Creating Tables",id:"creating-tables",level:3},{value:"Flipped column dictionary",id:"flipped-column-dictionary",level:4},{value:"List of conform dictionaries",id:"list-of-conform-dictionaries",level:4},{value:"Formal Table defintion",id:"formal-table-defintion",level:4},{value:"Keyed Tables vs Tables",id:"keyed-tables-vs-tables",level:3},{value:"Creating a keyed table",id:"creating-a-keyed-table",level:4},{value:"Keyed Tables: Dictionary of Dictionaries",id:"keyed-tables-dictionary-of-dictionaries",level:3},{value:"Indexing into tables",id:"indexing-into-tables",level:3},{value:"Appending records to tables",id:"appending-records-to-tables",level:3},{value:"Inserting into tables",id:"inserting-into-tables",level:3},{value:"Simple tables",id:"simple-tables",level:4},{value:"Keyed tables",id:"keyed-tables",level:4},{value:"Upsert: Fusion between insert and update",id:"upsert-fusion-between-insert-and-update",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"dictionaries-and-tables",children:"Dictionaries and Tables"}),"\n",(0,a.jsxs)(n.p,{children:["In this blog post, we explore two key data types native to KDB/Q: ",(0,a.jsx)(n.strong,{children:"Dictionaries and Tables"}),". Unlike mainstream programming languages like Java, which lack native support for these data types and require alternative structures (e.g., Java HashMap for dictionaries or Java ArrayList for lists of rows to represent tables), KDB/Q inherently supports both Dictionaries and Tables. Understanding these data structures is crucial for leveraging the speed and performance of KDB/Q to build efficient big data applications. In the following sections, we will examine the most important concepts of both data types, a in detail explanation of dictionaries and tables is beyond the scope of this blog post and can be found in ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/5_Dictionaries/#50-overview",children:"Chapter 5 - Dictionaries"})," and ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/8_Tables/",children:"Chapter 8 - Tables"})," of ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/",children:"Q for Mortals"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["As noted on the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/#datatypes",children:"reference page"})," at ",(0,a.jsx)(n.a,{href:"https://code.kx.com/home/",children:"code.kx.com"}),", dictionaries are of type 99h, while tables are of type 98h."]})}),"\n",(0,a.jsx)(n.h2,{id:"dictionaries",children:"Dictionaries"}),"\n",(0,a.jsxs)(n.p,{children:["In its simplest form, a dictionary is simply a mapping of a list of keys to a list of values, and it can be created using the ",(0,a.jsxs)(n.a,{href:"https://code.kx.com/q/ref/dict/",children:["bang operator ",(0,a.jsx)(n.code,{children:"!"})]}),". Let's look at an example:"]}),"\n",(0,a.jsx)(n.h3,{id:"creating-dictionaries",children:"Creating Dictionaries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Create a list of keys\nq)k:`a`b`c\n// Create a list of values\nq)v:1 2 3\n// Create the mapping between keys and values\nq)k!v\na| 1\nb| 2\nc| 3\n// Create a dictionary directly\nq)`a`b`c!1 2 3\na| 1\nb| 2\nc| 3\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["The keywords ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/key/",children:(0,a.jsx)(n.code,{children:"key"})}),"  and ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/value/",children:(0,a.jsx)(n.code,{children:"value"})})," can be used to extract the keys and values from a dictionary, respectively."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\nq)key d\n`a`b`c\nq)value d\n1 2 3\n"})})]}),"\n",(0,a.jsxs)(n.p,{children:["Dictionaries are highly flexible data structures. The main constraint when creating a dictionary is that the length of the keys list must match the length of the values list. If they don't match, a ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/basics/errors/",children:(0,a.jsx)(n.code,{children:"length error"})})," will occur."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`a`b`c!1 2 3 4\n'length\n  [0]  `a`b`c!1 2 3 4\n             ^\n"})}),"\n",(0,a.jsx)(n.p,{children:"To demonstrate the flexibility of dictionaries, note that the type of the list of keys or values doesn\u2019t have to be homogeneous. However, once you create a homogeneous list of keys or values, any new key or value added must match the existing types. This might sound complex, but it's easier to understand with some examples. Let's take a look."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'// Create a dictionary with a list of non-homogenous keys\nq)show d:(`a;10;"C")!1 2 3\n`a | 1\n10 | 2\n"C"| 3\n// Add a new key of type integer\nq)d[2]:4\nq)d\n`a | 1\n10 | 2\n"C"| 3\n2  | 4\n// Add another key of type symbol\nq)d[`b]:9\nq)d\n`a | 1\n10 | 2\n"C"| 3\n2  | 4\n`b | 9\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As shown in the example above, the keys of our dictionary can be of different types, allowing us to add new keys of any type. However, the values of the dictionary are all ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/#datatypes",children:(0,a.jsx)(n.code,{children:"long 7h"})}),". Attempting to add a record where the value type doesn't match the current value types will result in a type error."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'// Verify the data type of the keys of our dictionary\nq)type value d\n7h\n// Trying to add a new record with a symbol as value\nq)d["z"]:`hello\n\'type\n  [0]  d["z"]:`hello\n             ^\n'})}),"\n",(0,a.jsxs)(n.p,{children:["With the release of KDB/Q ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q//releases/ChangesIn4.1/",children:"version 4.1"}),", ",(0,a.jsx)(n.a,{href:"https://kx.com",children:"KX"})," introduced a new dictionary syntax that enhances both the readability and flexibility of the language. In KDB/Q 4.1, you can now define dictionaries as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)([a:1;b:2;c:3])\na| 1\nb| 2\nc| 3\n"})}),"\n",(0,a.jsx)(n.p,{children:"This is especially useful for creating empty or singleton dictionaries, which was quite verbose and cumbersome before version 4.1. See for yourself:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Creating an empty, untyped dictionary\nq)d:()!()\nq)0N!d\n()!()\n// Creating an empty dictionary with keys of type integer and values of type symbol\nq)d:(`int$())!`symbol$()\nq)0N!d\n(`int$())!`symbol$()\n// Creating a singleton dictionary\nq)enlist[`a]!enlist 3\na| 3\n"})}),"\n",(0,a.jsx)(n.p,{children:"In contrast, with KDB/Q version 4.1 above dictionary definitions became much easier and more readable"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Creating an empty dictionary\nq)d:([])\nq)0N!d\n(`symbol$())!()\n// Creating a singleton dictionary\nq)d:([a:3])\nq)d\na| 3\n"})}),"\n",(0,a.jsx)(n.h3,{id:"indexing-into-a-dictionary",children:"Indexing into a dictionary"}),"\n",(0,a.jsxs)(n.p,{children:["When you index into a dictionary, you are essentially performing a dictionary lookup, accessing a dictionary ",(0,a.jsx)(n.code,{children:"d"})," to retrieve the value ",(0,a.jsx)(n.code,{children:"v"})," at the specified key ",(0,a.jsx)(n.code,{children:"k"}),". You can index into a dictionary using both, brackets and postfix notation"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\n// Indexing into a dictionary using bracket notation\nq)d[`a]\n1\n// Indexing into a dictionary using postfix notation\nq)d`a\n1\n// Ensuring both notations return the same result\nq)d[`a]~d`a\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can also retrieve multiple elements using a list of keys as index"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\nq)d[`a`b]\n1 2\nq)d`a`b\n1 2\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, due to the flexibility of dictionaries, their keys don't have to be unique, allowing the same key to be used multiple times. This can lead to unexpected results when retrieving elements stored at a key that's used more than once."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d:`a`b`c`a`b`c`d!til 7\nq)d\na| 0\nb| 1\nc| 2\na| 3\nb| 4\nc| 5\nd| 6\nq)d`a\n0\nq)d`b\n1\nq)d?3\n`a\n"})}),"\n",(0,a.jsx)(n.h3,{id:"reverse-lookup-finding-values",children:"Reverse Lookup: Finding values"}),"\n",(0,a.jsxs)(n.p,{children:["Indexing into a dictionary is straightforward and a common operation. However, there are times when we need to perform the reverse operation: finding the key associated with a specific value. This is called a reverse lookup and we can accomplish this using the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/find/",children:(0,a.jsx)(n.code,{children:"find ?"})})," operator as follows"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d:`a`b`c!1 2 3\nq)d\na| 1\nb| 2\nc| 3\nq)d?3\n`c\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One drawback of the ",(0,a.jsx)(n.code,{children:"find ?"})," operator is that, for a list with non-unique elements, it will only return the index of the first occurrence of an element that appears multiple times. When applied to a dictionary, if the value being searched for occurs multiple times, only the first key associated with that value will be returned."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d:`a`b`c`d`e`f!1 2 3 1 2 3\nq)d\na| 1\nb| 2\nc| 3\nd| 1\ne| 2\nf| 3\nq)d?1\n`a\n"})}),"\n",(0,a.jsxs)(n.p,{children:["But don't worry. Fortunately, we can use the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/basics/comparison/#six-comparison-operators",children:(0,a.jsx)(n.code,{children:"equals ="})})," operator along with the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/where/",children:(0,a.jsx)(n.code,{children:"where"})})," keyword to find all keys for the value we're searching for. The following method will return exactly what you need."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d:`a`b`c`d`e`f!1 2 3 1 2 3\n// When comparing a dictionary to a value, the comparison is applied to every value of the dictionary\n// resulting in a boolean mask, indicating 1 where the comparison is true, and 0 where it is false\nq)d=1\na| 1\nb| 0\nc| 0\nd| 1\ne| 0\nf| 0\n// We can now leverage where to obtain the keys where the boolean mask is 1b\nq)where d=1\n`a`d\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"The code snippet above highlights a crucial concept about dictionaries. Fully understanding this will enhance your skills as a KDB/Q developer: the key-value mapping of a dictionary is analogous to the index-value mapping of a list. To clarify, if you have a list of numbers from 0 to 10, each number is implicitly mapped to its index\u20140 is mapped to index 0 (since KDB/Q uses zero-based indexing), 1 to index 1, 2 to index 2, and so forth. In a dictionary, this same index-value mapping occurs, but with keys serving as the index instead of numerical values. Moreover, there's nothing stopping you from creating a dictionary with numerical keys mapped to numerical values. Remembering that operations on dictionaries affect their values while leaving keys unchanged provides a powerful tool for your development. Let me illustrate what I just explained"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Creating a dictionary mapping the numbers 0 to 5 to the corresponding value\nq)0 1 2 3 4!0 1 2 3 4\n0| 0\n1| 1\n2| 2\n3| 3\n4| 4\n// same operation but in q-style\nq)x!x:til 5\n0| 0\n1| 1\n2| 2\n3| 3\n4| 4\nq)d:x!x:til 5\n// indexing into the dictionary at index 0\nq)d 0\n0\n// Creating a list of values from 0 to 5\nq)l:til 5\n// indexing into the list at index 0\nq)l 0\n0\n// Showing that both operations return the same result\nq)d[0]~l 0\n1b\n"})}),"\n",(0,a.jsx)(n.h3,{id:"operations-on-a-single-dictionary",children:"Operations on a single Dictionary"}),"\n",(0,a.jsx)(n.p,{children:"One of the great features of KDB/Q dictionaries is that applying a function to a dictionary effectively applies it to the dictionary's value list. Let me show you some examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// First we create a dictionary\nq)d:`a`b`c!1 2 3\n// We can convert all values to their corresponding negative value by using the keyword neg \nq)neg d\na| -1\nb| -2\nc| -3\n// Find the minimum value in the dictinary\nq)min d\n1\n// Multiply all values by 2\nq)2*d\na| 2\nb| 4\nc| 6\n// Compare the values of the dictionary to the value 2\nq)d=2\na| 0\nb| 1\nc| 0\n// count returns the length of the dictionary\nq)count d\n3\n// Return the first value of the dictionary d\nq)first d\n1\n// Return the last value of the dictionary d\nq)last d\n3\n"})}),"\n",(0,a.jsxs)(n.p,{children:["There are many other useful operations you can perform on dictionaries. For a detailed explanation, please refer to ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/5_Dictionaries/",children:"Chapter 5: Dictionaries"})," in Q for Mortals."]}),"\n",(0,a.jsx)(n.h3,{id:"operations-involving-multiple-dictionaries",children:"Operations involving multiple Dictionaries"}),"\n",(0,a.jsx)(n.p,{children:"We've already seen how to apply functions to a single dictionary. In this section, we'll explore how to use two or more dictionaries together with the KDB/Q operators we've covered so far. When applying functions such as addition, subtraction, multiplication or division to two dictionaries, the operation will match all common keys and apply the function to the value(s) of the matching key(s). Let's illustrate this with an example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d1:`a`b`c!1 2 3\nq)d2:`a`b`c!4 5 6\nq)d1+d2\na| 5\nb| 7\nc| 9\nq)d1-d2\na| -3\nb| -3\nc| -3\nq)d1*d2\na| 4\nb| 10\nc| 18\nq)d1%d2\na| 0.25\nb| 0.4\nc| 0.5\n"})}),"\n",(0,a.jsx)(n.p,{children:"But what happens if any of the two dictionaries contains non matching keys?"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d1+`a`b`d!6 7 8\na| 7\nb| 9\nc| 3\nd| 8\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As demonstrated above, the result is the union of the records in both dictionaries. The function is applied to all records where the keys match, and records without matching keys are amended using the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/5_Dictionaries/#527-arithmetic-and-relational-operations",children:"identity element"})," (0 for addition and subtraction and 1 for multiplication and division) of the operation as the second parameter."]}),"\n",(0,a.jsx)(n.h3,{id:"appending-and-amending-dictionaries",children:"Appending and Amending dictionaries"}),"\n",(0,a.jsx)(n.p,{children:"Now that we've explored how operators work on dictionaries, let's see how to insert new records into a dictionary. Adding a new record is straightforward: simply introduce a new key and assign it the value you want to insert."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show d:`a`b`c!1 2 3\na| 1\nb| 2\nc| 3\nq)d[`d]:4\nq)d\na| 1\nb| 2\nc| 3\nd| 4\n"})}),"\n",(0,a.jsx)(n.p,{children:"Updating existing records is just as simple as inserting new ones. Just index into the dictionary using the existing key and assign the new value to it."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d[`d]:5\nq)d\na| 1\nb| 2\nc| 3\nd| 5\n"})}),"\n",(0,a.jsx)(n.p,{children:"The only restriction for both operations is that the type of the new value you are inserting matches the type of the existing values of your dictionary."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d[`d]:`test\n'type\n  [0]  d[`d]:`test\n            ^\nq)d[`e]:`test\n'type\n  [0]  d[`e]:`test\n            ^\n"})}),"\n",(0,a.jsx)(n.h3,{id:"joining-dictionaries",children:"Joining Dictionaries"}),"\n",(0,a.jsx)(n.p,{children:"One of the great features of dictionaries is their behavior when joined. Since a dictionary is just a key-value mapping, joining two dictionaries will update the values of all matching keys in the first dictionary with the corresponding values from the second dictionary. Let's demonstrate this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)d1:`a`b`c!1 2 3\nq)d1\na| 1\nb| 2\nc| 3\nq)d2:`a`b`c!10 20 30\nq)d2\na| 10\nb| 20\nc| 30\nq)d1,d2\na| 10\nb| 20\nc| 30\n"})}),"\n",(0,a.jsx)(n.p,{children:"This feature is especially useful when designing your Application Programming Interfaces (APIs). You can pass a dictionary containing all the parameters for your API and within your function, you can then define a dictionary with the default parameters needed for your API's functionality. By joining the user-provided dictionary with the default parameters dictionary, you obtain all the necessary parameters. Let's look at some code to illustrate this concept."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"function:{[param]\n\tdefault:`a`b`c!1 2 3;\n\tres:defalut,param;\n\t:res\n\t};\n\nq)function[`a`b!10 20]\na| 10\nb| 20\nc| 3\n"})}),"\n",(0,a.jsx)(n.h3,{id:"column-dictionaries",children:"Column Dictionaries"}),"\n",(0,a.jsx)(n.p,{children:"Now that we've covered the basics of dictionaries, we can move on to a crucial concept for understanding our next topic: tables. This concept is column dictionaries, which form the foundation of tables. A column dictionary is a dictionary where each key is of type symbol, and each value is a list of values with the same length as all the other values. The formal definition is"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"`c1...`cN!(v1;...;vN)\nwhere \n - each c1 is a column name as symbol\n and\n - each v1 is a list of values\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let's look at a more practical example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)team:`name`age!(`Bob`Joe`Frank;25 35 40)\nq)team\nname| Bob Joe Frank\nage | 25  35  40\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, this dictionary contains two keys, ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"age"}),", which map to the corresponding names and ages of our team members. To retrieve all the names, you can index into the dictionary using the key ",(0,a.jsx)(n.code,{children:"name"})," like this ",(0,a.jsx)(n.code,{children:"team[`name]"}),".  Similarly, to get the ages of our team, you would use ",(0,a.jsx)(n.code,{children:"team[`age]"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Retrieve the names of the team\nq)team[`name]\n`Bob`Joe`Frank\n// Retrieve the age of the team\nq)team[`age]\n25 35 40\n"})}),"\n",(0,a.jsx)(n.p,{children:"Since each value in a column dictionary is actually a list, we can index into these lists as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Indexing into a list of values for the name key\nq)team[`name] 1\n`Joe\n// Using nested indexing to achieve the same\nq)team[`name;1]\n`Joe\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, if you recall, creating a singleton dictionary was somewhat cumbersome, and the same applies to a singleton column dictionary. Since a dictionary is a list of keys mapped to a list of values (or, in the case of a column dictionary, a list of lists), we need to use ",(0,a.jsx)(n.code,{children:"enlist"})," to create a singleton column dictionary."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)enlist[`name]!enlist `Bob`Joe`Frank\nname| Bob Joe Frank\n"})}),"\n",(0,a.jsx)(n.p,{children:"Luckily for us, this is much simpler with KDB/Q version 4.1"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)([name:`Bob`Joe`Frank])\nname| Bob Joe Frank\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We\u2019ve covered a lot about dictionaries so far, and now it's time to discuss the most important concept regarding column dictionaries. A ",(0,a.jsx)(n.em,{children:"flipped column dictionary"})," is simply a ",(0,a.jsx)(n.em,{children:"table"}),". Yes, that's right. If you flip a column dictionary, you get a table. Let's see this in practice."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Column Dictionary team, mapping name and age keys to a list of names and their corresponding ages\nq)team\nname| Bob Joe Frank\nage | 25  35  40\n// Creating a table by flipping a column dictionary\nq)show t:flip team\nname  age\n---------\nBob   25\nJoe   35\nFrank 40\n"})}),"\n",(0,a.jsx)(n.p,{children:"Additionally, it's worth noting that a table can be seen as a list of dictionaries that all conform, meaning the dictionaries share the same keys. In fact, KDB/Q will always aggregate a list of conforming dictionaries into a table."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Create a list of dictionaries that are all conform\nq)((`name`age!(`Bob;25));(`name`age!(`Joe;35));(`name`age!(`Frank;40)))\nname  age\n---------\nBob   25\nJoe   35\nFrank 40\n"})}),"\n",(0,a.jsx)(n.p,{children:"This understanding clarifies that we can access records in a table in the same way we index into a list, using position indexes. For instance, to retrieve the second record of our table, we simply use the index 1."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Indexing into a table\nq)t 1\nname| `Joe\nage | 35\n// Indexing into a list of conform dictionaries\nq)((`name`age!(`Bob;25));(`name`age!(`Joe;35));(`name`age!(`Frank;40))) 1\nname| `Joe\nage | 35\n// Verify that above results are in fact the same\nq)t[1]~((`name`age!(`Bob;25));(`name`age!(`Joe;35));(`name`age!(`Frank;40))) 1\n1b\n"})}),"\n",(0,a.jsx)(n.p,{children:"Last but not least, I'll explain why table operations are so performant and fast in KDB/Q. Tables are essentially column dictionaries, where each value is a list. Since KDB/Q is a vector/array programming language, operations on lists or vectors are highly efficient. Therefore, tables are represented as flipped column dictionaries in the background, rather than as a list of rows (simple dictionaries). This structure enables super-fast operations on columns, making KDB/Q much faster than conventional programming languages."}),"\n",(0,a.jsx)(n.p,{children:"We'll pause here for now, giving you time to absorb all the information covered in this blog. I'll update the blog later with a more detailed explanation of tables. If you have any questions, feel free to reach out."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Happy Coding!"})}),"\n",(0,a.jsx)(n.p,{children:"Now, let's continue. Last time, we discussed dictionaries, exploring their features, behaviors, and operations. We also covered column dictionaries and highlighted their key attribute: a flipped column dictionary becomes a table. Now, we will shift our focus to tables. Ensure you have a solid understanding of dictionaries, and if you need a refresher, feel free to revisit the previous section."}),"\n",(0,a.jsx)(n.h2,{id:"tables",children:"Tables"}),"\n",(0,a.jsx)(n.p,{children:"As previously mentioned, dictionaries and tables are native data types in KDB/Q, meaning they are first-class citizens and reside in memory just like lists. If you consider a table as a flipped column dictionary, you can think of it as a collection of named columns. This column-oriented structure, as opposed to a row-oriented one, is one of the reasons why KDB/Q excels at processing big data compared to relational databases. Furthermore, since lists are allocated in contiguous memory, so are columns, making data retrieval, manipulation, and storage highly efficient."}),"\n",(0,a.jsx)(n.h3,{id:"creating-tables",children:"Creating Tables"}),"\n",(0,a.jsx)(n.h4,{id:"flipped-column-dictionary",children:"Flipped column dictionary"}),"\n",(0,a.jsx)(n.p,{children:"The first method for creating a table is to start with a column dictionary. Since a flipped column dictionary is a table, let's begin with this approach."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// flipped column dictionary\nq)show t:flip `names`age!(`Alexander`Stephan`Christoph;37 27 34)\nnames     age\n-------------\nAlexander 37\nStephan   27\nChristoph 34\nq)0N!t\n+`names`age!(`Alexander`Stephan`Christoph;37 27 34)\nnames     age\n-------------\nAlexander 37\nStephan   27\nChristoph 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"As you can see from the above code, our flipped column dictionary is now represented as a table. However, upon closer inspection, we can observe that KDB/Q hasn't actually transposed the column dictionary in the background. Instead, it has only annotated that the data should be treated as a table. Keeping our table stored as a collection of named columns (i.e., lists) minimizes memory usage and enhances performance by enabling vectorized mathematical operations."}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["You can use ",(0,a.jsx)(n.code,{children:"0N!"})," for debugging and to see what's happening behind the scenes. As shown, the table is represented as ",(0,a.jsx)(n.code,{children:"+`names`age!(`Alexander`Stephan`Christoph;37 27 34)"}),", which is a flipped column dictionary. The ",(0,a.jsx)(n.code,{children:"+"})," operator is k-code for flipped."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)flip\n+:\n"})}),(0,a.jsxs)(n.p,{children:["You can find some documentation about exposed infrastructure ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/basics/exposed-infrastructure/",children:"here"})]})]}),"\n",(0,a.jsxs)(n.admonition,{type:"danger",children:[(0,a.jsx)(n.p,{children:"Creating a table by flipping a dictionary only works for column dictionaries. Remember, a column dictionary has symbols as keys, and each list must be of equal length, or be an atom that will automatically expand to match the length of the other lists."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)flip 1 2!(1 2 3;4 5 6)\n'nyi\n  [0]  flip 1 2!(1 2 3;4 5 6)\n       ^\nq)flip `a`b!(1 2;4 5 6)\n'length\n  [0]  flip `a`b!(1 2;4 5 6)\n       ^\nq)flip `a`b!(1;4 5 6)\na b\n---\n1 4\n1 5\n1 6\n"})})]}),"\n",(0,a.jsx)(n.h4,{id:"list-of-conform-dictionaries",children:"List of conform dictionaries"}),"\n",(0,a.jsx)(n.p,{children:"Another way of looking at tables is to see them as a list of conforming dictionaries. In fact, whenever you have a list of conforming dictionaries, KDB/Q will automatically convert it into a table. Let's take a look at this in practice."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)count (`name`age!(`Alexander;37);`name`age!(`Stephan;27);`name`age!(`Christoph;34))\n3\nq)first(`name`age!(`Alexander;37);`name`age!(`Stephan;27);`name`age!(`Christoph;34))\nname| `Alexander\nage | 37\nq)last(`name`age!(`Alexander;37);`name`age!(`Stephan;27);`name`age!(`Christoph;34))\nname| `Christoph\nage | 34\nq)(`name`age!(`Alexander;37);`name`age!(`Stephan;27);`name`age!(`Christoph;34))\nname      age\n-------------\nAlexander 37\nStephan   27\nChristoph 34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We first created a list of three conforming dictionaries and demonstrated that it is indeed a list by using the ",(0,a.jsx)(n.code,{children:"count"}),",",(0,a.jsx)(n.code,{children:"first"})," and ",(0,a.jsx)(n.code,{children:"last"})," operators to obtain the length of our list and the first and last elements, respectively. Then, we returned the list of conforming dictionaries and observed that KDB/Q automatically converts it into a table. Let's use ",(0,a.jsx)(n.code,{children:"0N!"})," to see what's happening behind the scenes."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)0N!(`name`age!(`Alexander;37);`name`age!(`Stephan;27);`name`age!(`Christoph;34))\n+`name`age!(`Alexander`Stephan`Christoph;37 27 34)\nname      age\n-------------\nAlexander 37\nStephan   27\nChristoph 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"In fact, our list of conforming dictionaries has been transformed into a table. This transformation makes memory allocation more efficient and operations on columns more performant due to the ability to use vectorized operations. But what about the operations we just applied to our list of conforming dictionaries? Will they still be valid for a table? Let's find out."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t:(`name`age!(`Alexander;37);`name`age!(`Stephan;27);`name`age!(`Christoph;34))\nname      age\n-------------\nAlexander 37\nStephan   27\nChristoph 34\nq)count t\n3\nq)first t\nname| `Alexander\nage | 37\nq)last t\nname| `Christoph\nage | 34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, the operations we applied to the list of conforming dictionaries can also be applied to our table. To verify whether a list of conforming dictionaries is truly a table, we can inspect its type using the ",(0,a.jsx)(n.code,{children:"type"})," operator"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)type (`name`age!(`Alexander;37);`name`age!(`Stephan;27);`name`age!(`Christoph;34))\n98h\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you recall, type 98h indicates a table. Feel free to verify this information ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/#datatypes",children:"here"})," if you have any doubts."]}),"\n",(0,a.jsx)(n.h4,{id:"formal-table-defintion",children:"Formal Table defintion"}),"\n",(0,a.jsx)(n.p,{children:"Finally, let's explore the formal method of creating a table by leveraging the concept of a table being a collection or list of named columns. This approach is particularly useful when creating empty tables and defining the schema of the data we aim to capture."}),"\n",(0,a.jsx)(n.p,{children:"A table can be formaly defined like"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"([] c1:L1; c2:L2; ... ; cn:Ln)\n\nwhere ci is a column name and Li is the corresponding list of column values\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let's have a look at a practical example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t:([] name:`Alex`Stephan`Christop; age:36 27 34)\nname     age\n------------\nAlex     36\nStephan  27\nChristop 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"Creating a table from data is straightforward, and defining an empty table schema, enforcing the column types is just as simple. Here's the code to do so:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t:([] name:`symbol$(); age:`int$())\nname age\n--------\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["The keyword ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/meta/",children:(0,a.jsx)(n.code,{children:"meta"})})," allows you to inspect the schema of a table. You can read more about it ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/meta/",children:"here"})]})}),"\n",(0,a.jsxs)(n.p,{children:["The schema of our table is now defined, and KDB/Q ensures that all types of the records we insert match the column types specified in the schema. Even if just one element of the record we're trying to insert doesn't match the type of the corresponding column, a ",(0,a.jsx)(n.code,{children:"type"})," error will be thrown."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`t insert (`Alexander;36i)\n,0\nq)`t insert (`Alex;`WrongType)\n'type\n  [0]  `t insert (`Alex;`WrongType)\n          ^\nq)t\nname      age\n-------------\nAlexander 36\nq)meta t\nc   | t f a\n----| -----\nname| s\nage | i\n"})}),"\n",(0,a.jsx)(n.p,{children:"We'll provide additional examples of how to insert records into a table later in the post."}),"\n",(0,a.jsx)(n.h3,{id:"keyed-tables-vs-tables",children:"Keyed Tables vs Tables"}),"\n",(0,a.jsx)(n.p,{children:"Another great feature of tables is that you can add a key to them, creating a keyed table. A key is basically a unique identifier, similar to a primary key in a traditional SQL database. Adding a key to a table is essential for performing joins between tables, which are powerful tools for merging datasets. This capability is one of the reasons why KDB/Q is so performant. We will cover joins in a dedicated blog post."}),"\n",(0,a.jsx)(n.h4,{id:"creating-a-keyed-table",children:"Creating a keyed table"}),"\n",(0,a.jsxs)(n.p,{children:["Adding a key to an existing table is straightforward using the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/keys/#xkey",children:(0,a.jsx)(n.code,{children:"xkey"})})," keyword. All you have to do, is to specify the column you would like to use as key and execute following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t:([] name:`Alexander`Stephan`Christoph; age:36 26 34)\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nq)show kt:`name xkey t\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Comparing the console output of the first table with the output of the second table illustrates that we have successfully added a key to our table, creating a keyed table ",(0,a.jsx)(n.code,{children:"kt"}),", making the ",(0,a.jsx)(n.code,{children:"name"})," column the unique identifier. Attempting to insert records with an existing key in the keyed table will result in an error, whereas new records with unique keys can still be inserted."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`kt insert (`Alexander;34)\n'insert\n  [0]  `kt insert (`Alexander;34)\n           ^\nq)`kt insert (`Alex;34)\n,3\nq)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"A keyed table can have multiple columns as keys; you are not limited to just one. Let's add another column to our keyed table and demonstrate how to create a keyed table with two columns as keys."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// We first add a date column to our table and then key on date and name\nq)`date`name xkey update date:.z.d from kt\ndate       name     | age\n--------------------| ---\n2024.06.28 Alexander| 36\n2024.06.28 Stephan  | 26\n2024.06.28 Christoph| 34\n2024.06.28 Alex     | 34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Another easy way to create a keyed table from an existing table is by using the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/enkey/",children:(0,a.jsx)(n.code,{children:"bang !"})})," operator. Just specify the number of keys you want to apply using the pattern ",(0,a.jsx)(n.code,{children:"n!table"}),", and the first ",(0,a.jsx)(n.code,{children:"n"})," columns will be used as keys. To unkey a table, or convert a keyed table back into a simple table, use ",(0,a.jsx)(n.code,{children:"0!keyedTable"}),". Alternatively, you can also use ",(0,a.jsx)(n.code,{children:"xkey"})," with an empty list ",(0,a.jsx)(n.code,{children:"()"})," to unkey a keyed table."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)1!t\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nq)xkey[`name;t]~1!t\n1b\nq)2!update date:.z.d from t\nname      age| date\n-------------| ----------\nAlexander 36 | 2024.06.28\nStephan   26 | 2024.06.28\nChristoph 34 | 2024.06.28\nq)0!kt\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nq)() xkey kt\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One key difference between the ",(0,a.jsx)(n.code,{children:"bang !"})," operator and trhe ",(0,a.jsx)(n.code,{children:"xkey"})," operator is that with the bang operator, you cannot specify the order of the columns used as keys. The bang operator will simply use the first ",(0,a.jsx)(n.code,{children:"n"})," columns as keys. However, with ",(0,a.jsx)(n.code,{children:"xkey"}),", you can specify the order of the keys by listing the column names in the desired order. Below example should highlight this"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`date`name xkey update date:.z.d from kt\ndate       name     | age\n--------------------| ---\n2024.06.28 Alexander| 36\n2024.06.28 Stephan  | 26\n2024.06.28 Christoph| 34\n2024.06.28 Alex     | 34\nq)2!update date:.z.d from t\nname      age| date\n-------------| ----------\nAlexander 36 | 2024.06.28\nStephan   26 | 2024.06.28\nChristoph 34 | 2024.06.28\n"})}),"\n",(0,a.jsx)(n.p,{children:"Last but not least, I would like to show you the formal definition of a keyed table, similar to what we have seen before with simple tables. If you review the formal definition of a simple table and wonder what the empty square brackets are for, here's the revelation: the square brackets are used to define the key(s) of a table. Let's take a closer look."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"([k1:K1;k2:K2;...;kN:KN] c1:L1; c2:L2; ... ; cn:Ln)\n\nwhere \n - ci is a column name and Li is the corresponding list of column values\n - ki is the name of the key column and Ki are the corresponding keys\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"In practice"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)([name:`Alexander`Stephan`Christoph`Alex] age:36 26 34 34)\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\nq)([date:4#.z.d; name:`Alexander`Stephan`Christoph`Alex] age:36 26 34 34)\ndate       name     | age\n--------------------| ---\n2024.06.28 Alexander| 36\n2024.06.28 Stephan  | 26\n2024.06.28 Christoph| 34\n2024.06.28 Alex     | 34\nq)([date:.z.d; name:`Alexander`Stephan`Christoph`Alex] age:36 26 34 34)\ndate       name     | age\n--------------------| ---\n2024.06.28 Alexander| 36\n2024.06.28 Stephan  | 26\n2024.06.28 Christoph| 34\n2024.06.28 Alex     | 34\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["You can verify whether a table is keyed or not by using the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/type/",children:(0,a.jsx)(n.code,{children:"type"})})," keyword. Tables are of type 98h while keyed tables are of type 99h"]})}),"\n",(0,a.jsx)(n.h3,{id:"keyed-tables-dictionary-of-dictionaries",children:"Keyed Tables: Dictionary of Dictionaries"}),"\n",(0,a.jsx)(n.p,{children:"But wait a moment\u2014if you've been carefully reading this blog post and review the tip I just shared, you'll notice something interesting. If a keyed table is of type 99h and dictionaries are also of type 99h, does that mean that a keyed table is a dictionary? Yes, exactly. That's precisely what it means. A keyed table is essentially a dictionary of tables."}),"\n",(0,a.jsxs)(n.p,{children:["Let's explore this in more detail. Using one of my favorite tools to debug KDB/Q code and understand what's happening - the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/basics/internal/#0nx-show",children:(0,a.jsx)(n.code,{children:"0N!"})})," operator - we can see that a keyed table is indeed a dictionary of two tables."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)0N!kt\n(+(,`name)!,`Alexander`Stephan`Christoph`Alex)!+(,`age)!,36 26 34 34\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"For further illustration and clarification, let's create a keyed table by manually creating a dictionary of two tables:"}),"\n",(0,a.jsxs)(n.p,{children:["First, we create the table to store the keys of our keyed table. Since we are keying only one column, we need to create a singleton dictionary using the ",(0,a.jsx)(n.code,{children:"enlist"})," operator. If you're not familiar with singleton dictionaries, refer to the previous section on dictionaries ",(0,a.jsx)(n.a,{href:"#dictionaries",children:"here"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Create a singleton dictionary storing our keys\nq)show k:enlist[`name]!enlist `Alexander`Stephan`Christoph`Alex\nname| Alexander Stephan Christoph Alex\n// We can do the same using the new q4.1 syntax\nq)show k1:([name:`Alexander`Stephan`Christoph`Alex])\nname| Alexander Stephan Christoph Alex\n// Verify that both methods obtain the same result\nq)k~k1\n1b\n"})}),"\n",(0,a.jsx)(n.p,{children:"Next, we need to create the table containing the values of our keyed table. This table will hold all the details corresponding to the keys. In our previous table, which stored names and ages of our users, we keyed on names, leaving only age as a column. Thus, we need to create another singleton dictionary for the values."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Create a singleton dictionary storing the values\nq)show v:enlist[`age]!enlist 36 26 34 34\nage| 36 26 34 34\n// We can do the same using the new q4.1 syntax\nq)show v1:([age:36 26 34 34])\nage| 36 26 34 34\n// Verify that both methods obtain the same result\nq)v~v1\n1b\n"})}),"\n",(0,a.jsx)(n.p,{children:"Finally, we can construct our keyed table by creating a dictionary of two tables, flipping the two column dictionaries we just created: the key dictionary and the value dictionary."}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"Remember, a table is nothing but a flipped column dictionary"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Create a keyed table by creating a dictionary of two tables\nq)show kt1:flip[k]!flip[v]\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n// Show our initial keyed table\nq)show kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n// Verify that both results match\nq)kt~kt1\n1b\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This conclusion should come as no surprise, given our initial investigation using ",(0,a.jsx)(n.code,{children:"0N!"}),". By examining the previous output, we can clearly see this concept. It's important to understand that the underlying k code for ",(0,a.jsx)(n.code,{children:"enlist"})," is ",(0,a.jsx)(n.code,{children:","})," and for ",(0,a.jsx)(n.code,{children:"flip"})," is ",(0,a.jsx)(n.code,{children:"+"}),". This has been illustrated in the exposed infrastructure section on code.kx.com ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/basics/exposed-infrastructure/",children:"here"})]}),"\n",(0,a.jsx)(n.admonition,{type:"danger",children:(0,a.jsx)(n.p,{children:"A note from KX: The use of k expressions in kdb+ applications is unsupported and strongly discouraged."})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Inspecting the output of 0N!\nq)0N!kt\n(+(,`name)!,`Alexander`Stephan`Christoph`Alex)!+(,`age)!,36 26 34 34\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n// Create a name singleton dictionary\nq)((,)`name)!((,)`Alexander`Stephan`Christoph`Alex)\nname| Alexander Stephan Christoph Alex\n// Flip it to create a table\nq)(+)((,)`name)!((,)`Alexander`Stephan`Christoph`Alex)\nname\n---------\nAlexander\nStephan\nChristoph\nAlex\n// Create an age singleton dictionary\nq)((,)`age)!((,)36 26 34 34)\nage| 36 26 34 34\n// Flip it to create a table \nq)(+)((,)`age)!((,)36 26 34 34)\nage\n---\n36\n26\n34\n34\n// Create a keyed table by creating a dictionary from two tables\nq)show kt2:((+)((,)`name)!((,)`Alexander`Stephan`Christoph`Alex))!(+)((,)`age)!((,)36 26 34 34)\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n// Verify that this actually matches our initial keyed table\nq)kt~kt2\n1b\n"})}),"\n",(0,a.jsx)(n.h3,{id:"indexing-into-tables",children:"Indexing into tables"}),"\n",(0,a.jsxs)(n.p,{children:["While this blog post focuses on the concepts of dictionaries and tables in KDB/Q, rather than providing a detailed guide on how to operate on them,  I would still like to give you a brief overview of operations on tables. This includes how to index into tables, insert or update records, and perform other basic operations. For a more comprehensive overview of table operations, please refer to Chapter 8 of ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/8_Tables/",children:"Q for Mortals"}),". In a future blog post, I will cover Q-SQL, detailing how to query KDB/Q tables, as well as joins \u2014 a powerful tool in KDB/Q for merging datasets."]}),"\n",(0,a.jsx)(n.p,{children:"First, let's explore how to index into a table. Indexing into a table is straightforward, similar to indexing into any other data structure. The only caveat is to be aware of whether we are dealing with a simple table or a keyed table. Let's examine both scenarios. Remember that a table can be viewed as a list of conforming dictionaries, and just as we can index into a list using a numerical index, we can do the same with a simple table."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\n// Using a single index returns a dictionary\nq)t 0\nname| `Alexander\nage | 36\nq)t 1\nname| `Stephan\nage | 26\nq)t 2\nname| `Christoph\nage | 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that the returned output is a dictionary, which makes perfect sense since each individual record in a table is a dictionary. However, if we use multiple indices to select two or more records, the result will still be a table. This is also makes sense, considering that a list of conforming dictionaries constitutes a table."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Using two or more indices returns a table\nq)t 0 1\nname      age\n-------------\nAlexander 36\nStephan   26\n// Nothing stops you from using the same index several times\nq)t 0 1 0\nname      age\n-------------\nAlexander 36\nStephan   26\nAlexander 36\n"})}),"\n",(0,a.jsx)(n.p,{children:"Additionally, we can use the first and last operator to retrieve the first and last record respectively."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)first t\nname| `Alexander\nage | 36\nq)last t\nname| `Christoph\nage | 34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Moreover, we can also use the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/take/",children:(0,a.jsx)(n.code,{children:"take"})})," to retrieve a number of rows from a table ",(0,a.jsx)(n.code,{children:"n#table"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)1#t\nname      age\n-------------\nAlexander 36\nq)2#t\nname      age\n-------------\nAlexander 36\nStephan   26\nq)3#t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"danger",children:[(0,a.jsxs)(n.p,{children:["Using the take operator requires careful attention. If you attempt to retrieve ",(0,a.jsx)(n.code,{children:"n"})," records where ",(0,a.jsx)(n.code,{children:"n"})," exceeds the total number of records in your table (you can check that using ",(0,a.jsx)(n.code,{children:"count t"}),"), take will fill the missing records by cycling through the beginning of the table until all ",(0,a.jsx)(n.code,{children:"n"})," records are obtained. To ensure you take an exact number of records without repetition, it's better to use the ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/sublist/",children:(0,a.jsx)(n.code,{children:"sublist"})})," operator."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)5#t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlexander 36\nStephan   26\nq)6#t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlexander 36\nStephan   26\nChristoph 34\nq)8#t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlexander 36\nStephan   26\nChristoph 34\nAlexander 36\nStephan   26\nq)5 sublist t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nq)2 sublist t\nname      age\n-------------\nAlexander 36\nStephan   26\n"})})]}),"\n",(0,a.jsx)(n.p,{children:"Another great feature of KDB/Q tables is the ability to retrieve entire columns at once by simply using the corresponding column name. This is one of the key reasons for KDB/Q's exceptional speed. As a column-oriented database, KDB/Q stores each column of a table as a vector in contiguous memory."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Retrieving the name column of our table\nq)t[`name]\n`Alexander`Stephan`Christoph\n// Retrieving the name and age column of our table\nq)t[`name`age]\nAlexander Stephan Christoph\n36        26      34\n// You can repeat column names\nq)t[`name`age`name]\nAlexander Stephan Christoph\n36        26      34\nAlexander Stephan Christoph\n"})}),"\n",(0,a.jsx)(n.p,{children:"As you can observe from above, each column is returned as a list."}),"\n",(0,a.jsx)(n.p,{children:"We can now combine indexing into a table using an index, with indexing into a table using a table column to retrieve one specific element of our table"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// We retrieve a specific element by using the index 2 and then the column name\nq)t[2;`name]\n`Christoph\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Next, let's look at how to index into a keyed table. Recall that a keyed table is essentially a dictionary of two tables. From the section on ",(0,a.jsx)(n.a,{href:"#indexing-into-a-dictionary",children:"Indexing into dictionaries"}),", we know that you use a key to index into a dictionary. Since a keyed table is a dictionary, the same principle applies."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\nq)kt[`Alexander]\nage| 36\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that just like a dictionary returns only the value associated with the key you used to index into it, a keyed table behaves similarly. From the above code snippet, we can see that when we index into a keyed table using a key, only the value part of the keyed table (i.e., the columns that are not part of the key) is returned."}),"\n",(0,a.jsx)(n.p,{children:"But can we index into a keyed table using a numerical index? Like we did with a simple table?"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt[0]\n'type\n  [0]  kt[0]\n       ^\n"})}),"\n",(0,a.jsxs)(n.p,{children:["No, we can't. As you can see from the example above, using a numerical index on a keyed table will throw a ",(0,a.jsx)(n.code,{children:"type"})," error. This behavior occurs because our table is keyed on a column of type symbol. Using any type other than a symbol to index into the keyed table will result in a ",(0,a.jsx)(n.code,{children:"type"})," error. However, if we use a numerical type for our key column, we can use a numerical index to index into this keyed table. Let's look at an example."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// First, let's create a keyed table using a numerical key\nq)show kt3:([index:0 1 2 3] name:`Alexander`Stephan`Christoph`Alex)\nindex| name\n-----| ---------\n0    | Alexander\n1    | Stephan\n2    | Christoph\n3    | Alex\n// Indexing into our new keyed table using the numerical index 2\nq)kt3 2\nname| Christoph\n"})}),"\n",(0,a.jsxs)(n.p,{children:["But what about the other methods of retrieving data that we used on simple tables, such as ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/first/#first",children:(0,a.jsx)(n.code,{children:"first"})}),", ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/first/#first",children:(0,a.jsx)(n.code,{children:"last"})}),", ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/take/",children:(0,a.jsx)(n.code,{children:"take"})}),", and ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q/ref/sublist/",children:(0,a.jsx)(n.code,{children:"sublist"})}),"? Do these methods also work on our keyed tables, and do they produce the same or similar results? Let's find out."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)first kt\nage| 36\nq)last kt\nage| 34\nq)1#kt\nname     | age\n---------| ---\nAlexander| 36\nq)5#kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\nAlexander| 36\nq)5 sublist kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With the exception of ",(0,a.jsx)(n.code,{children:"first"})," and ",(0,a.jsx)(n.code,{children:"last"}),", all other operators work the same way on keyed tables as they do on simple tables. The ",(0,a.jsx)(n.code,{children:"take"})," operator will return ",(0,a.jsx)(n.code,{children:"n"}),"  records, cycling through the table until ",(0,a.jsx)(n.code,{children:"n"})," records are retrieved if ",(0,a.jsx)(n.code,{children:"n"})," is larger than the ",(0,a.jsx)(n.code,{children:"count"})," of our table. The ",(0,a.jsx)(n.code,{children:"sublist"})," operator behaves as expected, selecting ",(0,a.jsx)(n.code,{children:"n"})," records from the table. However, the ",(0,a.jsx)(n.code,{children:"first"})," and ",(0,a.jsx)(n.code,{children:"last"})," operators produce different results for keyed tables compared to simple tables. When considering keyed tables as a dictionary of two tables, the results make sense: ",(0,a.jsx)(n.code,{children:"first"})," and ",(0,a.jsx)(n.code,{children:"last"})," return the first and last value parts of the first and last records, respectively. Similar to what the ",(0,a.jsx)(n.code,{children:"first"})," and ",(0,a.jsx)(n.code,{children:"last"})," operator would return when applied to a dictionary. Because the value part of the keyed table is a table itself, and both operators, ",(0,a.jsx)(n.code,{children:"first"})," and ",(0,a.jsx)(n.code,{children:"last"})," only return one record of this table, the result will be a dictionary."]}),"\n",(0,a.jsxs)(n.p,{children:["One cool feature of the ",(0,a.jsx)(n.code,{children:"take"})," operator when used with keyed tables is its ability to retrieve specific records using the keys of the table. Let me demonstrate:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\nq)([] name:`Alexander`Christoph`Stephan`Alex)#kt\nname     | age\n---------| ---\nAlexander| 36\nChristoph| 34\nStephan  | 26\n"})}),"\n",(0,a.jsx)(n.p,{children:"This is particularly useful if you want to retrieve records for specific keys, or in a specific order."}),"\n",(0,a.jsx)(n.h3,{id:"appending-records-to-tables",children:"Appending records to tables"}),"\n",(0,a.jsxs)(n.p,{children:["In the final section of this blog post, we will explore the basic methods for inserting data into a table. This process slightly varies between simple tables and keyed tables. A comprehensive discussion on how to insert data into tables is beyond the scope of this post. For a detailed explanation, please refer to the first section of ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/",children:"Chapter 9: Queries and Q-Sql"})," in ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/",children:"Q for Mortals"})]}),"\n",(0,a.jsx)(n.p,{children:"Let's start by appending some data to our tables:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// Review what was in our table\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\n// Append a new record by joining a dictionary\nq)t,`name`age!(`Alex;40)\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      40\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\n// Use assign in place to persist the changes\nq)t,:`name`age!(`Alex;40)\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      40\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can append records to a table by joining a dictionary to it. Since a table can be viewed as a list of conforming dictionaries, you can join a dictionary that matches the schema of your table. To persist the changes, you can use in-place assignment."}),"\n",(0,a.jsx)(n.p,{children:"A great feature of appending records via a dictionary is that the order of the dictionary's keys does not need to match the order of the table's columns. As long as the data types of the keys match the data types of the columns, the order of the keys is irrelevant. However, the keys in the dictionary must correspond to the column names in the table. Let's look at an example."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t,: `age`name!(45;`Joe)\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      34\nJoe       45\n"})}),"\n",(0,a.jsx)(n.p,{children:"But that's not all\u2014it's not just the order of the keys that can differ. We can also insert a dictionary with fewer keys than the table has columns. The missing columns are automatically filled with a null value of the appropriate column type."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t,:(enlist `name)!(enlist `Ted)\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      34\nJoe       45\nTed\nq)0N!t\n+`name`age!(`Alexander`Stephan`Christoph`Alex`Joe`Ted;36 26 34 34 45 0N)\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      34\nJoe       45\nTed\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, attempting to insert a dictionary with more keys than the table has columns will result in a mismatch error."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)t,:`name`age`iq!(`Bob;45;127)\n'mismatch\n  [0]  t,:`name`age`iq!(`Bob;45;127)\n        ^\n"})}),"\n",(0,a.jsx)(n.p,{children:"Appending records via a dictionary is indeed a powerful method, but it can involve quite a bit of typing. Luckily for us, this can be simplified and we actually don't have to type the full dictionary"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)show t,:(`Natalia;21)\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      40\nNatalia   21\n"})}),"\n",(0,a.jsx)(n.p,{children:"But what happens if we are trying to insert a record where one of the column types does not match the schema of our existing table? As you would expect, an error will be thrown"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'q)meta t\nc   | t f a\n----| -----\nname| s\nage | j\nq)t,:(`Tommy;35.5)\n\'type\n  [0]  t,:(`Tommy;35.5)\n        ^\nq)t,:("Tommy";35)\n\'length\n  [0]  t,:("Tommy";35)\n        ^\nq)t,:(45;35)\n\'type\n  [0]  t,:(45;35)\n        ^\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In our first attempt, we try to append a record where the age is a float. However, as you can see from the meta of our table, the age column is of type long. The obvious error thrown is a ",(0,a.jsx)(n.code,{children:"type"})," error. Our second append throws a ",(0,a.jsx)(n.code,{children:"length"})," error. This might come as a surprise initially, but let's reflect about it for a moment. We are trying to append a record with a string representation of the name. As we know, strings technically don't exist in KDB/Q but are represented as a list of char characters. Hence, what we are actually trying to do is append a list of char characters as the name. Since the name column is of type symbol, meaning each entry should be a symbol ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/2_Basic_Data_Types_Atoms/",children:"atom"}),", we get a ",(0,a.jsx)(n.code,{children:"length"})," error when trying to insert a list. Our last attempt fails for obvious reasons: we are trying to insert a numerical value for our name column, resulting in a ",(0,a.jsx)(n.code,{children:"type"})," error."]}),"\n",(0,a.jsx)(n.p,{children:"The above examples highlight the importance of defining the schema of your tables at creation. Creating an empty table without specifying column types is bad practice, as the types will be inferred from the first record you add. This can lead to insert or append failures and potentially serious production outages."}),"\n",(0,a.jsxs)(n.p,{children:["Imagine you create a table to store items and their corresponding prices, including the ID for each item and their price. However, when creating the table schema, you do not define the types for the columns. As shown by the meta data, the columns have no defined type after the table is created. You then proceed to insert the first record, but mistakenly enter the price of the first item (10\xa3) as an integer instead of a floating point number. When you attempt to insert the second item, which has a price of 3.8\xa3, a ",(0,a.jsx)(n.code,{children:"type"})," error is thrown."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)t1:([] id:(); price:())\nq)meta t1\nc    | t f a\n-----| -----\nid   |\nprice|\nq)t1,:(0;10)\nq)t1\nid price\n--------\n0  10\nq)meta t1\nc    | t f a\n-----| -----\nid   | j\nprice| j\nq)t1,:(2;3.8)\n'type\n  [0]  t1,:(2;3.8)\n         ^\n"})}),"\n",(0,a.jsx)(n.p,{children:"A much better approach is to specify the types of your columns when creating the table."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)t1:([] id:`int$(); price:`float$())\nq)meta t1\nc    | t f a\n-----| -----\nid   | i\nprice| f\nq)t1,:(0;10)\n'type\n  [0]  t1,:(0;10)\n         ^\nq)t1,:(0;10.0)\nq)t1\nid price\n--------\n0  10\nq)t1,:(1;3.8)\nq)t1\nid price\n--------\n0  10\n1  3.8\n"})}),"\n",(0,a.jsx)(n.p,{children:"You will still receive an error if you try to insert an integer price value rather than a floating point value, however, now the error is perfectly justified and you simply can avoid it by inserting a floating point price value."}),"\n",(0,a.jsx)(n.p,{children:"Next, let's look at how we can append a record to a keyed table. Remember, a keyed table is a dictionary of two tables."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt,:(enlist (enlist `name)!enlist `Alex)!enlist (enlist `age)!enlist 34\nq)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"That looks more complicated than it's supposed to be. Let's break it down into simople steps."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"// From right to left\n// First, let's remember how to create a singleton dictionary\nq)(enlist `age)!enlist 34\nage| 34\n// Next, a table can be viewed as a list of dictionary, using enlist to create a list of dictionaries\nq)enlist (enlist `age)!enlist 34\nage\n---\n34\n// Next we create the key dictionary of our keyed table\nq)(enlist (enlist `name)!enlist `Alex)\nname\n----\nAlex\n// Finally, putting everything together, we obtain a record we can append to our keyed table\nq)(enlist (enlist `name)!enlist `Alex)!enlist (enlist `age)!enlist 34\nname| age\n----| ---\nAlex| 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"That wasn't that complicated after all. However, still a lot of typing. Wouldn't it be great if this would be easier? Don't worry, luckily there is an easier syntax for above"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt,:(`Alex;34)\nq)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\n"})}),"\n",(0,a.jsx)(n.p,{children:"It's that easy, as long as the the fields you provide match exactly with both key and column values, you can use a list."}),"\n",(0,a.jsx)(n.h3,{id:"inserting-into-tables",children:"Inserting into tables"}),"\n",(0,a.jsx)(n.h4,{id:"simple-tables",children:"Simple tables"}),"\n",(0,a.jsxs)(n.p,{children:["Similar to appending records to an existing table, there are various ways to insert records into a table. While the keyword for this operation is always the same, namely ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#911-basic-insert",children:(0,a.jsx)(n.code,{children:"insert"})}),", the format of the records can vary. I'll cover the basics and leave the detailed exploration to you."]}),"\n",(0,a.jsx)(n.p,{children:"As with appending a record to a table, we can also insert a dictionary into a table. This should be obvious by now, considering that a table can be seen as a list of conforming dictionaries."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`t insert `name`age!(`Alex;34)\n,3\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      34\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The only caveat to be aware of is that the ",(0,a.jsx)(n.code,{children:"insert"})," operator uses pass-by-name, so you must reference the table by its symbol value. As a result, ",(0,a.jsx)(n.code,{children:"insert"})," only works with global variables."]}),"\n",(0,a.jsx)(n.p,{children:"Just as with appending a dictionary to a table, we can also shorten the syntax when inserting a new record into a table. We can insert a list of values, provided that each value matches the type of its corresponding column, essentially omitting the column names. Let's look at an example."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nq)`t insert (`Alex;40)\n,3\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      40\n"})}),"\n",(0,a.jsx)(n.p,{children:"That worked like a charm. But what about inserting multiple records? This should follow a similar pattern, right?"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`t insert ((`Natalia;21);(`Joe;22);(`Ted;39))\n'length\n  [0]  `t insert ((`Natalia;21);(`Joe;22);(`Ted;39))\n          ^\n"})}),"\n",(0,a.jsx)(n.p,{children:"Surprisingly, it doesn't work that way. But don't worry, we have the solution you're looking for. When inserting multiple records simultaneously, you need to pass the records as a list of lists, where each sublist corresponds to the values for each column."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`t insert (`Natalia`Joe`Ted;21 22 39)\n4 5 6\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      40\nNatalia   21\nJoe       22\nTed       39\n"})}),"\n",(0,a.jsx)(n.p,{children:"Even though this might not be the most intuitive way to insert multiple records into a table, it's precisely the pattern used to publish data from the Feedhandler to the Tickerplant. While inserting multiple records as a list of dictionaries is more intuitive, it requires significantly more typing."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`t insert ((`name`age!(`Alex;34));(`name`age!(`Natalia;21));(`name`age!(`Bob;45)))\n3 4 5\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nAlex      34\nNatalia   21\nBob       45\n"})}),"\n",(0,a.jsx)(n.p,{children:"But hold on a moment, how many times have we heard that a table is actually a list of dictionaries? It seems we can't stress this enough, as repetition helps it stick. If a list of dictionaries is a table, we should be able to insert multiple records by simply inserting a table of new records to the existing table. Let's demonstrate this next."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nq)`t insert ([] name:`Natalia`Alex`Bob; age:21 23 45)\n3 4 5\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nNatalia   21\nAlex      23\nBob       45\n"})}),"\n",(0,a.jsx)(n.p,{children:"That was pretty neat. This concludes the basics of inserting records into a simple table. Next, let's explore how we can insert records into a keyed table."}),"\n",(0,a.jsx)(n.h4,{id:"keyed-tables",children:"Keyed tables"}),"\n",(0,a.jsx)(n.p,{children:"Keyed tables behave quite similarly to simple tables when it comes to inserting new records, with one key difference (pun intended): since the keys of a keyed table are supposed to be unique, you cannot insert a new record with a key that already exists."}),"\n",(0,a.jsx)(n.p,{children:"As you can see below, inserting a new record into a keyed table when the key doesn't exist just works as expected."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\nq)`kt insert (enlist ((enlist `name)!enlist `Natalia))!(enlist (enlist `age)!enlist 21)\n,4\nq)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\nNatalia  | 21\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, if we try the same operation again, an error will be thrown"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`kt insert (enlist ((enlist `name)!enlist `Natalia))!(enlist (enlist `age)!enlist 21)\n'insert\n  [0]  `kt insert (enlist ((enlist `name)!enlist `Natalia))!(enlist (enlist `age)!enlist 21)\n           ^\n"})}),"\n",(0,a.jsx)(n.p,{children:"This makes perfect sense, as keys are meant to be unique after all."}),"\n",(0,a.jsx)(n.p,{children:"The above syntax is quite verbose and not particularly easy to read. Let's see if we can simplify this operation."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`kt insert (`Chris;33)\n,5\nq)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nAlex     | 34\nNatalia  | 21\nChris    | 33\n"})}),"\n",(0,a.jsx)(n.p,{children:"As with simple tables, you can insert into a keyed table by simply providing a list of values, ensuring that each value matches the types of the columns in your keyed table."}),"\n",(0,a.jsx)(n.p,{children:"Furthermore, as previously discussed, you can insert records that contain fewer columns than the table you are inserting into. In such cases, the missing columns will be populated with null values corresponding to their column types."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt2\nname     | age id\n---------| ------\nAlexander| 36  0\nStephan  | 26  1\nChristoph| 34  2\nAlex     | 34  3\nq)`kt2 insert (enlist ((enlist `name)!enlist `Natalia))!(enlist (enlist `age)!enlist 21)\n,4\nq)kt2\nname     | age id\n---------| ------\nAlexander| 36  0\nStephan  | 26  1\nChristoph| 34  2\nAlex     | 34  3\nNatalia  | 21\n"})}),"\n",(0,a.jsx)(n.p,{children:"It should not come as a surprise that you can insert one keyed table into another keyed table. However, for completeness, let's demonstrate this example as well."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nq)`kt insert ([name:enlist `Natalia] age:enlist 21)\n,3\nq)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nNatalia  | 21\n"})}),"\n",(0,a.jsx)(n.h3,{id:"upsert-fusion-between-insert-and-update",children:"Upsert: Fusion between insert and update"}),"\n",(0,a.jsxs)(n.p,{children:["If you're an anime enthusiast like me, who's watched ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dragon_Ball_Z",children:"Dragon Ball Z"})," you're likely familiar with the concept of fusions. It's when two characters merge to become a more powerful fighter, blending the strengths of both individuals. For those who haven't seen Dragon Ball Z and aren't familiar with the concept of fusion, the image below illustrates the fusion between Goku and Vegeta, two of the main characters of Dragon Ball Z."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Fusion",src:t(4982).A+"",width:"1140",height:"570"})}),"\n",(0,a.jsxs)(n.p,{children:["You might wonder why I'm suddenly mentioning anime. Have I lost my mind? Perhaps too much KDB/Q code has driven me crazy? Not at all. The reason for bringing up fusions is because ",(0,a.jsx)(n.a,{href:"https://code.kx.com/q4m3/9_Queries_q-sql/#92-upsert",children:(0,a.jsx)(n.code,{children:"upsert"})})," can be seen exactly as that - a fusion between insert and update. It creates a new, more powerful operator that combines the strengths of both individual operations."]}),"\n",(0,a.jsx)(n.p,{children:"Let's explore how this powerful operator works. For simple tables, upsert works much like insert, with the key distinction that upsert also functions on local variables. It supports both, pass-by-name and pass-by-value approaches."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nNatalia   21\nAlex      23\nBob       45\nq)t upsert (`Joe;29)\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nNatalia   21\nAlex      23\nBob       45\nJoe       29\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nNatalia   21\nAlex      23\nBob       45\nq)`t upsert (`Joe;29)\n`t\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nNatalia   21\nAlex      23\nBob       45\nJoe       29\n"})}),"\n",(0,a.jsx)(n.p,{children:"Since a simple table can contain duplicate records, where no key column exists to enforce uniqueness, upsert will indeed insert duplicate records just like insert would."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)`t insert (`Joe;29)\n,7\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nNatalia   21\nAlex      23\nBob       45\nJoe       29\nJoe       29\nq)`t upsert (`Joe;29)\n`t\nq)t\nname      age\n-------------\nAlexander 36\nStephan   26\nChristoph 34\nNatalia   21\nAlex      23\nBob       45\nJoe       29\nJoe       29\nJoe       29\n"})}),"\n",(0,a.jsx)(n.p,{children:"On a keyed table, upsert behaves differently: if the key of the record you are trying to upsert already exists, it updates the values of the corresponding record with the new values from the upserted record. If the key does not exist yet, it simply inserts the new record into the keyed table."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"q)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nNatalia  | 21\nq)`kt upsert (`Natalia;25)\nq)kt\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nNatalia  | 25\nq)kt upsert (`Joe;29)\nname     | age\n---------| ---\nAlexander| 36\nStephan  | 26\nChristoph| 34\nNatalia  | 25\nJoe      | 29\n"})}),"\n",(0,a.jsx)(n.p,{children:"Great! We've covered a lot in this blog post. I hope it has enhanced your understanding of dictionaries and tables. Now, take some time to review and ensure you internalise  the concepts well. If you have any questions, don't hesitate to ask. Until then, happy coding!"})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},4982:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/fusion-28aa89d6b55f2d72a50635474d514b27.jpg"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(6540);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);